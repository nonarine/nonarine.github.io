var DeRender=(()=>{var It=Object.defineProperty;var Mr=Object.getOwnPropertyDescriptor;var Pr=Object.getOwnPropertyNames;var Lr=Object.prototype.hasOwnProperty;var ze=(n,e)=>()=>(n&&(e=n(n=0)),e);var Si=(n,e)=>{for(var t in e)It(n,t,{get:e[t],enumerable:!0})},Dr=(n,e,t,i)=>{if(e&&typeof e=="object"||typeof e=="function")for(let r of Pr(e))!Lr.call(n,r)&&r!==t&&It(n,r,{get:()=>e[r],enumerable:!(i=Mr(e,r))||i.enumerable});return n};var Br=n=>Dr(It({},"__esModule",{value:!0}),n);var Ut,a,X=ze(()=>{Ut=class{constructor(){this.enabled=!0,this.verbosity="info",this.maxLogs=100,this.logs=[],this.consoleHooked=!1,this.originalConsole={},this.outputElement=null,this.silenced=!1,this.silencedBuffer=[],this.maxSilencedLogs=5e3}setOutputElement(e){this.outputElement=e}setEnabled(e){this.enabled=e}setVerbosity(e){let t=this.verbosity==="silent";this.verbosity=e;let i=e==="silent";t&&!i?this.unsilence():!t&&i&&this.silence()}silence(){this.silenced||(this.silenced=!0,this.info("Entering silent mode - logs will be buffered",null,!1))}unsilence(){if(!this.silenced)return;let e=this.silencedBuffer.length;this.silenced=!1,this.flush(),this.info(`Exited silent mode - flushed ${e} buffered logs`,null,!1)}flush(){if(this.silencedBuffer.length===0)return;let e=this.silencedBuffer.length;this.info(`Flushing ${e} silenced logs...`,null,!1);let t=this.consoleHooked?this.originalConsole.log:console.log;for(let i of this.silencedBuffer){let r=`[${i.timestamp}] ${i.message}`;i.data?t(r,i.data):t(r),i.stack&&t("Stack trace:",i.stack)}this.logs.push(...this.silencedBuffer),this.logs.length>this.maxLogs&&(this.logs=this.logs.slice(-this.maxLogs)),this.silencedBuffer=[],this.updateUI()}clearSilencedBuffer(){let e=this.silencedBuffer.length;this.silencedBuffer=[],this.info(`Cleared ${e} buffered logs`,null,!1)}shouldLog(e){if(!this.enabled)return!1;let t={verbose:0,debug:1,info:2,warn:3,error:4,silent:0};return t[e]>=t[this.verbosity]}log(e,t,i=null,r=!0){if(!this.shouldLog(e))return;let o=new Date().toLocaleTimeString(),s=null;i instanceof Error&&(s=i.stack,i={message:i.message,name:i.name,stack:i.stack});let l={timestamp:o,level:e,message:t,data:i,stack:s};if(this.silenced&&r){this.silencedBuffer.push(l),this.silencedBuffer.length>this.maxSilencedLogs&&this.silencedBuffer.shift();return}this.logs.push(l),this.logs.length>this.maxLogs&&this.logs.shift();let c=this.consoleHooked?this.originalConsole.log:console.log,d=`[${o}] ${t}`;i?c(d,i):c(d),s&&c("Stack trace:",s),this.updateUI()}verbose(e,t=null,i=!0){this.log("verbose",e,t,i)}debug(e,t=null,i=!0){this.log("debug",e,t,i)}info(e,t=null,i=!0){this.log("info",e,t,i)}warn(e,t=null,i=!0){this.log("warn",e,t,i)}error(e,t=null,i=!0){this.log("error",e,t,i)}clear(){this.logs=[],this.updateUI()}updateUI(){let e=this.outputElement?$(this.outputElement):$("#debug-output");if(!(!e||e.length===0)){e.empty();for(let t of this.logs){let i=$('<div class="debug-log"></div>').addClass(t.level),r=$('<span class="debug-timestamp"></span>').text(t.timestamp),o=$("<span></span>").text(t.message);if(i.append(r).append(o),t.data){let s=typeof t.data=="object"?JSON.stringify(t.data,null,2):String(t.data),l=$("<span></span>").text(" | "+s).css("color","#888");i.append(l)}if(t.stack){let s=$("<span></span>").text(" [stack]").css({color:"#ff6b6b",cursor:"pointer","text-decoration":"underline"}),l=$("<pre></pre>").text(t.stack).css({display:"none",color:"#ff6b6b","font-size":"9px",margin:"4px 0 0 20px",padding:"4px",background:"#2a0000","border-left":"2px solid #ff6b6b","overflow-x":"auto"});s.on("click",function(){l.toggle()}),i.append(s),i.append(l)}e.append(i)}e.scrollTop(e[0].scrollHeight)}}getLogs(){return this.logs}getSilencedBuffer(){return this.silencedBuffer}isSilenced(){return this.silenced}getBufferStats(){return{silenced:this.silenced,bufferSize:this.silencedBuffer.length,maxBufferSize:this.maxSilencedLogs,bufferUsagePercent:Math.round(this.silencedBuffer.length/this.maxSilencedLogs*100)}}hookConsole(){if(this.consoleHooked){this.warn("Console already hooked");return}this.originalConsole={log:console.log,info:console.info,warn:console.warn,error:console.error};let e=this;console.log=function(...t){e.originalConsole.log.apply(console,t);let i=t.map(r=>typeof r=="object"?JSON.stringify(r):String(r)).join(" ");e.debug("[console.log] "+i)},console.info=function(...t){e.originalConsole.info.apply(console,t);let i=t.map(r=>typeof r=="object"?JSON.stringify(r):String(r)).join(" ");e.debug("[console.info] "+i)},console.warn=function(...t){e.originalConsole.warn.apply(console,t);let i=t.map(r=>typeof r=="object"?JSON.stringify(r):String(r)).join(" ");e.warn("[console] "+i)},console.error=function(...t){e.originalConsole.error.apply(console,t);let i=t.map(r=>typeof r=="object"?JSON.stringify(r):String(r)).join(" ");e.error("[console] "+i)},this.consoleHooked=!0,this.info("Console hooked - browser console calls will echo to debug console")}unhookConsole(){if(!this.consoleHooked){this.warn("Console not hooked");return}console.log=this.originalConsole.log,console.info=this.originalConsole.info,console.warn=this.originalConsole.warn,console.error=this.originalConsole.error,this.consoleHooked=!1,this.info("Console unhooked - restored original behavior")}},a=new Ut});function Gi(n){return n=n.replace(/([a-z]+)\^(\d+)/g,(e,t,i)=>{let r=parseInt(i);return r===0?"1":r===1?t:Array(r).fill(t).join("*")}),n=n.replace(/pow\(([a-z]+),\s*(\d+)\)/g,(e,t,i)=>{let r=parseInt(i);return r===0?"1":r===1?t:r<=4?Array(r).fill(t).join("*"):e}),n}function xe(n,e){if(a.verbosity="verbose",a.info("=== JACOBIAN COMPUTATION START ==="),a.info("Timestamp:",new Date().toISOString()),a.info("Nerdamer loaded:",!!window.nerdamer),a.info("Nerdamer type:",typeof window.nerdamer),a.info("Nerdamer is function:",typeof window.nerdamer=="function"),a.info("Nerdamer.diff exists:",window.nerdamer&&typeof window.nerdamer.diff=="function"),a.info("Nerdamer.clear exists:",window.nerdamer&&typeof window.nerdamer.clear=="function"),a.info("Input expressions:",n.toString()),a.info("Dimensions:",e),!window.nerdamer)return a.error("Nerdamer not loaded - cannot compute Jacobian"),null;if(typeof window.nerdamer!="function")return a.error("Nerdamer is not a function - invalid state"),null;if(!window.nerdamer.diff)return a.error("Nerdamer.diff not available - incomplete initialization"),null;try{window.nerdamer&&window.nerdamer.clear&&(a.verbose("Clearing Nerdamer cache"),window.nerdamer.clear("all")),a.verbose("Testing Nerdamer consistency...");try{let s=window.nerdamer.diff(window.nerdamer("x*y"),"x").toString();window.nerdamer.clear("all");let l=window.nerdamer.diff(window.nerdamer("x*y"),"x").toString();a.verbose("Consistency test: d(x*y)/dx"),a.verbose(`  First result:  ${s}`),a.verbose(`  Second result: ${l}`),a.verbose(`  Consistent: ${s===l}`),s!==l&&a.error("WARNING: Nerdamer is giving inconsistent results!")}catch(r){a.warn("Consistency test failed:",r.message)}let t=n.map(r=>{let o=r.replace(/atan2\s*\(\s*([^,]+)\s*,\s*([^)]+)\s*\)/g,"atan(($1)/($2))");return o!==r&&a.verbose(`Replaced atan2 for differentiation: "${r}" \u2192 "${o}"`),o}),i=[];for(let r=0;r<e;r++){let o=[],s=t[r];a.verbose(`Row ${r}: differentiating expression "${s}"`);for(let l=0;l<e;l++){let c=Hr[l];try{a.verbose(`  Computing \u2202(${s})/\u2202${c}...`);let d=window.nerdamer.diff(window.nerdamer(s),c).toString();a.verbose(`  Raw derivative: ${d}`);let u=Gi(window.nerdamer(`simplify(${d})`).toString());a.verbose(`  Optimized: ${u}`),o.push(u)}catch(d){a.warn(`Failed to differentiate expression "${s}" w.r.t. ${c}: ${d.message}`),o.push("0")}}i.push(o)}a.info("=== JACOBIAN COMPUTATION COMPLETE ==="),a.info("Final Jacobian matrix:");for(let r=0;r<i.length;r++)a.info(`  Row ${r}: [${i[r].join(", ")}]`);return i}catch(t){return a.error("Failed to compute Jacobian matrix",t),null}}function ke(n){if(!n||!Array.isArray(n))return!1;for(let e of n){if(!Array.isArray(e))return!1;for(let t of e)if(typeof t!="string"||t==="")return!1}return!0}function Ot(n){if(!n||!Array.isArray(n))return a.error("Invalid Jacobian for inversion"),null;let e=n.length;if(e<2||e>4)return a.error(`Jacobian inversion only supported for 2x2, 3x3, and 4x4 matrices (got ${e}x${e})`),null;try{let t=n.map(r=>`[${r.join(",")}]`).join(",");a.verbose("Inverting Jacobian matrix:",`matrix(${t})`),window.nerdamer.setVar("J_temp",`matrix(${t})`),window.nerdamer.setVar("J_inv","invert(J_temp)");let i=[];for(let r=0;r<e;r++){let o=[];for(let s=0;s<e;s++){let l=window.nerdamer(`matget(J_inv, ${r}, ${s})`).toString(),c=Gi(l);o.push(c)}i.push(o)}a.verbose("Inverted Jacobian:");for(let r=0;r<i.length;r++)a.verbose(`  Row ${r}: [${i[r].join(", ")}]`);return i}catch(t){return a.error("Failed to invert Jacobian:",t.message),null}}var Hr,Gt=ze(()=>{X();Hr=["x","y","z","w","u","v"]});function oo(n){let e=[],t=/atan2\s*\(\s*([^,]+)\s*,\s*([^)]+)\s*\)/g,i;for(;(i=t.exec(n))!==null;)e.push({fullMatch:i[0],numerator:i[1].trim(),denominator:i[2].trim()});return e}function ir(n,e){let{numerator:t,denominator:i,fullMatch:r}=e,o=`PI/2 - atan2(${i}, ${t})`,s=n.map(c=>c.replace(r,o));return{condition:`abs(${i}) <= abs(${t})`,forwardTransforms:s}}function rr(n,e){let t=[],i=[];if(n.forEach((r,o)=>{oo(r).forEach(l=>{i.push({...l,transformIndex:o})})}),i.length===0)return[{condition:"true",forwardTransforms:n}];if(e===2||e===3&&i.length===1){let r=i[0];return t.push({condition:`abs(${r.denominator}) >= abs(${r.numerator})`,forwardTransforms:n}),t.push(ir(n,r)),t}if(e===3&&i.length>=2){let r=i[i.length-1];return t.push({condition:`abs(${r.denominator}) >= abs(${r.numerator})`,forwardTransforms:n}),t.push(ir(n,r)),t}return[{condition:"true",forwardTransforms:n}]}function or(n,e){if(n==="true")return"true";let t=n;return e.forEach((i,r)=>{let o=["x","y","z","w"][r],s=new RegExp(`\\b${i}\\b`,"g");t=t.replace(s,`pos.${o}`)}),t=t.replace(/\bPI\b/g,"3.14159265359"),t}var nr=ze(()=>{});var ar={};Si(ar,{CoordinateSystem:()=>j,PRESET_COORDINATE_SYSTEMS:()=>Ae,createCartesianSystem:()=>sr,getCartesianSystem:()=>ue,getCoordinateSystem:()=>no,getPresetsForDimension:()=>ii});function no(n){return Ae[n]||null}function ii(n){let e=[];for(let[t,i]of Object.entries(Ae))i.dimensions===n&&e.push({key:t,system:i});return e}function ue(n){let e=`cartesian${n}d`;return Ae[e]||sr(n)}function sr(n){let e=["x","y","z","w","u","v"].slice(0,n);return new j(`Cartesian ${n}D`,n,e.map(t=>({label:t,displayLabel:t})),e)}var j,Ae,Le=ze(()=>{Gt();nr();j=class n{constructor(e,t,i,r,o=null,s=!1,l=null){this.name=e,this.dimensions=t,this.variables=i,this.forwardTransforms=r,this.inverseTransforms=o,this.useIterativeSolver=s,this.charts=l||rr(r,t)}getVariableNames(){return this.variables.map(e=>e.label)}getDisplayLabels(){return this.variables.map(e=>e.displayLabel)}generateForwardTransformGLSL(e,t){let i=this.getVariableNames(),r=`vec${this.dimensions}`,o=this.forwardTransforms.map((s,l)=>{let c=t(s,e);return`    result.${["x","y","z","w"][l]} = ${c};`}).join(`
`);return`
// Forward transform: Cartesian \u2192 ${this.name}
${r} transformToNative(${r} pos) {
    ${r} result;
    float ${e.map((s,l)=>`${s} = pos.${["x","y","z","w"][l]}`).join(", ")};
${o}
    return result;
}`}generateVelocityTransformGLSL(e,t){if(this.charts&&this.charts.length>1)return this.generateMultiChartVelocityTransformGLSL(e,t);let i=this.charts&&this.charts.length===1?this.charts[0].forwardTransforms:this.forwardTransforms,r=xe(i,this.dimensions);if(!r)return console.error("Failed to compute Jacobian for coordinate system:",this.name),`
// Velocity transform: ${this.name} \u2192 Cartesian (IDENTITY FALLBACK - ERROR)
// WARNING: Jacobian computation failed, using identity transform
vec${this.dimensions} transformVelocityToCartesian(vec${this.dimensions} vel_native, vec${this.dimensions} pos) {
    return vel_native; // INCORRECT: Should use inverse Jacobian
}`;let o=Ot(r);if(!o)return console.error("Failed to invert Jacobian for coordinate system:",this.name),console.error("Forward Jacobian was:",r),`
// Velocity transform: ${this.name} \u2192 Cartesian (IDENTITY FALLBACK - ERROR)
// WARNING: Jacobian inversion failed, using identity transform
// This will produce INCORRECT results for non-Cartesian coordinates!
vec${this.dimensions} transformVelocityToCartesian(vec${this.dimensions} vel_native, vec${this.dimensions} pos) {
    return vel_native; // INCORRECT: Jacobian inversion failed
}`;let s=`vec${this.dimensions}`,l=["x","y","z","w"],c=[];for(let d=0;d<this.dimensions;d++){let h=o[d].map((g,f)=>`(${t(g,e)}) * vel_native.${l[f]}`);c.push(`    result.${l[d]} = ${h.join(" + ")};`)}return`
// Velocity transform: ${this.name} \u2192 Cartesian via Inverse Jacobian
// J_forward = [${r.map(d=>"["+d.join(", ")+"]").join(`,
//             `)}]
// J_inverse = [${o.map(d=>"["+d.join(", ")+"]").join(`,
//             `)}]
${s} transformVelocityToCartesian(${s} vel_native, ${s} pos) {
    ${s} result;
    float ${e.map((d,u)=>`${d} = pos.${l[u]}`).join(", ")};
${c.join(`
`)}
    return result;
}`}generateMultiChartVelocityTransformGLSL(e,t){let i=`vec${this.dimensions}`,r=["x","y","z","w"],o=this.charts.map((c,d)=>{let u=xe(c.forwardTransforms,this.dimensions);if(!u)return console.warn(`Failed to compute Jacobian for chart ${d} of ${this.name}`),null;let h=Ot(u);if(!h)return console.warn(`Failed to invert Jacobian for chart ${d} of ${this.name}`),null;let g=[];for(let f=0;f<this.dimensions;f++){let x=h[f].map((y,b)=>`(${t(y,e)}) * vel_native.${r[b]}`);g.push(`        result.${r[f]} = ${x.join(" + ")};`)}return{condition:c.condition,jacobian:u,inverseJacobian:h,matrixMultCode:g}}).filter(c=>c!==null);if(o.length===0)return console.error("All charts failed for coordinate system:",this.name),`
// Velocity transform: ${this.name} \u2192 Cartesian (ERROR: All charts failed)
${i} transformVelocityToCartesian(${i} vel_native, ${i} pos) {
    return vel_native; // FALLBACK: All charts failed
}`;let s=o.map((c,d)=>{let u=or(c.condition,e),h=d===0?"if":"else if",g=u==="true"?"":` (${u})`;return`    ${h}${g} {
        // Chart ${d+1}: Avoid singularities when ${c.condition}
${c.matrixMultCode.join(`
`)}
    }`}).join(" "),l=o.map((c,d)=>`// Chart ${d+1}: condition=${c.condition}
//   J_forward = [${c.jacobian.map(u=>"["+u.join(", ")+"]").join(`,
//               `)}]
//   J_inverse = [${c.inverseJacobian.map(u=>"["+u.join(", ")+"]").join(`,
//               `)}]`).join(`
`);return`
// Velocity transform: ${this.name} \u2192 Cartesian via Multiple Charts
// Using ${o.length} charts to handle coordinate singularities
${l}
${i} transformVelocityToCartesian(${i} vel_native, ${i} pos) {
    ${i} result;
    float ${e.map((c,d)=>`${c} = pos.${r[d]}`).join(", ")};
${s}
    return result;
}`}generateInverseTransformGLSL(e,t){let i=`vec${this.dimensions}`,r=["x","y","z","w"],o=["x","y","z","w","u","v"].slice(0,this.dimensions);if(this.inverseTransforms&&this.inverseTransforms.length===this.dimensions){let s=this.inverseTransforms.map((l,c)=>`    result.${r[c]} = ${l};`).join(`
`);return`
// Inverse transform: ${this.name} (Native \u2192 Cartesian)
// Using explicit inverse transform (Tier 1)
${i} transformToCartesian(${i} native_pos) {
    ${i} result;
    float ${e.map((l,c)=>`${l} = native_pos.${r[c]}`).join(", ")};
${s}
    return result;
}`}return this.useIterativeSolver?this.generateNewtonSolverGLSL(o,e,t):(console.warn(`No inverse transform defined for ${this.name}, using identity`),`
// Inverse transform: ${this.name} (Native \u2192 Cartesian)
// WARNING: Using identity fallback - no inverse defined!
${i} transformToCartesian(${i} native_pos) {
    return native_pos; // INCORRECT: Identity fallback
}`)}generateNewtonSolverGLSL(e,t,i){let r=`vec${this.dimensions}`,o=`mat${this.dimensions}`,s=["x","y","z","w"],l=this.forwardTransforms.map((u,h)=>{let g=i(u,e);return`        native.${s[h]} = ${g};`}).join(`
`),c=xe(this.forwardTransforms,this.dimensions);if(!c)return console.error("Failed to compute Jacobian for Newton solver:",this.name),`
// Newton solver failed: could not compute Jacobian
${r} transformToCartesian(${r} native_pos) {
    return native_pos; // ERROR FALLBACK
}`;let d=[];for(let u=0;u<this.dimensions;u++)for(let h=0;h<this.dimensions;h++){let g=i(c[u][h],e);d.push(`        J[${u}][${h}] = ${g};`)}return`
// Inverse transform: ${this.name} (Native \u2192 Cartesian)
// Using Newton's method iterative solver (Tier 3)
${r} transformToCartesian(${r} native_target) {
    // Use previous position as initial guess (stored in global)
    ${r} guess = vec${this.dimensions}(0.0); // TODO: Use previous frame position

    const int MAX_ITERATIONS = 10;
    const float TOLERANCE = 1e-6;

    for(int iter = 0; iter < MAX_ITERATIONS; iter++) {
        // Evaluate forward transform at current guess
        ${r} native;
        float ${e.map((u,h)=>`${u} = guess.${s[h]}`).join(", ")};
${l}

        // Compute error
        ${r} error = native - native_target;
        if(length(error) < TOLERANCE) {
            break; // Converged
        }

        // Build Jacobian matrix J = \u2202(native)/\u2202(cartesian)
        ${o} J;
${d.join(`
`)}

        // Newton step: guess -= inverse(J) * error
        guess -= inverse(J) * error;
    }

    return guess;
}`}toJSON(){return{name:this.name,dimensions:this.dimensions,variables:this.variables,forwardTransforms:this.forwardTransforms,inverseTransforms:this.inverseTransforms,useIterativeSolver:this.useIterativeSolver}}static fromJSON(e){return new n(e.name,e.dimensions,e.variables,e.forwardTransforms,e.inverseTransforms||null,e.useIterativeSolver||!1)}},Ae={cartesian2d:new j("Cartesian 2D",2,[{label:"x",displayLabel:"x"},{label:"y",displayLabel:"y"}],["x","y"],["x","y"]),polar2d:new j("Polar 2D",2,[{label:"r",displayLabel:"r"},{label:"theta",displayLabel:"\u03B8"}],["sqrt(x^2 + y^2)","atan2(y, x)"],["r*cos(theta)","r*sin(theta)"]),cartesian3d:new j("Cartesian 3D",3,[{label:"x",displayLabel:"x"},{label:"y",displayLabel:"y"},{label:"z",displayLabel:"z"}],["x","y","z"],["x","y","z"]),cylindrical3d:new j("Cylindrical 3D",3,[{label:"rho",displayLabel:"\u03C1"},{label:"phi",displayLabel:"\u03C6"},{label:"z",displayLabel:"z"}],["sqrt(x^2 + y^2)","atan2(y, x)","z"],["rho*cos(phi)","rho*sin(phi)","z"]),spherical3d:new j("Spherical 3D",3,[{label:"r",displayLabel:"r"},{label:"theta",displayLabel:"\u03B8"},{label:"phi",displayLabel:"\u03C6"}],["sqrt(x^2 + y^2 + z^2)","acos(z / sqrt(x^2 + y^2 + z^2))","atan2(y, x)"],["r*sin(theta)*cos(phi)","r*sin(theta)*sin(phi)","r*cos(theta)"]),cartesian4d:new j("Cartesian 4D",4,[{label:"x",displayLabel:"x"},{label:"y",displayLabel:"y"},{label:"z",displayLabel:"z"},{label:"w",displayLabel:"w"}],["x","y","z","w"],["x","y","z","w"]),hyperspherical4d:new j("Hyperspherical 4D",4,[{label:"r",displayLabel:"r"},{label:"theta",displayLabel:"\u03B8"},{label:"phi",displayLabel:"\u03C6"},{label:"psi",displayLabel:"\u03C8"}],["sqrt(x^2 + y^2 + z^2 + w^2)","acos(w / sqrt(x^2 + y^2 + z^2 + w^2))","acos(z / sqrt(x^2 + y^2 + z^2))","atan2(y, x)"],["r*sin(theta)*sin(phi)*cos(psi)","r*sin(theta)*sin(phi)*sin(psi)","r*sin(theta)*cos(phi)","r*cos(theta)"])}});var lr={};Si(lr,{decodeFloatRGBA:()=>oi,encodeFloatRGBA:()=>ri,getDecodeGLSL:()=>lo,getEncodeGLSL:()=>ao,getFixedPointConstantsGLSL:()=>so});function ri(n,e,t){n=Math.max(0,Math.min(1,n));let i=Math.floor(n*4294967295);e[t+0]=i>>>24&255,e[t+1]=i>>>16&255,e[t+2]=i>>>8&255,e[t+3]=i&255}function oi(n,e,t,i){return((n<<24|e<<16|t<<8|i)>>>0)/4294967295}function so(){return`
// Map to [0, 1] range for maximum precision at any zoom level
const float FIXED_POINT_SCALE = 4294967295.0; // 2^32 - 1
`}function ao(){return`
// Encode float in [0, 1] range to RGBA bytes
vec4 encodeFloat(float v) {
    // Clamp to [0, 1]
    v = clamp(v, 0.0, 1.0);

    // Map to [0, 2^32-1]
    float normalized = v * FIXED_POINT_SCALE;

    // Split into 4 bytes (big-endian)
    float byte0 = floor(normalized / 16777216.0);  // 2^24
    normalized -= byte0 * 16777216.0;
    float byte1 = floor(normalized / 65536.0);      // 2^16
    normalized -= byte1 * 65536.0;
    float byte2 = floor(normalized / 256.0);        // 2^8
    normalized -= byte2 * 256.0;
    float byte3 = floor(normalized);

    return vec4(byte0, byte1, byte2, byte3) / 255.0;
}

// Helper to normalize world coordinate to [0, 1] relative to viewport
float normalizeToViewport(float worldValue, float minVal, float maxVal) {
    return (worldValue - minVal) / (maxVal - minVal);
}

// Helper to denormalize from [0, 1] back to world coordinates
float denormalizeFromViewport(float normalized, float minVal, float maxVal) {
    return minVal + normalized * (maxVal - minVal);
}
`}function lo(){return`
// Decode RGBA bytes back to float in [0, 1] range
float decodeFloat(vec4 rgba) {
    // Reconstruct 32-bit integer from bytes (big-endian)
    vec4 bytes = rgba * 255.0;
    float intValue = bytes.r * 16777216.0 + bytes.g * 65536.0 + bytes.b * 256.0 + bytes.a;

    // Map from [0, 2^32-1] back to [0, 1]
    return intValue / FIXED_POINT_SCALE;
}
`}var ni=ze(()=>{});var Ve=class{constructor(e,t,i,r){this.gl=e,this.dimensions=t,this.resolution=i,this.strategy=r,this.readTextures=[],this.writeTextures=[];for(let o=0;o<t;o++)this.readTextures.push(this.createTexture()),this.writeTextures.push(this.createTexture());this.lineMode=!1,this.prevTextures=[];for(let o=0;o<t;o++)this.prevTextures.push(this.createTexture());this.textureUnitOffset=0}createTexture(){let e=this.gl,t=e.createTexture(),i=this.strategy.getTextureFormat();return e.bindTexture(e.TEXTURE_2D,t),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texImage2D(e.TEXTURE_2D,0,i.internalFormat,this.resolution,this.resolution,0,i.format,i.type,null),t}setLineMode(e){this.lineMode=e}setNeedsPrevTextures(e){}initializeData(e){let t=this.gl,i=this.strategy.getTextureFormat();for(let s=0;s<this.dimensions;s++)t.bindTexture(t.TEXTURE_2D,this.readTextures[s]),t.texImage2D(t.TEXTURE_2D,0,i.internalFormat,this.resolution,this.resolution,0,i.format,i.type,e[s]),t.bindTexture(t.TEXTURE_2D,this.writeTextures[s]),t.texImage2D(t.TEXTURE_2D,0,i.internalFormat,this.resolution,this.resolution,0,i.format,i.type,null),t.bindTexture(t.TEXTURE_2D,this.prevTextures[s]),t.texImage2D(t.TEXTURE_2D,0,i.internalFormat,this.resolution,this.resolution,0,i.format,i.type,e[s]);let r=this.strategy.getArrayType(),o=this.strategy.getComponentsPerValue();if(i.format===t.RGBA){let s=e[0];for(let l=0;l<this.resolution*this.resolution;l++)o===4&&(s[l*4+3]=1);t.bindTexture(t.TEXTURE_2D,this.readTextures[0]),t.texImage2D(t.TEXTURE_2D,0,i.internalFormat,this.resolution,this.resolution,0,i.format,i.type,s),t.bindTexture(t.TEXTURE_2D,this.prevTextures[0]),t.texImage2D(t.TEXTURE_2D,0,i.internalFormat,this.resolution,this.resolution,0,i.format,i.type,s)}}bindReadTextures(e){let t=this.gl;for(let i=0;i<this.dimensions;i++){let r=`u_pos_${i}`,o=t.getUniformLocation(e,r);o!==null&&(t.activeTexture(t.TEXTURE0+this.textureUnitOffset+i),t.bindTexture(t.TEXTURE_2D,this.readTextures[i]),t.uniform1i(o,this.textureUnitOffset+i))}}bindPrevTextures(e){let t=this.gl;for(let i=0;i<this.dimensions;i++){let r=`u_prev_pos_${i}`,o=t.getUniformLocation(e,r);if(o!==null){let s=this.textureUnitOffset+this.dimensions+i;t.activeTexture(t.TEXTURE0+s),t.bindTexture(t.TEXTURE_2D,this.prevTextures[i]),t.uniform1i(o,s)}}}getWriteTexture(e){return this.writeTextures[e]}swap(){let e=this.prevTextures;this.prevTextures=this.readTextures,this.readTextures=this.writeTextures,this.writeTextures=e}resize(e){let t=this.gl;this.resolution=e;for(let i=0;i<this.dimensions;i++)t.deleteTexture(this.readTextures[i]),t.deleteTexture(this.writeTextures[i]),t.deleteTexture(this.prevTextures[i]);this.readTextures=[],this.writeTextures=[],this.prevTextures=[];for(let i=0;i<this.dimensions;i++)this.readTextures.push(this.createTexture()),this.writeTextures.push(this.createTexture()),this.prevTextures.push(this.createTexture())}dispose(){let e=this.gl;for(let t=0;t<this.dimensions;t++)e.deleteTexture(this.readTextures[t]),e.deleteTexture(this.writeTextures[t]),e.deleteTexture(this.prevTextures[t]);this.readTextures=[],this.writeTextures=[],this.prevTextures=[]}getReadTextures(){return this.readTextures}readTexture(e){let t=this.gl,i=this.strategy.getTextureFormat(),r=this.strategy.getArrayType(),o=this.strategy.getComponentsPerValue(),s=new r(this.resolution*this.resolution*o),l=t.createFramebuffer();return t.bindFramebuffer(t.FRAMEBUFFER,l),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,this.readTextures[e],0),t.readPixels(0,0,this.resolution,this.resolution,i.format,i.type,s),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteFramebuffer(l),s}};X();var Ne=class{constructor(e,t,i,r={}){this.gl=e,this.width=t,this.height=i,this.useHDR=r.useHDR!==void 0?r.useHDR:!0,this.usePingPong=r.usePingPong!==void 0?r.usePingPong:!0,this.checkExtensions(),this.initialize(),a.info("FramebufferManager initialized",{width:t,height:i,useHDR:this.useHDR,hdrSupported:this.hdrSupported,textureFormat:this.getTextureFormatName()})}checkExtensions(){let e=this.gl;a.verbose("Checking WebGL extensions for HDR support..."),this.floatTextureExt=e.getExtension("OES_texture_float"),this.halfFloatTextureExt=e.getExtension("OES_texture_half_float"),this.floatColorBufferExt=e.getExtension("WEBGL_color_buffer_float")||e.getExtension("EXT_color_buffer_float"),this.halfFloatColorBufferExt=e.getExtension("EXT_color_buffer_half_float"),this.floatLinearExt=e.getExtension("OES_texture_float_linear"),this.halfFloatLinearExt=e.getExtension("OES_texture_half_float_linear"),this.floatBlendExt=e.getExtension("EXT_float_blend"),a.verbose("WebGL extension support:",{OES_texture_float:!!this.floatTextureExt,OES_texture_half_float:!!this.halfFloatTextureExt,WEBGL_color_buffer_float:!!this.floatColorBufferExt,EXT_color_buffer_half_float:!!this.halfFloatColorBufferExt,OES_texture_float_linear:!!this.floatLinearExt,OES_texture_half_float_linear:!!this.halfFloatLinearExt,EXT_float_blend:!!this.floatBlendExt}),this.hdrSupported=!!(this.floatColorBufferExt||this.halfFloatColorBufferExt),a.verbose(`HDR support determined: ${this.hdrSupported?"SUPPORTED":"NOT SUPPORTED"}`),this.useHDR&&!this.hdrSupported&&(a.warn("HDR rendering requested but not supported by device. Falling back to LDR."),this.useHDR=!1),this.useHDR?(this.floatColorBufferExt?(this.hdrType=e.FLOAT,this.hdrTypeExt=this.floatTextureExt,this.linearExt=this.floatLinearExt,a.info("Selected RGBA32F (full float) for HDR framebuffers")):this.halfFloatColorBufferExt&&(this.hdrType=this.halfFloatTextureExt.HALF_FLOAT_OES,this.hdrTypeExt=this.halfFloatTextureExt,this.linearExt=this.halfFloatLinearExt,a.info("Selected RGBA16F (half float) for HDR framebuffers")),this.linearExt||a.warn("Linear filtering not supported for float textures. Bloom quality may be affected.")):a.verbose("Using LDR (RGBA8) framebuffers")}initialize(){let e=this.gl;if(a.verbose(`Creating ${this.usePingPong?"ping-pong":"single"} framebuffers...`),this.usePingPong){this.framebuffers=[e.createFramebuffer(),e.createFramebuffer()],this.textures=[this.createTexture(),this.createTexture()],this.depthBuffer=e.createRenderbuffer(),e.bindRenderbuffer(e.RENDERBUFFER,this.depthBuffer),e.renderbufferStorage(e.RENDERBUFFER,e.DEPTH_COMPONENT16,this.width,this.height);for(let t=0;t<2;t++)e.bindFramebuffer(e.FRAMEBUFFER,this.framebuffers[t]),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,this.textures[t],0),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.RENDERBUFFER,this.depthBuffer),this.checkFramebufferStatus(t);this.currentIndex=0}else this.framebuffers=[e.createFramebuffer()],this.textures=[this.createTexture()],this.depthBuffer=e.createRenderbuffer(),e.bindRenderbuffer(e.RENDERBUFFER,this.depthBuffer),e.renderbufferStorage(e.RENDERBUFFER,e.DEPTH_COMPONENT16,this.width,this.height),e.bindFramebuffer(e.FRAMEBUFFER,this.framebuffers[0]),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,this.textures[0],0),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.RENDERBUFFER,this.depthBuffer),this.checkFramebufferStatus(0),this.currentIndex=0;e.bindFramebuffer(e.FRAMEBUFFER,null)}createTexture(){let e=this.gl,t=e.createTexture();e.bindTexture(e.TEXTURE_2D,t),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE);let i=this.useHDR&&this.linearExt?e.LINEAR:e.NEAREST,r=this.useHDR&&this.linearExt?e.LINEAR:e.NEAREST;return e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,i),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,r),this.useHDR?e.texImage2D(e.TEXTURE_2D,0,e.RGBA,this.width,this.height,0,e.RGBA,this.hdrType,null):e.texImage2D(e.TEXTURE_2D,0,e.RGBA,this.width,this.height,0,e.RGBA,e.UNSIGNED_BYTE,null),t}checkFramebufferStatus(e){let t=this.gl;if(t.isContextLost())throw new Error("WebGL context lost");let i=t.checkFramebufferStatus(t.FRAMEBUFFER);if(i!==t.FRAMEBUFFER_COMPLETE){let r=this.getFramebufferStatusString(i);throw a.error(`Framebuffer ${e} is not complete: ${r}`,{format:this.getTextureFormatName(),size:`${this.width}x${this.height}`,status:i,contextLost:t.isContextLost()}),new Error(`Framebuffer ${e} incomplete: ${r}`)}a.verbose(`Framebuffer ${e} created successfully: ${this.getTextureFormatName()} at ${this.width}x${this.height}`)}getFramebufferStatusString(e){let t=this.gl;switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"UNSUPPORTED";default:return`UNKNOWN (${e})`}}getTextureFormatName(){return this.useHDR?this.hdrType===this.gl.FLOAT?"RGBA32F (Full HDR)":"RGBA16F (Half HDR)":"RGBA8 (LDR)"}bind(){let e=this.gl;e.bindFramebuffer(e.FRAMEBUFFER,this.framebuffers[this.currentIndex]),e.viewport(0,0,this.width,this.height)}bindCanvas(){let e=this.gl;e.bindFramebuffer(e.FRAMEBUFFER,null)}getCurrentTexture(){return this.textures[this.currentIndex]}getPreviousTexture(){return this.usePingPong?this.textures[1-this.currentIndex]:this.textures[0]}swap(){this.usePingPong&&(this.currentIndex=1-this.currentIndex)}clear(e=0,t=0,i=0,r=1){let o=this.gl;this.bind(),o.clearColor(e,t,i,r),o.clear(o.COLOR_BUFFER_BIT)}clearAll(e=0,t=0,i=0,r=1){let o=this.gl;for(let s=0;s<this.framebuffers.length;s++)o.bindFramebuffer(o.FRAMEBUFFER,this.framebuffers[s]),o.clearColor(e,t,i,r),o.clear(o.COLOR_BUFFER_BIT);o.bindFramebuffer(o.FRAMEBUFFER,null)}resize(e,t){if(e===this.width&&t===this.height)return;a.info("Resizing HDR framebuffers",{from:`${this.width}x${this.height}`,to:`${e}x${t}`,format:this.getTextureFormatName()}),this.width=e,this.height=t;let i=this.gl;for(let r of this.textures)i.deleteTexture(r);this.depthBuffer&&i.deleteRenderbuffer(this.depthBuffer),this.depthBuffer=i.createRenderbuffer(),i.bindRenderbuffer(i.RENDERBUFFER,this.depthBuffer),i.renderbufferStorage(i.RENDERBUFFER,i.DEPTH_COMPONENT16,e,t),this.textures=[];for(let r=0;r<this.framebuffers.length;r++)this.textures.push(this.createTexture()),i.bindFramebuffer(i.FRAMEBUFFER,this.framebuffers[r]),i.framebufferTexture2D(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,this.textures[r],0),i.framebufferRenderbuffer(i.FRAMEBUFFER,i.DEPTH_ATTACHMENT,i.RENDERBUFFER,this.depthBuffer),this.checkFramebufferStatus(r);this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,null),this.clearAll()}dispose(){let e=this.gl;for(let t of this.framebuffers)e.deleteFramebuffer(t);for(let t of this.textures)e.deleteTexture(t);this.framebuffers=[],this.textures=[],a.verbose("FramebufferManager disposed")}isHDR(){return this.useHDR&&this.hdrSupported}getHDRSupport(){return{supported:this.hdrSupported,enabled:this.useHDR,format:this.getTextureFormatName(),hasFloatColorBuffer:!!this.floatColorBufferExt,hasHalfFloatColorBuffer:!!this.halfFloatColorBufferExt,hasLinearFiltering:!!this.linearExt}}};X();var tt=class{constructor(e,t,i,r={}){this.gl=e,this.width=t,this.height=i,this.enabled=r.enabled!==void 0?r.enabled:!0,this.intensity=r.intensity!==void 0?r.intensity:.5,this.threshold=r.threshold!==void 0?r.threshold:1,this.radius=r.radius!==void 0?r.radius:1,this.bloomScale=r.bloomScale!==void 0?r.bloomScale:1,this.bloomWidth=Math.floor(t*this.bloomScale),this.bloomHeight=Math.floor(i*this.bloomScale),this.checkExtensions(),this.initialize(),a.info("BloomManager initialized",{bloomSize:`${this.bloomWidth}x${this.bloomHeight}`,scale:this.bloomScale,threshold:this.threshold,intensity:this.intensity})}checkExtensions(){let e=this.gl;if(this.floatTextureExt=e.getExtension("OES_texture_float"),this.halfFloatTextureExt=e.getExtension("OES_texture_half_float"),this.floatColorBufferExt=e.getExtension("WEBGL_color_buffer_float")||e.getExtension("EXT_color_buffer_float"),this.halfFloatColorBufferExt=e.getExtension("EXT_color_buffer_half_float"),this.floatLinearExt=e.getExtension("OES_texture_float_linear"),this.halfFloatLinearExt=e.getExtension("OES_texture_half_float_linear"),this.floatBlendExt=e.getExtension("EXT_float_blend"),this.hdrSupported=!!(this.floatColorBufferExt||this.halfFloatColorBufferExt),!this.hdrSupported){a.warn("HDR not supported for bloom. Bloom effect will be disabled."),this.enabled=!1;return}this.floatColorBufferExt?(this.hdrType=e.FLOAT,this.linearExt=this.floatLinearExt):this.halfFloatColorBufferExt&&(this.hdrType=this.halfFloatTextureExt.HALF_FLOAT_OES,this.linearExt=this.halfFloatLinearExt),this.linearExt||a.warn("Linear filtering not supported for bloom textures. Bloom quality may be reduced.")}initialize(){if(!this.enabled||!this.hdrSupported)return;let e=this.gl;this.brightFBO=e.createFramebuffer(),this.blurFBO1=e.createFramebuffer(),this.blurFBO2=e.createFramebuffer(),this.brightTexture=this.createTexture(),this.blurTexture1=this.createTexture(),this.blurTexture2=this.createTexture(),e.bindFramebuffer(e.FRAMEBUFFER,this.brightFBO),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,this.brightTexture,0),this.checkFramebufferStatus("Bright extraction"),e.bindFramebuffer(e.FRAMEBUFFER,this.blurFBO1),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,this.blurTexture1,0),this.checkFramebufferStatus("Blur 1"),e.bindFramebuffer(e.FRAMEBUFFER,this.blurFBO2),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,this.blurTexture2,0),this.checkFramebufferStatus("Blur 2"),e.bindFramebuffer(e.FRAMEBUFFER,null),a.verbose("Bloom framebuffers initialized successfully")}createTexture(){let e=this.gl,t=e.createTexture();e.bindTexture(e.TEXTURE_2D,t),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE);let i=this.linearExt?e.LINEAR:e.NEAREST;return e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,i),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,i),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,this.bloomWidth,this.bloomHeight,0,e.RGBA,this.hdrType,null),t}checkFramebufferStatus(e){let t=this.gl,i=t.checkFramebufferStatus(t.FRAMEBUFFER);if(i!==t.FRAMEBUFFER_COMPLETE)throw a.error(`${e} framebuffer is not complete: ${i}`),new Error(`${e} framebuffer incomplete`);a.verbose(`${e} framebuffer created successfully`)}getBrightFBO(){return this.brightFBO}getBrightTexture(){return this.brightTexture}getBlurFBOs(){return[this.blurFBO1,this.blurFBO2]}getBlurTextures(){return[this.blurTexture1,this.blurTexture2]}getBloomSize(){return{width:this.bloomWidth,height:this.bloomHeight}}updateConfig(e){e.enabled!==void 0&&(this.enabled=e.enabled),e.intensity!==void 0&&(this.intensity=e.intensity),e.threshold!==void 0&&(this.threshold=e.threshold),e.radius!==void 0&&(this.radius=e.radius)}resize(e,t){if(!this.enabled||!this.hdrSupported)return;let i=Math.floor(e*this.bloomScale),r=Math.floor(t*this.bloomScale);if(i===this.bloomWidth&&r===this.bloomHeight)return;a.info("Resizing bloom framebuffers",{from:`${this.bloomWidth}x${this.bloomHeight}`,to:`${i}x${r}`}),this.width=e,this.height=t,this.bloomWidth=i,this.bloomHeight=r;let o=this.gl;o.deleteTexture(this.brightTexture),o.deleteTexture(this.blurTexture1),o.deleteTexture(this.blurTexture2),this.brightTexture=this.createTexture(),this.blurTexture1=this.createTexture(),this.blurTexture2=this.createTexture(),o.bindFramebuffer(o.FRAMEBUFFER,this.brightFBO),o.framebufferTexture2D(o.FRAMEBUFFER,o.COLOR_ATTACHMENT0,o.TEXTURE_2D,this.brightTexture,0),this.checkFramebufferStatus("Bright extraction (resized)"),o.bindFramebuffer(o.FRAMEBUFFER,this.blurFBO1),o.framebufferTexture2D(o.FRAMEBUFFER,o.COLOR_ATTACHMENT0,o.TEXTURE_2D,this.blurTexture1,0),this.checkFramebufferStatus("Blur 1 (resized)"),o.bindFramebuffer(o.FRAMEBUFFER,this.blurFBO2),o.framebufferTexture2D(o.FRAMEBUFFER,o.COLOR_ATTACHMENT0,o.TEXTURE_2D,this.blurTexture2,0),this.checkFramebufferStatus("Blur 2 (resized)"),o.bindFramebuffer(o.FRAMEBUFFER,null)}dispose(){if(!this.enabled||!this.hdrSupported)return;let e=this.gl;e.deleteFramebuffer(this.brightFBO),e.deleteFramebuffer(this.blurFBO1),e.deleteFramebuffer(this.blurFBO2),e.deleteTexture(this.brightTexture),e.deleteTexture(this.blurTexture1),e.deleteTexture(this.blurTexture2),a.verbose("BloomManager disposed")}isEnabled(){return this.enabled&&this.hdrSupported}};X();var L={NUMBER:"NUMBER",VARIABLE:"VARIABLE",FUNCTION:"FUNCTION",OPERATOR:"OPERATOR",LPAREN:"LPAREN",RPAREN:"RPAREN",COMMA:"COMMA",EOF:"EOF"},zt={"+":{precedence:1,associativity:"L"},"-":{precedence:1,associativity:"L"},"*":{precedence:2,associativity:"L"},"/":{precedence:2,associativity:"L"},"^":{precedence:3,associativity:"R"},"%":{precedence:2,associativity:"L"}},Fi=new Set(["sin","cos","tan","asin","acos","atan","atan2","sinh","cosh","tanh","exp","log","log2","sqrt","abs","floor","ceil","fract","sign","min","max","pow","mod","length","normalize","dot"]),_e={},Vt={pi:"PI",e:"E",PI:"PI",E:"E"};function it(n){let e=[],t=0,i=null;for(;t<n.length;){let r=n[t];if(/\s/.test(r)){t++;continue}if(/\d/.test(r)||r==="."&&/\d/.test(n[t+1])){let o="";for(;t<n.length&&/[\d.]/.test(n[t]);)o+=n[t++];let s={type:L.NUMBER,value:parseFloat(o)};e.push(s),i=s;continue}if(/[a-zA-Z_]/.test(r)){let o="";for(;t<n.length&&/[a-zA-Z_0-9]/.test(n[t]);)o+=n[t++];let s;Fi.has(o)||_e.hasOwnProperty(o)?s={type:L.FUNCTION,value:o}:Vt.hasOwnProperty(o)?s={type:L.NUMBER,value:Vt[o],isConstant:!0}:s={type:L.VARIABLE,value:o},e.push(s),i=s;continue}if(zt.hasOwnProperty(r)){r==="-"&&(i===null||i.type===L.OPERATOR||i.type===L.LPAREN||i.type===L.COMMA)&&e.push({type:L.NUMBER,value:0});let o={type:L.OPERATOR,value:r};e.push(o),i=o,t++;continue}if(r==="("){let o={type:L.LPAREN};e.push(o),i=o,t++;continue}if(r===")"){let o={type:L.RPAREN};e.push(o),i=o,t++;continue}if(r===","){let o={type:L.COMMA};e.push(o),i=o,t++;continue}throw new Error(`Unexpected character: ${r} at position ${t}`)}return e.push({type:L.EOF}),e}function rt(n){let e=[],t=[],i=0,r=()=>n[i],o=()=>n[i++];for(;r().type!==L.EOF;){let s=o();if(s.type===L.NUMBER)e.push(s);else if(s.type===L.VARIABLE)e.push(s);else if(s.type===L.FUNCTION)t.push(s);else if(s.type===L.COMMA)for(;t.length>0&&t[t.length-1].type!==L.LPAREN;)e.push(t.pop());else if(s.type===L.OPERATOR){let l=s;for(;t.length>0;){let c=t[t.length-1];if(c.type===L.OPERATOR){let d=zt[l.value],u=zt[c.value];if(d.associativity==="L"&&d.precedence<=u.precedence||d.associativity==="R"&&d.precedence<u.precedence)e.push(t.pop());else break}else break}t.push(l)}else if(s.type===L.LPAREN)t.push(s);else if(s.type===L.RPAREN){for(;t.length>0&&t[t.length-1].type!==L.LPAREN;)e.push(t.pop());if(t.length===0)throw new Error("Mismatched parentheses");t.pop(),t.length>0&&t[t.length-1].type===L.FUNCTION&&e.push(t.pop())}}for(;t.length>0;){let s=t.pop();if(s.type===L.LPAREN)throw new Error("Mismatched parentheses");e.push(s)}return e}function Ir(n,e){let t=[],i=new Set(e);["dx","dy","dz","dw","du","dv"].forEach(o=>i.add(o)),i.add("a");for(let o of n)if(o.type===L.NUMBER)if(o.isConstant){let s={PI:"Math.PI",E:"Math.E"};t.push(s[o.value]||o.value.toString())}else t.push(o.value.toString());else if(o.type===L.VARIABLE)if(i.has(o.value))t.push(o.value);else throw new Error(`Unknown variable: ${o.value}. Available: ${e.join(", ")}, dx, dy, dz, dw, du, dv, a (animation alpha)`);else if(o.type===L.OPERATOR){if(t.length<2)throw new Error("Invalid expression");let s=t.pop(),l=t.pop();o.value==="^"?t.push(`Math.pow(${l}, ${s})`):t.push(`(${l} ${o.value} ${s})`)}else if(o.type===L.FUNCTION){let s=Ri(o.value);if(t.length<s)throw new Error(`Not enough arguments for ${o.value}`);let l=[];for(let u=0;u<s;u++)l.unshift(t.pop());let d={mod:"%",fract:"(x => x - Math.floor(x))",mix:"(a, b, t) => a * (1 - t) + b * t"}[o.value]||`Math.${o.value}`;t.push(`${d}(${l.join(", ")})`)}if(t.length!==1)throw new Error("Invalid expression");return t[0]}function Ai(n,e,t=!1,i="pos"){let r=[],o={};if(t)e.forEach(s=>{o[s]=s});else{let s=["x","y","z","w","u","v"],l=["dx","dy","dz","dw","du","dv"];e.forEach((c,d)=>{d<6?o[c]=`${i}.${s[d]}`:o[c]=`${i}[${d}]`}),l.forEach((c,d)=>{d<6?o[c]=`velocity.${s[d]}`:o[c]=`velocity[${d}]`}),o.a="u_alpha"}for(let s of n)if(s.type===L.NUMBER)if(s.isConstant){let l={PI:"3.14159265359",E:"2.71828182846"};r.push(l[s.value]||s.value.toString())}else{let l=s.value.toString();!l.includes(".")&&!l.includes("e")&&!l.includes("E")&&(l+=".0"),r.push(l)}else if(s.type===L.VARIABLE)if(o.hasOwnProperty(s.value))r.push(o[s.value]);else throw new Error(`Unknown variable: ${s.value}. Available: ${e.join(", ")}`);else if(s.type===L.OPERATOR){if(r.length<2)throw new Error("Invalid expression");let l=r.pop(),c=r.pop();if(s.value==="^"){let d=l.match(/^(\d+)\.0$/);if(d){let u=parseInt(d[1]);u===0?r.push("1.0"):u===1?r.push(c):u<=4?r.push(`(${Array(u).fill(c).join(" * ")})`):r.push(`pow(${c}, ${l})`)}else r.push(`pow(${c}, ${l})`)}else s.value==="%"?r.push(`mod(${c}, ${l})`):r.push(`(${c} ${s.value} ${l})`)}else if(s.type===L.FUNCTION){let l=Ri(s.value);if(r.length<l)throw new Error(`Not enough arguments for ${s.value}`);let c=[];for(let u=0;u<l;u++)c.unshift(r.pop());let d=s.value;s.value==="atan2"&&(d="atan"),r.push(`${d}(${c.join(", ")})`)}if(r.length!==1)throw new Error("Invalid expression");return r[0]}function Ri(n){return _e.hasOwnProperty(n)?_e[n].params.length:new Set(["min","max","pow","mod","dot","atan2"]).has(n)?2:1}function Ur(n){let e="";for(let[t,i]of Object.entries(_e)){let r=it(i.body),o=rt(r),s=Ai(o,i.params,!0);e+=`float ${t}(`,e+=i.params.map(l=>`float ${l}`).join(", "),e+=`) {
`,e+=`    return ${s};
`,e+=`}

`}return e}function de(n,e,t=null,i="pos"){let r=t||["x","y","z","w","u","v"].slice(0,e);try{let o=it(n),s=rt(o);return Ai(s,r,!1,i)}catch(o){throw new Error(`Parse error: ${o.message}`)}}function ot(){return Ur([])}function Ci(n,e=null,t="pos"){let i=n.length;return n.map((r,o)=>{try{return de(r.trim(),i,e,t)}catch(s){throw new Error(`Error in dimension ${o}: ${s.message}`)}})}function Nt(n,e=null){let t=n.length,i=e||["x","y","z","w","u","v"].slice(0,t);return n.map((r,o)=>{try{let s=it(r.trim()),l=rt(s),d=`return ${Ir(l,i)};`;return new Function(...i,d)}catch(s){throw new Error(`Error creating evaluator for dimension ${o}: ${s.message}`)}})}function Mi(n){for(let t in _e)delete _e[t];if(!n||!n.trim())return;let e=n.split(`
`);for(let t=0;t<e.length;t++){let i=e[t].trim();if(!i||i.startsWith("//")||i.startsWith("#"))continue;let r=i.match(/^([a-zA-Z_][a-zA-Z_0-9]*)\s*\(([^)]*)\)\s*=\s*(.+)$/);if(!r)throw new Error(`Line ${t+1}: Invalid function definition syntax. Expected: functionName(arg1, arg2) = expression`);let[,o,s,l]=r;if(Fi.has(o))throw new Error(`Line ${t+1}: Cannot override built-in function '${o}'`);if(Vt.hasOwnProperty(o))throw new Error(`Line ${t+1}: Cannot use constant name '${o}' as function name`);let c=s.split(",").map(d=>d.trim()).filter(d=>d);for(let d of c)if(!/^[a-zA-Z_][a-zA-Z_0-9]*$/.test(d))throw new Error(`Line ${t+1}: Invalid parameter name '${d}'`);try{let d=it(l);rt(d)}catch(d){throw new Error(`Line ${t+1}: Error parsing function body: ${d.message}`)}_e[o]={params:c,body:l}}}function Pi(){return{..._e}}function Li(n,e,t){let i=n.createShader(e);if(n.shaderSource(i,t),n.compileShader(i),!n.getShaderParameter(i,n.COMPILE_STATUS)){let r=n.getShaderInfoLog(i);throw n.deleteShader(i),new Error(`Shader compilation error: ${r}

Source:
${Vr(t)}`)}return i}function zr(n,e,t){let i=n.createProgram();if(n.attachShader(i,e),n.attachShader(i,t),n.linkProgram(i),!n.getProgramParameter(i,n.LINK_STATUS)){let r=n.getProgramInfoLog(i);throw n.deleteProgram(i),new Error(`Program linking error: ${r}`)}return i}function J(n,e,t){let i=Li(n,n.VERTEX_SHADER,e),r=Li(n,n.FRAGMENT_SHADER,t),o=zr(n,i,r);return n.deleteShader(i),n.deleteShader(r),o}function Vr(n){return n.split(`
`).map((e,t)=>`${t+1}: ${e}`).join(`
`)}function Di(){return`
precision highp float;

attribute vec2 a_pos;

void main() {
    gl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);
}
`}function Bi(n,e,t,i,r=null,o=null){let s=Array.from({length:n},(b,v)=>`uniform sampler2D u_pos_${v};`).join(`
`),l=`vec${n}`,c=Array.from({length:n},(b,v)=>`decodeFloat(texture2D(u_pos_${v}, v_texcoord))`).join(", "),d=["x","y","z","w"],u=e.map((b,v)=>`    result.${d[v]} = ${b};`).join(`
`),h=o&&o.forwardTransform,g=h?`
// Coordinate system transformation functions (native-space integration)
${o.forwardTransform}
${o.inverseTransform}
// Note: velocityTransform not needed with native-space integration
`:"",f=r&&r.forward,p=f?`
// Domain transformation functions
${r.helpers||""}
${r.forward}
${r.inverse}
${r.jacobian}
`:"",x=h?`
// User-defined velocity field in native coordinates (${o.name||"custom"})
${l} get_velocity_native(${l} pos_native) {
    ${l} result;
    // Extract native coordinates for use in expressions
    float ${o.nativeVars?o.nativeVars.map((b,v)=>`${b} = pos_native.${d[v]}`).join(", "):d.slice(0,n).map((b,v)=>`${b} = pos_native.${b}`).join(", ")};
${u}
    return result;
}

// Velocity function in Cartesian (redirects to native, for use by integrator)
${l} get_velocity(${l} pos_native) {
    return get_velocity_native(pos_native);
}
`:f?`
// Original velocity field in world coordinates
${l} get_velocity_original(${l} pos) {
    ${l} result;
    float x = pos.x;
    ${n>1?"float y = pos.y;":""}
    ${n>2?"float z = pos.z;":""}
    ${n>3?"float w = pos.w;":""}

${u}

    return result;
}

// Transformed velocity field: dy/dt = J_T(x) * f(x)
// where y = T(x)
${l} get_velocity(${l} pos_transformed) {
    // Transform back to world coordinates
    ${l} pos = transform_inverse(pos_transformed);

    // Evaluate original velocity field
    ${l} vel_original = get_velocity_original(pos);

    // Apply Jacobian: component-wise multiplication
    ${l} jacobian = transform_jacobian(pos);
    return vel_original * jacobian;
}
`:`
// User-defined velocity field (no transform)
${l} get_velocity(${l} pos) {
    ${l} result;
    float x = pos.x;
    ${n>1?"float y = pos.y;":""}
    ${n>2?"float z = pos.z;":""}
    ${n>3?"float w = pos.w;":""}

${u}

    return result;
}
`,y=ot();return`
precision highp float;

${i.getGLSLConstants()}
${i.getGLSLDecodeFunction()}
${i.getGLSLEncodeFunction()}
${i.getGLSLNormalizeFunction()}
${i.getGLSLDenormalizeFunction()}

${y}

${s}

uniform vec2 u_min;
uniform vec2 u_max;
uniform float u_h;
uniform float u_rand_seed;
uniform float u_drop_rate;
uniform int u_out_coordinate;
uniform float u_particles_res;
uniform float u_max_velocity;
uniform float u_drop_low_velocity;
uniform float u_velocity_threshold;
uniform float u_alpha;
${f?"uniform vec4 u_transform_params;":""}

${g}

${p}

${x}

${t}

// High-quality hash-based random number generator
// Returns value in [0, 1] with good distribution
float rand(vec2 co) {
    // Hash the input
    vec2 p = co + vec2(u_rand_seed, u_rand_seed * 1.61803398875);
    // Use a better hash function
    p = fract(p * vec2(443.897, 441.423));
    p += dot(p.yx, p.xy + vec2(19.19, 17.17));
    return fract(p.x * p.y);
}

// Secondary independent random function
float rand2(vec2 co) {
    vec2 p = co + vec2(u_rand_seed * 2.71828, u_rand_seed * 3.14159);
    p = fract(p * vec2(269.5, 271.3));
    p += dot(p.yx, p.xy + vec2(23.23, 29.29));
    return fract(p.x * p.y);
}

void main() {
    vec2 texcoord = gl_FragCoord.xy / u_particles_res;

    // Read current age from alpha channel of u_pos_0
    float current_age = texture2D(u_pos_0, texcoord).a;

    // Read current position from textures
    // Positions are stored as normalized [0,1] values, denormalize to world coords
    ${l} pos;
    ${Array.from({length:n},(b,v)=>{let w=["x","y","z","w"][v];return v===0?`pos.${w} = denormalizeFromViewport(decodeFloat(texture2D(u_pos_${v}, texcoord)), u_min.x, u_max.x);`:v===1?`pos.${w} = denormalizeFromViewport(decodeFloat(texture2D(u_pos_${v}, texcoord)), u_min.y, u_max.y);`:`pos.${w} = denormalizeFromViewport(decodeFloat(texture2D(u_pos_${v}, texcoord)), -10.0, 10.0);`}).join(`
    `)}

    // Integrate to get new position
    ${l} new_pos;
    ${h?`
    // NATIVE-SPACE INTEGRATION:
    // 1. Transform position to native coordinates
    // 2. Integrate in native space (using velocity defined in native coords)
    // 3. Transform result back to Cartesian
    ${l} pos_native = transformToNative(pos);
    ${l} new_pos_native = integrate(pos_native, u_h);
    new_pos = transformToCartesian(new_pos_native);
    `:f?`
    // Transform to y-space, integrate, then transform back to x-space
    ${l} pos_transformed = transform_forward(pos);
    ${l} new_pos_transformed = integrate(pos_transformed, u_h);
    new_pos = transform_inverse(new_pos_transformed);
    `:`
    // Direct integration (no transform)
    new_pos = integrate(pos, u_h);
    `}

    // Calculate velocity at new position for low-velocity dropping
    ${l} velocity = ${f?"get_velocity_original(new_pos)":"get_velocity(new_pos)"};
    float speed = length(velocity);

    // Check if particle is outside viewport bounds with small margin
    // Use 20% margin to allow particles to flow slightly off-screen before respawning
    float width = u_max.x - u_min.x;
    float height = u_max.y - u_min.y;
    bool outside = new_pos.x < (u_min.x - width * 0.2) || new_pos.x > (u_max.x + width * 0.2) ||
                   new_pos.y < (u_min.y - height * 0.2) || new_pos.y > (u_max.y + height * 0.2);

    // Check if particle is too slow (if drop_low_velocity is enabled)
    bool too_slow = u_drop_low_velocity > 0.5 && speed < (u_max_velocity * u_velocity_threshold);

    // Random drop: reset particle to random position with small probability
    // Also reset if particle exits the viewport or is too slow
    float drop_chance = rand(texcoord);
    bool should_respawn = drop_chance < u_drop_rate || outside || too_slow;
    if (should_respawn) {
        // Spawn particles 2% OUTSIDE viewport for natural flow-in effect (negative margin)
        // Use texcoord + rand_seed for truly independent random values per particle per frame
        const float margin = -0.02;
        ${n===2?`new_pos.x = u_min.x + width * margin + rand(texcoord * 1.234 + vec2(u_rand_seed)) * width * (1.0 - 2.0 * margin);
        new_pos.y = u_min.y + height * margin + rand2(texcoord * 5.678 + vec2(u_rand_seed * 2.345)) * height * (1.0 - 2.0 * margin);`:Array.from({length:n},(b,v)=>{let w=["x","y","z","w"];return v===0?"new_pos.x = u_min.x + width * margin + rand(texcoord * 1.234 + vec2(u_rand_seed)) * width * (1.0 - 2.0 * margin);":v===1?"new_pos.y = u_min.y + height * margin + rand2(texcoord * 5.678 + vec2(u_rand_seed * 2.345)) * height * (1.0 - 2.0 * margin);":`new_pos.${w[v]} = -10.4 + rand(texcoord * ${v+1}.37 + vec2(u_rand_seed * ${v+3}.5)) * 20.8;`}).join(`
        `)}
    }

    // Calculate new age (based on all spawn conditions)
    float new_age;
    if (should_respawn) {
        new_age = 0.0; // Reset age for newly spawned particles
    } else {
        new_age = min(current_age + 0.5, 1.0); // Increment age, cap at 1.0
    }

    // Output the selected coordinate
    // Normalize world coords back to [0, 1] before encoding
    ${Array.from({length:n},(b,v)=>{let w=["x","y","z","w"][v],S;return v===0?S=`normalizeToViewport(new_pos.${w}, u_min.x, u_max.x)`:v===1?S=`normalizeToViewport(new_pos.${w}, u_min.y, u_max.y)`:S=`normalizeToViewport(new_pos.${w}, -10.0, 10.0)`,v===0?`if (u_out_coordinate == ${v}) {
        gl_FragColor = encodeFloat(${S});
        gl_FragColor.a = new_age; // Store age in alpha channel
    }`:v===n-1?` else {
        gl_FragColor = encodeFloat(${S});
    }`:` else if (u_out_coordinate == ${v}) {
        gl_FragColor = encodeFloat(${S});
    }`}).join("")}
}
`}function Ii(n,e,t,i,r=!1,o=null){let s=o&&o.forwardTransform,l=Array.from({length:n},(x,y)=>`uniform sampler2D u_pos_${y};`).join(`
`),c=Array.from({length:n},(x,y)=>`uniform sampler2D u_prev_pos_${y};`).join(`
`),d=`vec${n}`,u=["x","y","z","w"],h=t.map((x,y)=>`    result.${u[y]} = ${x};`).join(`
`),g=s?`
// Coordinate system transformation functions
${o.forwardTransform}
${o.inverseTransform}
// Note: inverseTransform needed for computing Cartesian velocity via finite differences
`:"",f=s?`
// User-defined velocity field in native coordinates
${d} get_velocity_native(${d} pos_native) {
    ${d} result;
${h}
    return result;
}

// Velocity field for visualization (no Cartesian transform needed with native-space integration)
${d} get_velocity(${d} pos_cartesian) {
    ${d} pos_native = transformToNative(pos_cartesian);
    return get_velocity_native(pos_native);
}
`:`
// User-defined velocity field
${d} get_velocity(${d} pos) {
    ${d} result;
    float x = pos.x;
    ${n>1?"float y = pos.y;":""}
    ${n>2?"float z = pos.z;":""}
    ${n>3?"float w = pos.w;":""}

${h}

    return result;
}
`,p=ot();return`
precision highp float;

${i.getGLSLConstants()}
${i.getGLSLDecodeFunction()}
${i.getGLSLDenormalizeFunction()}

${p}

attribute float a_index;
${r?"attribute float a_vertex_id; // 0 = prev, 1 = current":""}

${l}
${c}

uniform float u_particles_res;
uniform vec2 u_min;
uniform vec2 u_max;
uniform float u_alpha;
uniform float u_particle_size;
uniform vec2 u_viewport_size;  // Actual render resolution (renderWidth, renderHeight)
uniform vec2 u_canvas_size;    // Canvas resolution (canvas.width, canvas.height)

varying vec${n} v_pos;
varying vec${n} v_velocity;          // Full N-dimensional velocity (for expression mode)
varying vec${n} v_velocity_projected; // Projected 2D velocity (for angle-based color modes)

${e}

${g}

${f}

void main() {
    ${r?`
    // Line mode: index buffer has [0,0,1,1,2,2,3,3,...], vertex ID buffer has [0,1,0,1,0,1,...]
    // a_vertex_id = 0 means previous position, 1 means current position
    float particle_index = a_index;
    bool is_current = a_vertex_id > 0.5;
    `:`
    // Point mode: one vertex per particle
    float particle_index = a_index;
    `}

    // Calculate texture coordinate from particle index
    // Add 0.5 to sample from texel centers
    vec2 texcoord = vec2(
        (mod(particle_index, u_particles_res) + 0.5) / u_particles_res,
        (floor(particle_index / u_particles_res) + 0.5) / u_particles_res
    );

    // Read age from alpha channel of u_pos_0
    float age = texture2D(u_pos_0, texcoord).a;

    // Read position from textures and denormalize to world coordinates
    ${d} pos;
    ${r?`
    if (is_current) {
        // Current position
        ${Array.from({length:n},(x,y)=>{let b=["x","y","z","w"][y];return y===0?`pos.${b} = denormalizeFromViewport(decodeFloat(texture2D(u_pos_${y}, texcoord)), u_min.x, u_max.x);`:y===1?`pos.${b} = denormalizeFromViewport(decodeFloat(texture2D(u_pos_${y}, texcoord)), u_min.y, u_max.y);`:`pos.${b} = denormalizeFromViewport(decodeFloat(texture2D(u_pos_${y}, texcoord)), -10.0, 10.0);`}).join(`
        `)}
    } else {
        // Previous position
        ${Array.from({length:n},(x,y)=>{let b=["x","y","z","w"][y];return y===0?`pos.${b} = denormalizeFromViewport(decodeFloat(texture2D(u_prev_pos_${y}, texcoord)), u_min.x, u_max.x);`:y===1?`pos.${b} = denormalizeFromViewport(decodeFloat(texture2D(u_prev_pos_${y}, texcoord)), u_min.y, u_max.y);`:`pos.${b} = denormalizeFromViewport(decodeFloat(texture2D(u_prev_pos_${y}, texcoord)), -10.0, 10.0);`}).join(`
        `)}
    }
    `:`
    ${Array.from({length:n},(x,y)=>{let b=["x","y","z","w"][y];return y===0?`pos.${b} = denormalizeFromViewport(decodeFloat(texture2D(u_pos_${y}, texcoord)), u_min.x, u_max.x);`:y===1?`pos.${b} = denormalizeFromViewport(decodeFloat(texture2D(u_pos_${y}, texcoord)), u_min.y, u_max.y);`:`pos.${b} = denormalizeFromViewport(decodeFloat(texture2D(u_pos_${y}, texcoord)), -10.0, 10.0);`}).join(`
    `)}
    `}

    // Calculate velocity for coloring
    ${d} velocity;
    ${s?`
    // For coordinate systems: compute Cartesian velocity from position difference
    // Read previous position (already in Cartesian space from update shader)
    ${d} prev_pos;
    ${Array.from({length:n},(x,y)=>{let b=["x","y","z","w"][y];return y===0?`prev_pos.${b} = denormalizeFromViewport(decodeFloat(texture2D(u_prev_pos_${y}, texcoord)), u_min.x, u_max.x);`:y===1?`prev_pos.${b} = denormalizeFromViewport(decodeFloat(texture2D(u_prev_pos_${y}, texcoord)), u_min.y, u_max.y);`:`prev_pos.${b} = denormalizeFromViewport(decodeFloat(texture2D(u_prev_pos_${y}, texcoord)), -10.0, 10.0);`}).join(`
    `)}

    // Cartesian velocity from finite difference
    velocity = pos - prev_pos;
    `:`
    // For Cartesian systems: compute velocity directly
    velocity = get_velocity(pos);
    `}

    // Pass N-dimensional position and full velocity to fragment shader
    v_pos = pos;
    v_velocity = velocity; // Full N-dimensional velocity for expression mode

    // Skip newly spawned particles (age < 1) by moving them off-screen
    if (age < 1.0) {
        gl_Position = vec4(10.0, 10.0, 10.0, 1.0); // Far outside clip space
        gl_PointSize = 0.0;
        v_velocity_projected = velocity; // Won't be used since particle is off-screen
    } else {
        // Project position to 3D (with depth)
        vec3 pos_3d = project_to_3d(pos);

        // Project velocity to 2D (using same mapper)
        // For linear projections, this is correct for tangent vectors
        vec2 velocity_2d = project_to_2d(velocity);

        // Create 2D velocity vector (pad to match dimensions for varying)
        ${d} velocity_projected;
        velocity_projected.x = velocity_2d.x;
        velocity_projected.y = velocity_2d.y;
        ${n>2?"velocity_projected.z = 0.0;":""}
        ${n>3?"velocity_projected.w = 0.0;":""}

        // Pass projected 2D velocity to fragment shader (for angle-based color modes)
        v_velocity_projected = velocity_projected;

        // Map to screen space
        vec2 normalized = (pos_3d.xy - u_min) / (u_max - u_min);

        // Use depth value (normalized to [-1, 1] range)
        // For now, assume depth is in similar range to x/y coordinates
        float depth_normalized = (pos_3d.z - (u_min.x + u_min.y) * 0.5) / ((u_max.x - u_min.x + u_max.y - u_min.y) * 0.5);
        depth_normalized = clamp(depth_normalized, -1.0, 1.0);

        gl_Position = vec4(normalized * 2.0 - 1.0, depth_normalized, 1.0);

        // Scale particle size by render scale to maintain consistent visual size
        // Calculate render scale as viewport size / canvas size
        float render_scale = u_viewport_size.x / u_canvas_size.x;
        gl_PointSize = u_particle_size * render_scale;
    }
}
`}function Ui(n,e,t){return`
precision highp float;

${ot()}

varying vec${n} v_pos;
varying vec${n} v_velocity;          // Full N-dimensional velocity (for expression mode)
varying vec${n} v_velocity_projected; // Projected 2D velocity (for angle-based color modes)

${t?`uniform float u_max_velocity;
uniform float u_velocity_log_scale;`:""}
uniform float u_particle_intensity;
uniform float u_color_saturation;
uniform float u_alpha;
uniform vec2 u_viewport_size;  // Actual render resolution
uniform vec2 u_canvas_size;    // Canvas resolution

${e}

void main() {
    // Get color based on position and velocity
    vec3 color = getColor(v_pos, v_velocity, v_velocity_projected);

    // Apply saturation adjustment (for attractor visualization)
    // 0.0 = grayscale, 1.0 = full saturation
    if (u_color_saturation < 1.0) {
        float luminance = dot(color, vec3(0.2126, 0.7152, 0.0722));
        vec3 grayscale = vec3(luminance);
        color = mix(grayscale, color, u_color_saturation);
    }

    // Scale by intensity for HDR (allows colors > 1.0)
    color *= u_particle_intensity;

    // Calculate render scale factor
    float render_scale = u_viewport_size.x / u_canvas_size.x;

    // Compensate alpha for particle size scaling to maintain constant brightness
    // Particle area scales with render_scale\xB2, so divide alpha by render_scale\xB2
    // This ensures that larger particles contribute the same total brightness
    float area_compensation = 1.0 / (render_scale * render_scale);
    float adjusted_alpha = 0.35 * area_compensation;

    // Alpha blending allows proper fade to black
    gl_FragColor = vec4(color, adjusted_alpha);
}
`}function zi(){return`
precision highp float;

attribute vec2 a_pos;
varying vec2 v_texcoord;

void main() {
    v_texcoord = a_pos;
    gl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);
}
`}function Vi(){return`
precision highp float;

uniform sampler2D u_screen;
uniform float u_fade;

varying vec2 v_texcoord;

void main() {
    vec4 color = texture2D(u_screen, v_texcoord);
    vec3 faded = color.rgb * u_fade;

    // Snap to black if very dark (prevents floating point precision issues)
    // This ensures trails fade completely to black
    float brightness = max(max(faded.r, faded.g), faded.b);
    if (brightness < 0.003) {
        faded = vec3(0.0);
    }

    gl_FragColor = vec4(faded, 1.0);
}
`}function Ni(n=""){return n||(n=`
vec3 tonemap(vec3 color) {
    return color * u_exposure;
}

vec3 applyGamma(vec3 color) {
    return pow(color, vec3(1.0 / u_gamma));
}
`),`
precision highp float;

uniform sampler2D u_screen;
uniform sampler2D u_bloom;
uniform float u_bloom_intensity;
uniform float u_bloom_alpha;
uniform bool u_bloom_enabled;
uniform float u_exposure;
uniform float u_gamma;
uniform float u_whitePoint;
uniform float u_brightness_desat;
uniform float u_brightness_sat;
uniform float u_hdr_max_brightness;
uniform float u_hdr_avg_brightness;
uniform float u_highlight_compression;
uniform float u_compression_threshold;

varying vec2 v_texcoord;

// Logarithmic highlight compression (pre-tone mapping)
// Only compresses values above threshold to help tone mapper cover full dynamic range
// Preserves hue by compressing luminance only, then scaling RGB to match
vec3 compressHighlights(vec3 color, float strength, float threshold) {
    if (strength < 0.0001) return color; // Disabled

    // Calculate luminance (Rec. 709)
    float luma = dot(color, vec3(0.2126, 0.7152, 0.0722));

    // Avoid division by zero
    if (luma < 0.0001) return color;

    // Compress luminance only
    float compressedLuma;
    if (luma <= threshold) {
        compressedLuma = luma; // Below threshold: unchanged
    } else {
        // Above threshold: compress the excess
        float excess = luma - threshold;
        float compressed = log(1.0 + excess * strength) / strength;
        compressedLuma = threshold + compressed;
    }

    // Scale RGB to match compressed luminance (preserves hue and saturation)
    return color * (compressedLuma / luma);
}

${n}

void main() {
    // Read HDR color from framebuffer
    vec3 hdrColor = texture2D(u_screen, v_texcoord).rgb;

    // Blend bloom if enabled (before tone mapping)
    if (u_bloom_enabled) {
        vec3 bloomColor = texture2D(u_bloom, v_texcoord).rgb * u_bloom_intensity;
        // Alpha blend: mix base color with bloom using alpha
        hdrColor = mix(hdrColor, hdrColor + bloomColor, u_bloom_alpha);
    }

    // Calculate HDR brightness once for both effects (Rec. 709 luminance)
    float hdrBrightness = dot(hdrColor, vec3(0.2126, 0.7152, 0.0722));
    vec3 hdrGray = vec3(hdrBrightness);

    // Get adaptive thresholds based on actual HDR buffer statistics
    float avgBrightness = max(u_hdr_avg_brightness, 0.1); // Avoid division by zero
    float maxBrightness = max(u_hdr_max_brightness, 1.0);

    // Work in log space to handle the massive dynamic range (0.1 to 100,000+)
    float logAvg = log2(avgBrightness + 1.0);
    float logMax = log2(maxBrightness + 1.0);
    float logBrightness = log2(hdrBrightness + 1.0);

    // Apply brightness-based DESATURATION (desaturates BRIGHT regions)
    // Prevents oversaturation and RGB clipping in dense accumulations
    if (u_brightness_desat > 0.0) {
        // Target brighter-than-average regions (where particles accumulate)
        // Start desaturating at 2x average, full desat at 100x average
        // This hits the actual bright accumulations, not just the max peaks
        float brightStart = avgBrightness * 2.0;
        float brightEnd = avgBrightness * 100.0;
        float logBrightStart = log2(brightStart + 1.0);
        float logBrightEnd = log2(brightEnd + 1.0);
        float desatFactor = smoothstep(logBrightStart, logBrightEnd, logBrightness) * u_brightness_desat;

        // Blend toward grayscale
        hdrColor = mix(hdrColor, hdrGray, desatFactor);
    }

    // Apply brightness-based SATURATION BUILDUP (desaturates DIM regions)
    // Creates effect where sparse particles are washed out, dense accumulations pop with color
    if (u_brightness_sat > 0.0) {
        // Slider controls the threshold: higher values = more aggressive desaturation
        // - At 0.3: pixels below ~1000x average are desaturated
        // - At 0.5: pixels below ~4000x average are desaturated
        // - At 1.0: pixels below ~137,000 (max) are desaturated (very aggressive)
        float threshold = avgBrightness * pow(10.0, u_brightness_sat * 3.0); // 1x to 1000x average
        float logThreshold = log2(threshold + 1.0);

        // Narrow transition for sharp cutoff
        float logTransitionStart = log2(avgBrightness * 0.1 + 1.0); // 10% of average
        float satFactor = smoothstep(logTransitionStart, logThreshold, logBrightness);

        // Apply the effect: low brightness gets desaturated AND dimmed
        float desatAmount = (1.0 - satFactor) * u_brightness_sat;
        hdrColor = mix(hdrColor, hdrGray, desatAmount);

        // Also reduce brightness in desaturated regions
        // This makes sparse trails even more subtle (both dim and colorless)
        hdrColor *= (1.0 - desatAmount * 0.5); // Reduce brightness by up to 50%
    }

    // Apply gamma correction in HDR space (before tone mapping)
    // This prevents clipping and gives the tone mapper more headroom
    vec3 gammaCorrected = applyGamma(hdrColor);

    // Apply luminance gamma in HDR space (hue-preserving brightness adjustment)
    vec3 hdrGammaCorrected = applyLuminanceGamma(gammaCorrected);

    // Apply highlight compression to compress bright values before tone mapping
    // This helps the tone mapper cover the full dynamic range more effectively
    vec3 compressed = compressHighlights(hdrGammaCorrected, u_highlight_compression, u_compression_threshold);

    // Apply tone mapping operator to compress HDR values into LDR range
    vec3 ldrColor = tonemap(compressed);

    gl_FragColor = vec4(ldrColor, 1.0);
}
`}function ki(){return`
precision highp float;

uniform sampler2D u_screen;
uniform float u_threshold;

varying vec2 v_texcoord;

void main() {
    vec3 color = texture2D(u_screen, v_texcoord).rgb;

    // Calculate luminance
    float brightness = dot(color, vec3(0.2126, 0.7152, 0.0722));

    // Extract bright regions above threshold
    // Use smooth step for soft transition
    float contribution = smoothstep(u_threshold * 0.8, u_threshold * 1.2, brightness);

    // Output bright pixels only
    gl_FragColor = vec4(color * contribution, 1.0);
}
`}function kt(n=!0,e=1){return`
precision highp float;

uniform sampler2D u_texture;
uniform vec2 u_texel_size;
uniform float u_radius;

varying vec2 v_texcoord;

void main() {
    vec2 direction = ${n?"vec2(1.0, 0.0)":"vec2(0.0, 1.0)"};
    vec3 result = vec3(0.0);

    // Bilinear-optimized 13-tap Gaussian blur
    // Uses hardware linear filtering to sample between pixels for smoother results
    // This reduces the blocky appearance by effectively sampling at sub-pixel positions

    vec2 off1 = vec2(1.3846153846) * direction * u_texel_size * u_radius;
    vec2 off2 = vec2(3.2307692308) * direction * u_texel_size * u_radius;
    vec2 off3 = vec2(5.0769230769) * direction * u_texel_size * u_radius;

    result += texture2D(u_texture, v_texcoord).rgb * 0.2270270270;
    result += texture2D(u_texture, v_texcoord + off1).rgb * 0.3162162162;
    result += texture2D(u_texture, v_texcoord - off1).rgb * 0.3162162162;
    result += texture2D(u_texture, v_texcoord + off2).rgb * 0.0702702703;
    result += texture2D(u_texture, v_texcoord - off2).rgb * 0.0702702703;
    result += texture2D(u_texture, v_texcoord + off3).rgb * 0.0162162162;
    result += texture2D(u_texture, v_texcoord - off3).rgb * 0.0162162162;

    gl_FragColor = vec4(result, 1.0);
}
`}function Oi(){return`
precision highp float;

uniform sampler2D u_base;
uniform sampler2D u_bloom;
uniform float u_bloom_intensity;

varying vec2 v_texcoord;

void main() {
    vec3 baseColor = texture2D(u_base, v_texcoord).rgb;
    vec3 bloomColor = texture2D(u_bloom, v_texcoord).rgb;

    // Add bloom to base with intensity control
    vec3 result = baseColor + bloomColor * u_bloom_intensity;

    gl_FragColor = vec4(result, 1.0);
}
`}function Nr(){return`
precision highp float;

uniform sampler2D u_screen;
uniform vec2 u_resolution;
uniform float u_spatialSigma;   // Spatial blur radius
uniform float u_intensitySigma; // Edge preservation threshold

varying vec2 v_uv;

// Gaussian function
float gaussian(float x, float sigma) {
    return exp(-(x * x) / (2.0 * sigma * sigma));
}

// Luminance for edge detection
float luminance(vec3 color) {
    return dot(color, vec3(0.299, 0.587, 0.114));
}

void main() {
    vec2 texelSize = 1.0 / u_resolution;

    vec3 centerColor = texture2D(u_screen, v_uv).rgb;
    float centerLum = luminance(centerColor);

    // Single-pass noise detection using simple statistics
    const float brightnessThreshold = 0.05;

    // Sample 3x3 neighborhood (unrolled - no arrays)
    float s0 = luminance(texture2D(u_screen, v_uv + vec2(-1.0, -1.0) * texelSize).rgb);
    float s1 = luminance(texture2D(u_screen, v_uv + vec2( 0.0, -1.0) * texelSize).rgb);
    float s2 = luminance(texture2D(u_screen, v_uv + vec2( 1.0, -1.0) * texelSize).rgb);
    float s3 = luminance(texture2D(u_screen, v_uv + vec2(-1.0,  0.0) * texelSize).rgb);
    float s4 = luminance(texture2D(u_screen, v_uv + vec2( 0.0,  0.0) * texelSize).rgb);
    float s5 = luminance(texture2D(u_screen, v_uv + vec2( 1.0,  0.0) * texelSize).rgb);
    float s6 = luminance(texture2D(u_screen, v_uv + vec2(-1.0,  1.0) * texelSize).rgb);
    float s7 = luminance(texture2D(u_screen, v_uv + vec2( 0.0,  1.0) * texelSize).rgb);
    float s8 = luminance(texture2D(u_screen, v_uv + vec2( 1.0,  1.0) * texelSize).rgb);

    // Compute statistics
    float sum = s0 + s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8;
    float sumSquares = s0*s0 + s1*s1 + s2*s2 + s3*s3 + s4*s4 + s5*s5 + s6*s6 + s7*s7 + s8*s8;

    float brightCount = 0.0;
    if (s0 > brightnessThreshold) brightCount += 1.0;
    if (s1 > brightnessThreshold) brightCount += 1.0;
    if (s2 > brightnessThreshold) brightCount += 1.0;
    if (s3 > brightnessThreshold) brightCount += 1.0;
    if (s4 > brightnessThreshold) brightCount += 1.0;
    if (s5 > brightnessThreshold) brightCount += 1.0;
    if (s6 > brightnessThreshold) brightCount += 1.0;
    if (s7 > brightnessThreshold) brightCount += 1.0;
    if (s8 > brightnessThreshold) brightCount += 1.0;

    float mean = sum / 9.0;
    float variance = (sumSquares / 9.0) - (mean * mean);

    // Simple edge detection: check gradient magnitude
    float gradX = abs(s5 - s3); // right - left
    float gradY = abs(s7 - s1); // bottom - top
    float gradient = gradX + gradY;

    // Noise detection: sparse scattered particles
    // If there's ANY variance in a dark region with low gradient, it's probably noise

    bool isDarkAndSparse = (mean < 0.2) && (brightCount < 5.0);
    bool hasNoEdges = (gradient < 0.15);

    // Apply blur to dark sparse regions with no strong edges
    bool shouldBlur = isDarkAndSparse && hasNoEdges;

    if (!shouldBlur) {
        // Structured region - pass through unchanged
        gl_FragColor = vec4(centerColor, 1.0);
        return;
    }

    // Sparse region - apply aggressive gaussian blur
    vec3 colorSum = vec3(0.0);
    float weightSum = 0.0;

    // Larger kernel radius for stronger smoothing
    const int radius = 5; // 11x11 kernel

    for (int x = -radius; x <= radius; x++) {
        for (int y = -radius; y <= radius; y++) {
            vec2 offset = vec2(float(x), float(y)) * texelSize;
            vec3 sampleColor = texture2D(u_screen, v_uv + offset).rgb;

            // Only spatial weight (pure gaussian blur in sparse regions)
            float spatialDist = length(vec2(float(x), float(y)));
            float weight = gaussian(spatialDist, u_spatialSigma);

            colorSum += sampleColor * weight;
            weightSum += weight;
        }
    }

    // Normalize
    vec3 result = colorSum / weightSum;

    gl_FragColor = vec4(result, 1.0);
}
`}var nt=class{constructor(e,t,i,r={}){this.gl=e,this.width=t,this.height=i,this.enabled=r.enabled!==void 0?r.enabled:!1,this.spatialSigma=r.spatialSigma!==void 0?r.spatialSigma:4,this.intensitySigma=r.intensitySigma!==void 0?r.intensitySigma:.2,this.framebuffer=null,this.texture=null,this.program=null,this.quadBuffer=null,this.initialize(),a.info("BilateralFilterManager initialized",{size:`${t}x${i}`,enabled:this.enabled,spatialSigma:this.spatialSigma,intensitySigma:this.intensitySigma})}initialize(){let e=this.gl;if(this.createFramebuffer(),this.compileShader(),!this.quadBuffer){let t=new Float32Array([0,0,1,0,0,1,0,1,1,0,1,1]);this.quadBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.quadBuffer),e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)}}createFramebuffer(){let e=this.gl;this.texture=e.createTexture(),e.bindTexture(e.TEXTURE_2D,this.texture),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,this.width,this.height,0,e.RGBA,e.UNSIGNED_BYTE,null),this.framebuffer=e.createFramebuffer(),e.bindFramebuffer(e.FRAMEBUFFER,this.framebuffer),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,this.texture,0);let t=e.checkFramebufferStatus(e.FRAMEBUFFER);t!==e.FRAMEBUFFER_COMPLETE&&a.error("Bilateral filter framebuffer incomplete",{status:t}),e.bindFramebuffer(e.FRAMEBUFFER,null)}compileShader(){let e=this.gl,t=`
attribute vec2 a_pos;
varying vec2 v_uv;

void main() {
    v_uv = a_pos;
    gl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);
}
`,i=Nr();this.program=J(e,t,i),this.program||a.error("Failed to compile bilateral filter shader")}apply(e){if(!this.enabled)return e;let t=this.gl;t.bindFramebuffer(t.FRAMEBUFFER,this.framebuffer),t.viewport(0,0,this.width,this.height),t.useProgram(this.program),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,e),t.uniform1i(t.getUniformLocation(this.program,"u_screen"),0),t.uniform2f(t.getUniformLocation(this.program,"u_resolution"),this.width,this.height),t.uniform1f(t.getUniformLocation(this.program,"u_spatialSigma"),this.spatialSigma),t.uniform1f(t.getUniformLocation(this.program,"u_intensitySigma"),this.intensitySigma);let i=t.getAttribLocation(this.program,"a_pos");return t.bindBuffer(t.ARRAY_BUFFER,this.quadBuffer),t.enableVertexAttribArray(i),t.vertexAttribPointer(i,2,t.FLOAT,!1,0,0),t.drawArrays(t.TRIANGLES,0,6),t.bindFramebuffer(t.FRAMEBUFFER,null),this.texture}updateConfig(e){e.enabled!==void 0&&(this.enabled=e.enabled),e.spatialSigma!==void 0&&(this.spatialSigma=e.spatialSigma),e.intensitySigma!==void 0&&(this.intensitySigma=e.intensitySigma)}isEnabled(){return this.enabled}resize(e,t){this.width=e,this.height=t,this.cleanup(),this.createFramebuffer()}cleanup(){let e=this.gl;this.framebuffer&&(e.deleteFramebuffer(this.framebuffer),this.framebuffer=null),this.texture&&(e.deleteTexture(this.texture),this.texture=null)}setQuadBuffer(e){this.quadBuffer=e}};X();function kr(){return`
precision highp float;

uniform sampler2D u_screen;
uniform vec2 u_resolution;
uniform float u_threshold;

varying vec2 v_uv;

float luminance(vec3 color) {
    return dot(color, vec3(0.299, 0.587, 0.114));
}

void main() {
    vec2 inverseScreenSize = 1.0 / u_resolution;

    // Sample center
    vec3 center = texture2D(u_screen, v_uv).rgb;
    float lumC = luminance(center);

    // Sample neighbors
    float lumL = luminance(texture2D(u_screen, v_uv + vec2(-1.0, 0.0) * inverseScreenSize).rgb);
    float lumR = luminance(texture2D(u_screen, v_uv + vec2(1.0, 0.0) * inverseScreenSize).rgb);
    float lumT = luminance(texture2D(u_screen, v_uv + vec2(0.0, -1.0) * inverseScreenSize).rgb);
    float lumB = luminance(texture2D(u_screen, v_uv + vec2(0.0, 1.0) * inverseScreenSize).rgb);

    // Compute delta (edge strength)
    float deltaL = abs(lumC - lumL);
    float deltaR = abs(lumC - lumR);
    float deltaT = abs(lumC - lumT);
    float deltaB = abs(lumC - lumB);

    // Horizontal and vertical edges
    vec2 edges = vec2(0.0);

    // Horizontal edge (top-bottom difference)
    float maxDeltaH = max(deltaT, deltaB);
    if (maxDeltaH > u_threshold) {
        edges.x = maxDeltaH;
    }

    // Vertical edge (left-right difference)
    float maxDeltaV = max(deltaL, deltaR);
    if (maxDeltaV > u_threshold) {
        edges.y = maxDeltaV;
    }

    gl_FragColor = vec4(edges, 0.0, 1.0);
}
`}function Or(){return`
precision highp float;

uniform sampler2D u_edgesTex;
uniform vec2 u_resolution;

varying vec2 v_uv;

void main() {
    vec2 inverseScreenSize = 1.0 / u_resolution;

    vec2 edges = texture2D(u_edgesTex, v_uv).xy;
    vec4 weights = vec4(0.0);

    // If no edges detected, skip
    if (dot(edges, vec2(1.0)) < 0.001) {
        gl_FragColor = weights;
        return;
    }

    // Simplified weight calculation
    // For horizontal edge, blend vertically
    if (edges.x > 0.0) {
        // Check how far edge extends
        float edgeT = texture2D(u_edgesTex, v_uv + vec2(0.0, -1.0) * inverseScreenSize).x;
        float edgeB = texture2D(u_edgesTex, v_uv + vec2(0.0, 1.0) * inverseScreenSize).x;

        // Weight based on edge continuity
        weights.x = edges.x * 0.5; // Top blend
        weights.y = edges.x * 0.5; // Bottom blend

        // Reduce weight if edge continues (sharp feature, not aliasing)
        if (edgeT > 0.0 && edgeB > 0.0) {
            weights.x *= 0.25;
            weights.y *= 0.25;
        }
    }

    // For vertical edge, blend horizontally
    if (edges.y > 0.0) {
        float edgeL = texture2D(u_edgesTex, v_uv + vec2(-1.0, 0.0) * inverseScreenSize).y;
        float edgeR = texture2D(u_edgesTex, v_uv + vec2(1.0, 0.0) * inverseScreenSize).y;

        weights.z = edges.y * 0.5; // Left blend
        weights.w = edges.y * 0.5; // Right blend

        // Reduce weight if edge continues
        if (edgeL > 0.0 && edgeR > 0.0) {
            weights.z *= 0.25;
            weights.w *= 0.25;
        }
    }

    gl_FragColor = weights;
}
`}function Gr(){return`
precision highp float;

uniform sampler2D u_colorTex;
uniform sampler2D u_blendTex;
uniform vec2 u_resolution;
uniform float u_intensity;

varying vec2 v_uv;

void main() {
    vec2 inverseScreenSize = 1.0 / u_resolution;

    // Get blend weights
    vec4 weights = texture2D(u_blendTex, v_uv) * u_intensity;

    // If no blending needed, return original color
    if (dot(weights, vec4(1.0)) < 0.001) {
        gl_FragColor = texture2D(u_colorTex, v_uv);
        return;
    }

    // Sample neighbors
    vec3 colorC = texture2D(u_colorTex, v_uv).rgb;
    vec3 colorT = texture2D(u_colorTex, v_uv + vec2(0.0, -1.0) * inverseScreenSize).rgb;
    vec3 colorB = texture2D(u_colorTex, v_uv + vec2(0.0, 1.0) * inverseScreenSize).rgb;
    vec3 colorL = texture2D(u_colorTex, v_uv + vec2(-1.0, 0.0) * inverseScreenSize).rgb;
    vec3 colorR = texture2D(u_colorTex, v_uv + vec2(1.0, 0.0) * inverseScreenSize).rgb;

    // Blend based on weights
    vec3 result = colorC;
    result += colorT * weights.x;
    result += colorB * weights.y;
    result += colorL * weights.z;
    result += colorR * weights.w;

    // Normalize
    float totalWeight = 1.0 + weights.x + weights.y + weights.z + weights.w;
    result /= totalWeight;

    gl_FragColor = vec4(result, 1.0);
}
`}var st=class{constructor(e,t,i,r={}){this.gl=e,this.width=t,this.height=i,this.enabled=r.enabled!==void 0?r.enabled:!0,this.intensity=r.intensity!==void 0?r.intensity:.75,this.threshold=r.threshold!==void 0?r.threshold:.1,this.edgesFramebuffer=null,this.edgesTexture=null,this.blendFramebuffer=null,this.blendTexture=null,this.edgeDetectionProgram=null,this.blendingWeightProgram=null,this.neighborhoodBlendProgram=null,this.quadBuffer=null,this.initialize(),a.info("SMAAManager initialized",{size:`${t}x${i}`,enabled:this.enabled,intensity:this.intensity,threshold:this.threshold})}initialize(){let e=this.gl;if(this.createFramebuffers(),this.compileShaders(),!this.quadBuffer){let t=new Float32Array([0,0,1,0,0,1,0,1,1,0,1,1]);this.quadBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.quadBuffer),e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)}}createFramebuffers(){let e=this.gl;this.edgesTexture=this.createTexture(),this.edgesFramebuffer=this.createFramebuffer(this.edgesTexture),this.blendTexture=this.createTexture(),this.blendFramebuffer=this.createFramebuffer(this.blendTexture)}createTexture(){let e=this.gl,t=e.createTexture();return e.bindTexture(e.TEXTURE_2D,t),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,this.width,this.height,0,e.RGBA,e.UNSIGNED_BYTE,null),t}createFramebuffer(e){let t=this.gl,i=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,i),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0);let r=t.checkFramebufferStatus(t.FRAMEBUFFER);return r!==t.FRAMEBUFFER_COMPLETE&&a.error("SMAA framebuffer incomplete",{status:r}),t.bindFramebuffer(t.FRAMEBUFFER,null),i}compileShaders(){let e=this.gl,t=`
attribute vec2 a_pos;
varying vec2 v_uv;

void main() {
    v_uv = a_pos;
    gl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);
}
`;this.edgeDetectionProgram=J(e,t,kr()),this.blendingWeightProgram=J(e,t,Or()),this.neighborhoodBlendProgram=J(e,t,Gr()),(!this.edgeDetectionProgram||!this.blendingWeightProgram||!this.neighborhoodBlendProgram)&&a.error("Failed to compile SMAA shaders")}applyToFramebuffer(e,t,i){if(!this.enabled||this.intensity<=0){let o=this.gl;o.bindFramebuffer(o.FRAMEBUFFER,t),o.viewport(0,0,this.width,this.height),this.copyToFramebuffer(e,i);return}let r=this.gl;r.bindFramebuffer(r.FRAMEBUFFER,this.edgesFramebuffer),r.viewport(0,0,this.width,this.height),r.useProgram(this.edgeDetectionProgram),r.activeTexture(r.TEXTURE0),r.bindTexture(r.TEXTURE_2D,e),r.uniform1i(r.getUniformLocation(this.edgeDetectionProgram,"u_screen"),0),r.uniform2f(r.getUniformLocation(this.edgeDetectionProgram,"u_resolution"),this.width,this.height),r.uniform1f(r.getUniformLocation(this.edgeDetectionProgram,"u_threshold"),this.threshold),this.drawQuad(this.edgeDetectionProgram,i),r.bindFramebuffer(r.FRAMEBUFFER,this.blendFramebuffer),r.viewport(0,0,this.width,this.height),r.useProgram(this.blendingWeightProgram),r.activeTexture(r.TEXTURE0),r.bindTexture(r.TEXTURE_2D,this.edgesTexture),r.uniform1i(r.getUniformLocation(this.blendingWeightProgram,"u_edgesTex"),0),r.uniform2f(r.getUniformLocation(this.blendingWeightProgram,"u_resolution"),this.width,this.height),this.drawQuad(this.blendingWeightProgram,i),r.bindFramebuffer(r.FRAMEBUFFER,t),r.viewport(0,0,this.width,this.height),r.useProgram(this.neighborhoodBlendProgram),r.activeTexture(r.TEXTURE0),r.bindTexture(r.TEXTURE_2D,e),r.uniform1i(r.getUniformLocation(this.neighborhoodBlendProgram,"u_colorTex"),0),r.activeTexture(r.TEXTURE1),r.bindTexture(r.TEXTURE_2D,this.blendTexture),r.uniform1i(r.getUniformLocation(this.neighborhoodBlendProgram,"u_blendTex"),1),r.uniform2f(r.getUniformLocation(this.neighborhoodBlendProgram,"u_resolution"),this.width,this.height),r.uniform1f(r.getUniformLocation(this.neighborhoodBlendProgram,"u_intensity"),this.intensity),this.drawQuad(this.neighborhoodBlendProgram,i)}applyToCanvas(e,t){this.applyToFramebuffer(e,null,t)}applyToCanvas_OLD(e,t){if(!this.enabled||this.intensity<=0){this.copyToCanvas(e,t);return}let i=this.gl;i.bindFramebuffer(i.FRAMEBUFFER,this.edgesFramebuffer),i.viewport(0,0,this.width,this.height),i.useProgram(this.edgeDetectionProgram),i.activeTexture(i.TEXTURE0),i.bindTexture(i.TEXTURE_2D,e),i.uniform1i(i.getUniformLocation(this.edgeDetectionProgram,"u_screen"),0),i.uniform2f(i.getUniformLocation(this.edgeDetectionProgram,"u_resolution"),this.width,this.height),i.uniform1f(i.getUniformLocation(this.edgeDetectionProgram,"u_threshold"),this.threshold),this.drawQuad(this.edgeDetectionProgram,t),i.bindFramebuffer(i.FRAMEBUFFER,this.blendFramebuffer),i.viewport(0,0,this.width,this.height),i.useProgram(this.blendingWeightProgram),i.activeTexture(i.TEXTURE0),i.bindTexture(i.TEXTURE_2D,this.edgesTexture),i.uniform1i(i.getUniformLocation(this.blendingWeightProgram,"u_edgesTex"),0),i.uniform2f(i.getUniformLocation(this.blendingWeightProgram,"u_resolution"),this.width,this.height),this.drawQuad(this.blendingWeightProgram,t),i.bindFramebuffer(i.FRAMEBUFFER,null),i.viewport(0,0,this.width,this.height),i.useProgram(this.neighborhoodBlendProgram),i.activeTexture(i.TEXTURE0),i.bindTexture(i.TEXTURE_2D,e),i.uniform1i(i.getUniformLocation(this.neighborhoodBlendProgram,"u_colorTex"),0),i.activeTexture(i.TEXTURE1),i.bindTexture(i.TEXTURE_2D,this.blendTexture),i.uniform1i(i.getUniformLocation(this.neighborhoodBlendProgram,"u_blendTex"),1),i.uniform2f(i.getUniformLocation(this.neighborhoodBlendProgram,"u_resolution"),this.width,this.height),i.uniform1f(i.getUniformLocation(this.neighborhoodBlendProgram,"u_intensity"),this.intensity),this.drawQuad(this.neighborhoodBlendProgram,t)}drawQuad(e,t){let i=this.gl,r=i.getAttribLocation(e,"a_pos");i.bindBuffer(i.ARRAY_BUFFER,t),i.enableVertexAttribArray(r),i.vertexAttribPointer(r,2,i.FLOAT,!1,0,0),i.drawArrays(i.TRIANGLES,0,6)}copyToFramebuffer(e,t){let i=this.gl;i.useProgram(this.neighborhoodBlendProgram),i.activeTexture(i.TEXTURE0),i.bindTexture(i.TEXTURE_2D,e),i.uniform1i(i.getUniformLocation(this.neighborhoodBlendProgram,"u_colorTex"),0),i.activeTexture(i.TEXTURE1),i.bindTexture(i.TEXTURE_2D,this.blendTexture),i.uniform1i(i.getUniformLocation(this.neighborhoodBlendProgram,"u_blendTex"),1),i.uniform2f(i.getUniformLocation(this.neighborhoodBlendProgram,"u_resolution"),this.width,this.height),i.uniform1f(i.getUniformLocation(this.neighborhoodBlendProgram,"u_intensity"),0),this.drawQuad(this.neighborhoodBlendProgram,t)}copyToCanvas(e,t){let i=this.gl;i.bindFramebuffer(i.FRAMEBUFFER,null),i.viewport(0,0,this.width,this.height),this.copyToFramebuffer(e,t)}updateConfig(e){e.enabled!==void 0&&(this.enabled=e.enabled),e.intensity!==void 0&&(this.intensity=e.intensity),e.threshold!==void 0&&(this.threshold=e.threshold)}isEnabled(){return this.enabled&&this.intensity>0}resize(e,t){this.width=e,this.height=t,this.cleanup(),this.createFramebuffers()}cleanup(){let e=this.gl;this.edgesFramebuffer&&e.deleteFramebuffer(this.edgesFramebuffer),this.blendFramebuffer&&e.deleteFramebuffer(this.blendFramebuffer),this.edgesTexture&&e.deleteTexture(this.edgesTexture),this.blendTexture&&e.deleteTexture(this.blendTexture),this.edgesFramebuffer=null,this.blendFramebuffer=null,this.edgesTexture=null,this.blendTexture=null}setQuadBuffer(e){this.quadBuffer=e}get framebuffer(){return null}};X();var at=class{constructor(e){this.gl=e,this.reductionProgram=null,this.finalProgram=null,this.quadBuffer=null,this.reductionFBOs=[],this.reductionTextures=[],this.stats={red:{min:0,max:0,avg:0},green:{min:0,max:0,avg:0},blue:{min:0,max:0,avg:0},maxBrightness:0,avgBrightness:0,histogram:[],timestamp:0},this.initialized=!1}initialize(){let e=this.gl;this.quadBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.quadBuffer),e.bufferData(e.ARRAY_BUFFER,new Float32Array([0,0,1,0,0,1,0,1,1,0,1,1]),e.STATIC_DRAW);let t=`
attribute vec2 a_pos;
varying vec2 v_texcoord;
void main() {
    v_texcoord = a_pos;
    gl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);
}
`,i=`
precision highp float;
uniform sampler2D u_texture;
uniform vec2 u_texel_size;
varying vec2 v_texcoord;

void main() {
    // Sample 2x2 block
    vec2 base = v_texcoord;
    vec3 s0 = texture2D(u_texture, base).rgb;
    vec3 s1 = texture2D(u_texture, base + vec2(u_texel_size.x, 0.0)).rgb;
    vec3 s2 = texture2D(u_texture, base + vec2(0.0, u_texel_size.y)).rgb;
    vec3 s3 = texture2D(u_texture, base + u_texel_size).rgb;

    // Compute min/max across the 2x2 block
    vec3 minVal = min(min(s0, s1), min(s2, s3));
    vec3 maxVal = max(max(s0, s1), max(s2, s3));

    // Store: R=min, G=max, B=sum (for averaging)
    // We'll pack min in R channel, max in G channel, sum in B channel
    // Actually, we need all three channels for each stat, so let's use a different approach
    // Let's just compute the max for now (most useful for saturation buildup)

    gl_FragColor = vec4(maxVal, 1.0);
}
`;return this.reductionProgram=this.createProgram(t,i),this.reductionProgram?(this.initialized=!0,!0):(a.error("Failed to create reduction shader"),!1)}createProgram(e,t){let i=this.gl,r=i.createShader(i.VERTEX_SHADER);if(i.shaderSource(r,e),i.compileShader(r),!i.getShaderParameter(r,i.COMPILE_STATUS))return a.error("Vertex shader compile error:",i.getShaderInfoLog(r)),null;let o=i.createShader(i.FRAGMENT_SHADER);if(i.shaderSource(o,t),i.compileShader(o),!i.getShaderParameter(o,i.COMPILE_STATUS))return a.error("Fragment shader compile error:",i.getShaderInfoLog(o)),null;let s=i.createProgram();return i.attachShader(s,r),i.attachShader(s,o),i.linkProgram(s),i.getProgramParameter(s,i.LINK_STATUS)?s:(a.error("Program link error:",i.getProgramInfoLog(s)),null)}compute(e,t,i,r=!0){if(!this.initialized&&!this.initialize())return this.stats;let o=this.gl,s=r?16:2;return this.computeCPUSampled(e,t,i,s)}computeCPUSampled(e,t,i,r){let o=this.gl,s=o.createFramebuffer();if(o.bindFramebuffer(o.FRAMEBUFFER,s),o.framebufferTexture2D(o.FRAMEBUFFER,o.COLOR_ATTACHMENT0,o.TEXTURE_2D,e,0),o.checkFramebufferStatus(o.FRAMEBUFFER)!==o.FRAMEBUFFER_COMPLETE)return a.error("Framebuffer not complete for stats readback"),o.deleteFramebuffer(s),this.stats;let l=4,c=16,d=l*l*c*c,u=new Float32Array(d*4),h=0;for(let F=0;F<l;F++)for(let A=0;A<l;A++){let C=Math.floor(t/l*A+(t/l-c)/2),V=Math.floor(i/l*F+(i/l-c)/2),D=new Float32Array(c*c*4);o.readPixels(C,V,c,c,o.RGBA,o.FLOAT,D),u.set(D,h*4),h+=c*c}o.deleteFramebuffer(s),o.bindFramebuffer(o.FRAMEBUFFER,null);let g=1/0,f=-1/0,p=0,x=1/0,y=-1/0,b=0,v=1/0,w=-1/0,S=0,M=d;for(let F=0;F<M;F++){let A=F*4,C=u[A],V=u[A+1],D=u[A+2];g=Math.min(g,C),f=Math.max(f,C),p+=C,x=Math.min(x,V),y=Math.max(y,V),b+=V,v=Math.min(v,D),w=Math.max(w,D),S+=D}let E=M>0?p/M:0,R=M>0?b/M:0,I=M>0?S/M:0,B=20,z=new Array(B).fill(0),K=Math.max(f,y,w);if(K>0){let F=Math.log2(K+1);for(let A=0;A<M;A++){let C=A*4,V=Math.max(u[C],u[C+1],u[C+2]),D=Math.log2(V+1),k=Math.min(Math.floor(D/F*B),B-1);z[k]++}}return this.stats={red:{min:g,max:f,avg:E},green:{min:x,max:y,avg:R},blue:{min:v,max:w,avg:I},maxBrightness:Math.max(f,y,w),avgBrightness:(E+R+I)/3,histogram:z,timestamp:Date.now(),sampledPixels:M,sampleRate:r},this.stats}getCached(){return this.stats}dispose(){let e=this.gl;this.quadBuffer&&e.deleteBuffer(this.quadBuffer),this.reductionProgram&&e.deleteProgram(this.reductionProgram),this.finalProgram&&e.deleteProgram(this.finalProgram),this.reductionFBOs.forEach(t=>e.deleteFramebuffer(t)),this.reductionTextures.forEach(t=>e.deleteTexture(t)),this.reductionFBOs=[],this.reductionTextures=[]}};X();var lt=class{constructor(e){this.gl=e,this.program=null,this.quadBuffer=null,this.resultTexture=null,this.resultFBO=null,this.stats={maxVelocity:5,avgVelocity:2,sampleCount:0,timestamp:0},this.initialized=!1,this.shaderSource=null}initialize(e,t,i=null){let r=this.gl;if(this.quadBuffer=r.createBuffer(),r.bindBuffer(r.ARRAY_BUFFER,this.quadBuffer),r.bufferData(r.ARRAY_BUFFER,new Float32Array([0,0,1,0,0,1,0,1,1,0,1,1]),r.STATIC_DRAW),this.resultTexture=r.createTexture(),r.bindTexture(r.TEXTURE_2D,this.resultTexture),r.texImage2D(r.TEXTURE_2D,0,r.RGBA,64,1,0,r.RGBA,r.FLOAT,null),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE),this.resultFBO=r.createFramebuffer(),r.bindFramebuffer(r.FRAMEBUFFER,this.resultFBO),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,this.resultTexture,0),r.checkFramebufferStatus(r.FRAMEBUFFER)!==r.FRAMEBUFFER_COMPLETE)return a.error("Velocity stats framebuffer not complete"),this.dispose(),!1;r.bindFramebuffer(r.FRAMEBUFFER,null);let o=`vec${e}`,s=["x","y","z","w"],l=t.map((p,x)=>`    result.${s[x]} = ${p};`).join(`
`),c=i&&i.forwardTransform,d=c?`
// User-defined velocity field in native coordinates
${o} get_velocity_native(${o} pos_native) {
    ${o} result;
${l}
    return result;
}

// Velocity field for statistics (native-space integration)
${o} get_velocity(${o} pos_cartesian) {
    ${o} pos_native = transformToNative(pos_cartesian);
    return get_velocity_native(pos_native);
}
`:`
// User-defined velocity field
${o} get_velocity(${o} pos) {
    ${o} result;
    float x = pos.x;
    ${e>1?"float y = pos.y;":""}
    ${e>2?"float z = pos.z;":""}
    ${e>3?"float w = pos.w;":""}

${l}

    return result;
}
`,u=`
attribute vec2 a_pos;
varying vec2 v_texcoord;
void main() {
    v_texcoord = a_pos;
    gl_Position = vec4(a_pos * 2.0 - 1.0, 0.0, 1.0);
}
`,h=`
precision highp float;

${Array.from({length:e},(p,x)=>`uniform sampler2D u_pos_${x};`).join(`
`)}
uniform vec2 u_bbox_min;
uniform vec2 u_bbox_max;
uniform float u_resolution;
uniform float u_sample_count;
uniform float u_alpha;

varying vec2 v_texcoord;

${c?i.forwardTransform:""}

${d}

void main() {
    // Each output pixel computes velocity for one sampled particle
    float particleIndex = floor(v_texcoord.x * u_sample_count);

    // Random sampling across all particles
    float totalParticles = u_resolution * u_resolution;
    float stride = totalParticles / u_sample_count;
    float sampleIdx = particleIndex * stride;

    // Convert to texture coordinates
    float x = mod(sampleIdx, u_resolution);
    float y = floor(sampleIdx / u_resolution);
    vec2 texCoord = (vec2(x, y) + 0.5) / u_resolution;

    // Read position from textures
    vec${e} position;
    ${Array.from({length:e},(p,x)=>`position[${x}] = texture2D(u_pos_${x}, texCoord).r;`).join(`
    `)}

    // Compute velocity
    vec${e} velocity = get_velocity(position);

    // Compute magnitude
    float speed = length(velocity);

    // Output: R = velocity magnitude, G = 1.0 (for counting), B/A unused
    gl_FragColor = vec4(speed, 1.0, 0.0, 1.0);
}
`,g=r.createShader(r.VERTEX_SHADER);if(r.shaderSource(g,u),r.compileShader(g),!r.getShaderParameter(g,r.COMPILE_STATUS))return a.error("Velocity stats vertex shader error:",r.getShaderInfoLog(g)),!1;let f=r.createShader(r.FRAGMENT_SHADER);return r.shaderSource(f,h),r.compileShader(f),r.getShaderParameter(f,r.COMPILE_STATUS)?(this.program=r.createProgram(),r.attachShader(this.program,g),r.attachShader(this.program,f),r.linkProgram(this.program),r.getProgramParameter(this.program,r.LINK_STATUS)?(this.initialized=!0,this.dimensions=e,this.shaderSource=h,a.verbose("VelocityStatsManager initialized"),!0):(a.error("Velocity stats program link error:",r.getProgramInfoLog(this.program)),!1)):(a.error("Velocity stats fragment shader error:",r.getShaderInfoLog(f)),a.error(`Generated shader code:
`+h),!1)}compute(e,t,i,r=0){if(!this.initialized)return this.stats;let o=this.gl;o.bindFramebuffer(o.FRAMEBUFFER,this.resultFBO),o.viewport(0,0,64,1),o.useProgram(this.program);for(let x=0;x<this.dimensions;x++)o.activeTexture(o.TEXTURE0+x),o.bindTexture(o.TEXTURE_2D,e[x]),o.uniform1i(o.getUniformLocation(this.program,`u_pos_${x}`),x);o.uniform2f(o.getUniformLocation(this.program,"u_bbox_min"),t.min[0],t.min[1]),o.uniform2f(o.getUniformLocation(this.program,"u_bbox_max"),t.max[0],t.max[1]),o.uniform1f(o.getUniformLocation(this.program,"u_resolution"),i),o.uniform1f(o.getUniformLocation(this.program,"u_sample_count"),64),o.uniform1f(o.getUniformLocation(this.program,"u_alpha"),r),o.bindBuffer(o.ARRAY_BUFFER,this.quadBuffer);let s=o.getAttribLocation(this.program,"a_pos");o.enableVertexAttribArray(s),o.vertexAttribPointer(s,2,o.FLOAT,!1,0,0),o.drawArrays(o.TRIANGLES,0,6);let l=new Float32Array(256);o.readPixels(0,0,64,1,o.RGBA,o.FLOAT,l),o.bindFramebuffer(o.FRAMEBUFFER,null);let c=[],d=0,u=0;for(let x=0;x<64;x++){let y=l[x*4];isFinite(y)&&y>0&&(c.push(y),d=Math.max(d,y),u+=y)}let h=c.length,g=h>0?u/h:0,f=g,p=g;if(h>0){c.sort((b,v)=>b-v);let x=Math.floor(h*.9),y=Math.floor(h*.95);f=c[Math.min(x,h-1)],p=c[Math.min(y,h-1)]}return this.stats={maxVelocity:d>0?d:this.stats.maxVelocity,avgVelocity:g>0?g:this.stats.avgVelocity,percentile90:f>0?f:this.stats.percentile90||g,percentile95:p>0?p:this.stats.percentile95||g,sampleCount:h,timestamp:Date.now()},this.stats}getCached(){return this.stats}dispose(){let e=this.gl;this.quadBuffer&&e.deleteBuffer(this.quadBuffer),this.program&&e.deleteProgram(this.program),this.resultTexture&&e.deleteTexture(this.resultTexture),this.resultFBO&&e.deleteFramebuffer(this.resultFBO),this.initialized=!1}needsRecompile(){return!0}getShaderSource(){return this.shaderSource}};X();var ct=class{constructor(e,t,i,r){this.particleCount=e,this.dimensions=t,this.bbox=i||this.getDefaultBBox(t),this.strategy=r,this.resolution=Math.ceil(Math.sqrt(e)),this.actualParticleCount=this.resolution*this.resolution,this.initializeParticles()}getDefaultBBox(e){return{min:new Array(e).fill(-5),max:new Array(e).fill(5)}}initializeParticles(){this.data=[];let e=[],t=this.strategy.getArrayType(),i=this.strategy.getComponentsPerValue();for(let r=0;r<this.dimensions;r++){let o=new t(this.actualParticleCount*i);for(let s=0;s<this.actualParticleCount;s++){let c;if(r<2&&this.bbox.min&&this.bbox.max){let f=r===0?this.bbox.min[0]:this.bbox.min[1],x=(r===0?this.bbox.max[0]:this.bbox.max[1])-f;c=f+x*-.02+Math.random()*x*(1-2*-.02)}else c=-10.4+Math.random()*20.8;let d=r<2?r===0?this.bbox.min[0]:this.bbox.min[1]:-10,u=r<2?r===0?this.bbox.max[0]:this.bbox.max[1]:10,h=this.strategy.encodeValue(c,d,u),g=s*i;for(let f=0;f<i;f++)o[g+f]=h[f];if(s<10&&r<2){let f=new t(i);for(let y=0;y<i;y++)f[y]=o[g+y];let p=this.strategy.decodeValue(f,d,u);e[s]||(e[s]={});let x;i===4?x=`[${h[0].toFixed?.(0)||h[0]}, ${h[1].toFixed?.(0)||h[1]}, ${h[2].toFixed?.(0)||h[2]}, ${h[3].toFixed?.(0)||h[3]}]`:x=h[0].toString(),e[s][r===0?"x":"y"]={worldValue:c.toFixed(4),encoded:x,decodedWorld:p.toFixed(4),error:Math.abs(c-p).toFixed(6)}}}this.data.push(o)}e.length>0&&a.info("Particle initialization - first 10 particles:",{strategy:this.strategy.getName(),bbox:`[${this.bbox.min[0]}, ${this.bbox.min[1]}] to [${this.bbox.max[0]}, ${this.bbox.max[1]}]`,samples:e.filter(r=>r)}),this.indices=new Float32Array(this.actualParticleCount);for(let r=0;r<this.actualParticleCount;r++)this.indices[r]=r}getDimensionData(e){return this.data[e]}getAllData(){return this.data}getIndices(){return this.indices}setParticleCount(e){this.particleCount=e,this.resolution=Math.ceil(Math.sqrt(e)),this.actualParticleCount=this.resolution*this.resolution,this.initializeParticles()}setDimensions(e){this.dimensions=e,this.bbox=this.getDefaultBBox(e),this.initializeParticles()}setBBox(e){this.bbox=e}getResolution(){return this.resolution}getActualParticleCount(){return this.actualParticleCount}};Gt();X();var jr=["x","y","z","w","u","v"];function je(n){let e=n===2?"mat2":n===3?"mat3":"mat4",t=`inverse${n}`;if(n===2)return`
// Compute inverse of 2x2 matrix (closed form)
// For matrix [a c; b d] (column-major), inverse is [d -c; -b a] / det
mat2 inverse2(mat2 m) {
    float det = m[0][0]*m[1][1] - m[1][0]*m[0][1];
    return mat2(m[1][1], -m[1][0], -m[0][1], m[0][0]) / det;
}`;let i=`
// Compute inverse of ${n}x${n} matrix using Gauss-Jordan elimination
${e} ${t}(${e} m) {
    // Create augmented matrix [m | I] stored as ${n} column vectors
`;for(let r=0;r<n;r++){i+=`    vec${n} aug${r} = vec${n}(`;for(let o=0;o<n;o++)o>0&&(i+=", "),i+=`m[${r}][${o}]`;i+=`);
`}for(let r=0;r<n;r++){i+=`    vec${n} aug${n+r} = vec${n}(`;for(let o=0;o<n;o++)o>0&&(i+=", "),i+=o===r?"1.0":"0.0";i+=`);
`}i+=`
`;for(let r=0;r<n;r++){i+=`    // Pivot ${r}: Make diagonal element = 1 and eliminate column ${r}
`,i+=`    float scale${r} = aug${r}[${r}];
`,i+=`    if (abs(scale${r}) < 0.0001) scale${r} = 0.0001;
`;for(let o=0;o<2*n;o++)i+=`    aug${o}[${r}] /= scale${r};
`;i+=`
`;for(let o=0;o<n;o++)if(o!==r){i+=`    // Eliminate row ${o}
`,i+=`    float factor${r}_${o} = aug${r}[${o}];
`;for(let s=0;s<2*n;s++)i+=`    aug${s}[${o}] -= factor${r}_${o} * aug${s}[${r}];
`;i+=`
`}}i+=`    // Extract inverse from augmented matrix
`,i+=`    return ${e}(
`;for(let r=0;r<n;r++)r>0&&(i+=`,
`),i+=`        aug${n+r}`;return i+=`
    );
`,i+=`}
`,i}function dt(n,e){let t=e===2?"mat2":e===3?"mat3":"mat4",i=`vec${e}`,r="";for(let l=0;l<e;l++)r+=`    float ${jr[l]} = pos.${["x","y","z","w"][l]};
`;let o=[];for(let l=0;l<e;l++)for(let c=0;c<e;c++){let d=n[c][l];try{let u=de(d,e);o.push(u)}catch(u){a.warn(`Failed to compile Jacobian element [${c}][${l}]: ${d}`,u),o.push("0.0")}}return`
${je(e)}

// Compute Jacobian matrix at given position
${t} computeJacobian(${i} pos) {
${r}
    return ${t}(
        ${o.join(`,
        `)}
    );
}`}function me(n,e,t){let i=e(n);return`        ${n} = ${i};`}function Oe(n,e,t){let i=`vec${t}`,r=`${n}_pred`,o=`${n}_mid`,s=e(n),l=e(o);return`        // Predictor: standard fixed-point step
        ${i} ${r} = ${s};

        // Corrector: evaluate at midpoint between current and predictor
        ${i} ${o} = (${n} + ${r}) * 0.5;
        ${n} = ${l};`}function Ge(n,e,t,i){let r=`vec${i}`,o=i===2?"mat2":i===3?"mat3":"mat4",s=`inverse${i}`,l=e(n),c=t(n);return`        ${r} F_${n} = ${l};
        ${o} J_${n} = ${c};

        // Newton step: x -= J^(-1) * F
        ${r} delta_${n} = ${s}(J_${n}) * F_${n};
        ${n} -= delta_${n};`}function He(n,e,t,i="h",r=null){let o=`vec${t}`,s=t===2?"mat2":t===3?"mat3":"mat4",l=`inverse${t}`,c=["x","y","z","w"],d="1e-4",u="",h=[];for(let p=0;p<t;p++){let x=`Df_col${p}_${n}`,y=Array.from({length:t},(w,S)=>S===p?d:"0.0").join(", "),b=e(`${n} + ${o}(${y})`),v=e(n);u+=`
        // Velocity Jacobian column ${p}: d(velocity)/d${c[p]}
        ${o} ${x} = (${b} - ${v}) / ${d};`,h.push(x)}u+=`

        // Velocity Jacobian matrix Df
        ${s} Df_${n} = ${s}(${h.join(", ")});

        // Residual Jacobian: J_F = I - ${i} * Df
        ${s} J_${n} = ${s}(1.0) - ${i} * Df_${n};`;let g=e(n),f=r||`pos + ${i} * ${g}`;return`        // Finite difference Jacobian approximation (epsilon = ${d})${u}

        // Compute residual: F(x) = x - RHS
        ${o} F_${n} = ${n} - (${f});

        // Newton step: x -= J^(-1) * F
        ${o} delta_${n} = ${l}(J_${n}) * F_${n};
        ${n} -= delta_${n};`}function Xr(n){return{name:"Euler",costFactor:1,code:`
// Euler integration
vec${n} integrate(vec${n} pos, float h) {
    vec${n} velocity = get_velocity(pos);
    return pos + h * velocity;
}
`}}function Hi(n){return{name:"Explicit Midpoint",costFactor:2,code:`
// Explicit Midpoint (RK2) integration
vec${n} integrate(vec${n} pos, float h) {
    vec${n} k1 = get_velocity(pos);
    vec${n} k2 = get_velocity(pos + h * 0.5 * k1);
    return pos + h * k2;
}
`}}function Wr(n){return{name:"Heun (Explicit Trapezoidal)",costFactor:2,code:`
// Heun's Method (Explicit Trapezoidal) integration
vec${n} integrate(vec${n} pos, float h) {
    vec${n} k1 = get_velocity(pos);
    vec${n} k2 = get_velocity(pos + h * k1);
    return pos + h * 0.5 * (k1 + k2);
}
`}}function ji(n){return{name:"RK4",costFactor:4,code:`
// Runge-Kutta 4 integration
vec${n} integrate(vec${n} pos, float h) {
    vec${n} k1 = get_velocity(pos);
    vec${n} k2 = get_velocity(pos + h * 0.5 * k1);
    vec${n} k3 = get_velocity(pos + h * 0.5 * k2);
    vec${n} k4 = get_velocity(pos + h * k3);

    return pos + h * (k1 / 6.0 + k2 / 3.0 + k3 / 3.0 + k4 / 6.0);
}
`}}function Xi(n,e=3,t="fixed-point",i=null){a.info(`*** Implicit Euler integrator requested: solutionMethod=${t}, hasExpressions=${!!i}`);let r=`vec${n}`,o=n===2?"mat2":n===3?"mat3":"mat4",s="pos + h * get_velocity(pos)",l=g=>`pos + h * get_velocity(${g})`,c=g=>`get_velocity(${g})`,d,u,h="";if(t==="newton"&&i){a.info("Computing Jacobian for Newton's method");let g=xe(i,n);ke(g)?(a.info("\u2713 Successfully using Newton's method for Implicit Euler"),h=dt(g,n),d=Ge("x_new",x=>`${x} - pos - h * get_velocity(${x})`,x=>`${o}(1.0) - h * computeJacobian(${x})`,n),u="Newton"):(a.warn("\u2717 Failed to compute Jacobian for Newton's method"),a.warn("Falling back to fixed-point iteration"),d=me("x_new",l,n),u="Fixed-Point")}else t==="newton-fd"?(a.info("\u2713 Using finite difference Newton's method for Implicit Euler"),h=je(n),d=He("x_new",c,n),u="Newton (FD)"):t==="midpoint"?(d=Oe("x_new",l,n),u="Midpoint"):(d=me("x_new",l,n),u="Fixed-Point");return{name:`Implicit Euler (${u})`,costFactor:1,code:`
${h}
// Implicit Euler integration (${u.toLowerCase()} solver)
${r} integrate(${r} pos, float h) {
    // Start with initial guess
    ${r} x_new = ${s};

    // Iterative solver
    for (int i = 0; i < ${e}; i++) {
${d}
    }

    return x_new;
}
`}}function Jr(n,e=4,t="fixed-point",i=null){a.info(`*** Implicit Midpoint integrator requested: solutionMethod=${t}, hasExpressions=${!!i}`);let r=`vec${n}`,o=n===2?"mat2":n===3?"mat3":"mat4",l="pos + h * get_velocity(pos + h * 0.5 * get_velocity(pos))",c=f=>`pos + h * get_velocity((pos + ${f}) * 0.5)`,d=f=>`get_velocity((pos + ${f}) * 0.5)`,u,h,g="";if(t==="newton"&&i){a.info("Computing Jacobian for Newton's method (Implicit Midpoint)");let f=xe(i,n);ke(f)?(a.info("\u2713 Successfully using Newton's method for Implicit Midpoint"),g=dt(f,n),u=Ge("x_new",y=>`${y} - pos - h * get_velocity((pos + ${y}) * 0.5)`,y=>`${o}(1.0) - (h * 0.5) * computeJacobian((pos + ${y}) * 0.5)`,n),h="Newton"):(a.warn("\u2717 Failed to compute Jacobian for Newton's method (Implicit Midpoint)"),a.warn("Falling back to fixed-point iteration"),u=me("x_new",c,n),h="Fixed-Point")}else t==="newton-fd"?(a.info("\u2713 Using finite difference Newton's method for Implicit Midpoint"),g=je(n),u=He("x_new",d,n,"h * 0.5"),h="Newton (FD)"):t==="midpoint"?(u=Oe("x_new",c,n),h="Midpoint"):(u=me("x_new",c,n),h="Fixed-Point");return{name:`Implicit Midpoint (${h})`,costFactor:2,code:`
${g}
// Implicit Midpoint integration (${h.toLowerCase()} solver)
${r} integrate(${r} pos, float h) {
    // Start with initial guess
    ${r} x_new = ${l};

    // Iterative solver
    for (int i = 0; i < ${e}; i++) {
${u}
    }

    return x_new;
}
`}}function qr(n,e=4,t="fixed-point",i=null){a.info(`*** Trapezoidal integrator requested: solutionMethod=${t}, hasExpressions=${!!i}`);let r=`vec${n}`,o=n===2?"mat2":n===3?"mat3":"mat4",s="pos + h * f0",l=g=>`pos + h * 0.5 * (f0 + get_velocity(${g}))`,c=g=>`get_velocity(${g})`,d,u,h="";if(t==="newton"&&i){a.info("Computing Jacobian for Newton's method (Trapezoidal)");let g=xe(i,n);ke(g)?(a.info("\u2713 Successfully using Newton's method for Trapezoidal"),h=dt(g,n),d=Ge("x_new",x=>`${x} - pos - h * 0.5 * (f0 + get_velocity(${x}))`,x=>`${o}(1.0) - (h * 0.5) * computeJacobian(${x})`,n),u="Newton"):(a.warn("\u2717 Failed to compute Jacobian for Newton's method (Trapezoidal)"),a.warn("Falling back to fixed-point iteration"),d=me("x_new",l,n),u="Fixed-Point")}else t==="newton-fd"?(a.info("\u2713 Using finite difference Newton's method for Trapezoidal"),h=je(n),d=He("x_new",c,n,"h * 0.5","pos + h * 0.5 * (f0 + "+c("x_new")+")"),u="Newton (FD)"):t==="midpoint"?(d=Oe("x_new",l,n),u="Midpoint"):(d=me("x_new",l,n),u="Fixed-Point");return{name:`Trapezoidal (${u})`,costFactor:2,code:`
${h}
// Trapezoidal Rule integration (${u.toLowerCase()} solver)
${r} integrate(${r} pos, float h) {
    ${r} f0 = get_velocity(pos);

    // Start with initial guess
    ${r} x_new = ${s};

    // Iterative solver
    for (int i = 0; i < ${e}; i++) {
${d}
    }

    return x_new;
}
`}}function Kr(n,e=5,t="fixed-point",i=null){a.info(`*** Implicit RK4 integrator requested: solutionMethod=${t}, hasExpressions=${!!i}`);let r=`vec${n}`,o=n===2?"mat2":n===3?"mat3":"mat4",s=`
    // Gauss-Legendre coefficients for 2-stage method
    const float a11 = 0.25;
    const float a12 = 0.25 - sqrt(3.0) / 6.0;
    const float a21 = 0.25 + sqrt(3.0) / 6.0;
    const float a22 = 0.25;
    const float b1 = 0.5;
    const float b2 = 0.5;
    const float c1 = 0.5 - sqrt(3.0) / 6.0;
    const float c2 = 0.5 + sqrt(3.0) / 6.0;`,l=`
    // Start with explicit RK4 as initial guess
    ${r} k1_guess = get_velocity(pos);
    ${r} k2_guess = get_velocity(pos + h * 0.5 * k1_guess);

    ${r} k1 = k1_guess;
    ${r} k2 = k2_guess;`,c=b=>`get_velocity(pos + h * (a11 * ${b} + a12 * k2))`,d=b=>`get_velocity(pos + h * (a21 * k1 + a22 * ${b}))`,u=b=>`get_velocity(pos + h * (a11 * ${b} + a12 * k2))`,h=b=>`get_velocity(pos + h * (a21 * k1 + a22 * ${b}))`,g,f,p,x="";if(t==="newton"&&i){a.info("Computing Jacobian for Newton's method (Implicit RK4 - simplified)");let b=xe(i,n);if(ke(b)){a.info("\u2713 Successfully using simplified Newton's method for Implicit RK4"),x=dt(b,n);let v=E=>`${E} - get_velocity(pos + h * (a11 * ${E} + a12 * k2))`,w=E=>`${o}(1.0) - (h * a11) * computeJacobian(pos + h * (a11 * ${E} + a12 * k2))`,S=E=>`${E} - get_velocity(pos + h * (a21 * k1 + a22 * ${E}))`,M=E=>`${o}(1.0) - (h * a22) * computeJacobian(pos + h * (a21 * k1 + a22 * ${E}))`;g=Ge("k1",v,w,n),f=Ge("k2",S,M,n),p="Newton"}else a.warn("\u2717 Failed to compute Jacobian for Newton's method (Implicit RK4)"),a.warn("Falling back to fixed-point iteration"),g=me("k1",c,n),f=me("k2",d,n),p="Fixed-Point"}else t==="newton-fd"?(a.info("\u2713 Using finite difference Newton's method for Implicit RK4 (simplified)"),x=je(n),g=He("k1",u,n,"h * a11"),f=He("k2",h,n,"h * a22"),p="Newton (FD)"):t==="midpoint"?(g=Oe("k1",c,n),f=Oe("k2",d,n),p="Midpoint"):(g=me("k1",c,n),f=me("k2",d,n),p="Fixed-Point");let y=`
    // Iterative solver for coupled stages (Gauss-Seidel style)
    for (int i = 0; i < ${e}; i++) {
        // Stage 1
${g}

        // Stage 2
${f}
    }`;return{name:`Implicit RK4 (${p})`,costFactor:4,code:`
${x}
// Implicit RK4 (Gauss-Legendre 2-stage) integration (${p.toLowerCase()} solver)
${r} integrate(${r} pos, float h) {
${s}
${l}
${y}

    return pos + h * (b1 * k1 + b2 * k2);
}
`}}function Wi(n,e,t={}){let i=t.iterations||3,r=t.solutionMethod||"fixed-point",o=t.expressions||null;switch(n){case"euler":return Xr(e);case"explicit-midpoint":return Hi(e);case"heun":return Wr(e);case"rk4":return ji(e);case"implicit-euler":return Xi(e,i,r,o);case"implicit-midpoint":return Jr(e,t.iterations||4,r,o);case"trapezoidal":return qr(e,t.iterations||4,r,o);case"implicit-rk4":return Kr(e,t.iterations||5,r,o);case"rk2":return Hi(e);case"implicit":return Xi(e,i,r,o);default:return ji(e)}}function ut(n,e,t,i=null){i===null&&(i=t>=3?2:-1);let r=i>=0&&i<t;return{name:"Select",params:{dim1:n,dim2:e,depthDim:i},code:`
// Select 2 dimensions for display${r?" (with depth)":""}
vec2 project_to_2d(vec${t} pos) {
    return vec2(pos[${n}], pos[${e}]);
}

vec3 project_to_3d(vec${t} pos) {
    return vec3(pos[${n}], pos[${e}], ${r?`pos[${i}]`:"0.0"});
}
`}}function Yr(n,e){let t=n[0].map((o,s)=>`${o.toFixed(6)} * pos[${s}]`).join(" + "),i=n[1].map((o,s)=>`${o.toFixed(6)} * pos[${s}]`).join(" + "),r=n[2]?n[2].map((o,s)=>`${o.toFixed(6)} * pos[${s}]`).join(" + "):null;return{name:"Linear Projection",params:{matrix:n},code:`
// Linear projection matrix
vec2 project_to_2d(vec${e} pos) {
    return vec2(
        ${t},
        ${i}
    );
}

vec3 project_to_3d(vec${e} pos) {
    return vec3(
        ${t},
        ${i},
        ${r||"0.0"}
    );
}
`}}function Zr(n,e){let t=n===0?1:0,i=t+1;return i===n&&i++,{name:"Orthographic",params:{axis:n},code:`
// Orthographic projection (remove axis ${n}, use as depth)
vec2 project_to_2d(vec${e} pos) {
    return vec2(pos[${t}], pos[${i}]);
}

vec3 project_to_3d(vec${e} pos) {
    return vec3(pos[${t}], pos[${i}], pos[${n}]);
}
`}}function Qr(){return{name:"Spherical",params:{},code:`
// Spherical projection (3D only)
vec2 project_to_2d(vec3 pos) {
    float r = length(pos);
    if (r < 0.001) return vec2(0.0, 0.0);

    float theta = atan(pos.y, pos.x);
    float phi = acos(pos.z / r);

    return vec2(theta, phi);
}

vec3 project_to_3d(vec3 pos) {
    float r = length(pos);
    if (r < 0.001) return vec3(0.0, 0.0, 0.0);

    float theta = atan(pos.y, pos.x);
    float phi = acos(pos.z / r);

    return vec3(theta, phi, r);  // Use radius as depth
}
`}}function eo(n){return{name:"Stereographic",params:{},code:`
// Stereographic projection
vec2 project_to_2d(vec${n} pos) {
    float denom = 1.0 - pos[${n-1}];
    if (abs(denom) < 0.001) denom = 0.001;
    return vec2(pos[0] / denom, pos[1] / denom);
}

vec3 project_to_3d(vec${n} pos) {
    float denom = 1.0 - pos[${n-1}];
    if (abs(denom) < 0.001) denom = 0.001;
    return vec3(pos[0] / denom, pos[1] / denom, pos[${n-1}]);
}
`}}function Ji(n,e,t={}){switch(n){case"select":{let i=t.dim1!==void 0?t.dim1:0,r=t.dim2!==void 0?t.dim2:Math.min(1,e-1),o=t.depthDim!==void 0?t.depthDim:null;return ut(i,r,e,o)}case"project":{let i=t.matrix||[[1,0,...Array(Math.max(0,e-2)).fill(0)],[0,1,...Array(Math.max(0,e-2)).fill(0)]];return Yr(i,e)}case"orthographic":{let i=t.axis!==void 0?t.axis:e-1;return Zr(i,e)}case"spherical":return e===3?Qr():ut(0,1,e);case"stereographic":return e>=3?eo(e):ut(0,1,e);case"custom":{let i=t.horizontalExpr||"x",r=t.verticalExpr||"y",o=t.depthExpr||"";return to(i,r,o,e)}default:return ut(0,1,e)}}function to(n,e,t,i){let r=de(n||"x",i),o=de(e||"y",i),s=t?de(t,i):"0.0";return{name:"Custom",params:{horizontalExpr:n,verticalExpr:e,depthExpr:t},code:`
// Custom mapper
vec2 project_to_2d(vec${i} pos) {
    return vec2(
        ${r},
        ${o}
    );
}

vec3 project_to_3d(vec${i} pos) {
    return vec3(
        ${r},
        ${o},
        ${s}
    );
}
`}}var se=class{constructor(e,t){this.name=e,this.description=t}generateHelpers(e){return""}generateForward(e){throw new Error("generateForward must be implemented")}generateInverse(e){throw new Error("generateInverse must be implemented")}generateJacobian(e){throw new Error("generateJacobian must be implemented")}getParameters(){return[]}},Pe=class extends se{constructor(){super("identity","No transformation (identity)")}generateForward(e){let t=`vec${e}`;return`
${t} transform_forward(${t} x) {
    return x;
}`}generateInverse(e){let t=`vec${e}`;return`
${t} transform_inverse(${t} y) {
    return y;
}`}generateJacobian(e){let t=`vec${e}`;return`
${t} transform_jacobian(${t} x) {
    return ${t}(1.0);
}`}},Ht=class extends se{constructor(){super("power","Power transform (zoom lens effect)")}generateForward(e){let t=`vec${e}`;return`
${t} transform_forward(${t} x) {
    float alpha = u_transform_params.x;
    ${t} result;
    ${Array.from({length:e},(i,r)=>{let o=["x","y","z","w"][r]||`[${r}]`;return`    result.${o} = sign(x.${o}) * pow(abs(x.${o}) + 1e-8, alpha);`}).join(`
`)}
    return result;
}`}generateInverse(e){let t=`vec${e}`;return`
${t} transform_inverse(${t} y) {
    float alpha = u_transform_params.x;
    float inv_alpha = 1.0 / alpha;
    ${t} result;
    ${Array.from({length:e},(i,r)=>{let o=["x","y","z","w"][r]||`[${r}]`;return`    result.${o} = sign(y.${o}) * pow(abs(y.${o}) + 1e-8, inv_alpha);`}).join(`
`)}
    return result;
}`}generateJacobian(e){let t=`vec${e}`;return`
${t} transform_jacobian(${t} x) {
    float alpha = u_transform_params.x;
    ${t} result;
    ${Array.from({length:e},(i,r)=>{let o=["x","y","z","w"][r]||`[${r}]`;return`    result.${o} = alpha * pow(abs(x.${o}) + 1e-8, alpha - 1.0);`}).join(`
`)}
    return result;
}`}getParameters(){return[{name:"alpha",label:"Exponent (\u03B1)",type:"slider",min:1e-4,max:25,step:1e-4,default:.5,info:"\u03B1 < 1.0: zoom into origin; \u03B1 > 1.0: compress origin"}]}},jt=class extends se{constructor(){super("tanh","Hyperbolic tangent (compress infinity)")}generateHelpers(e){return`
// Helper: tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)
float tanh_scalar(float x) {
    float e2x = exp(2.0 * x);
    return (e2x - 1.0) / (e2x + 1.0);
}
`}generateForward(e){let t=`vec${e}`;return`
${t} transform_forward(${t} x) {
    float beta = u_transform_params.x;
    ${t} result;
    ${Array.from({length:e},(i,r)=>{let o=["x","y","z","w"][r]||`[${r}]`;return`result.${o} = tanh_scalar(beta * x.${o});`}).join(`
    `)}
    return result;
}`}generateInverse(e){let t=`vec${e}`;return`
${t} transform_inverse(${t} y) {
    float beta = u_transform_params.x;
    // atanh(y) = 0.5 * log((1+y)/(1-y))
    ${t} result;
    ${Array.from({length:e},(i,r)=>{let o=["x","y","z","w"][r]||`[${r}]`;return`{
        float y_clamped = clamp(y.${o}, -0.99999, 0.99999);
        result.${o} = 0.5 * log((1.0 + y_clamped) / (1.0 - y_clamped)) / beta;
    }`}).join(`
    `)}
    return result;
}`}generateJacobian(e){let t=`vec${e}`;return`
${t} transform_jacobian(${t} x) {
    float beta = u_transform_params.x;
    // Jacobian of tanh: d/dx tanh(x) = 1 - tanh^2(x)
    ${t} tanh_vals;
    ${Array.from({length:e},(i,r)=>{let o=["x","y","z","w"][r]||`[${r}]`;return`tanh_vals.${o} = tanh_scalar(beta * x.${o});`}).join(`
    `)}
    return beta * (${t}(1.0) - tanh_vals * tanh_vals);
}`}getParameters(){return[{name:"beta",label:"Compression (\u03B2)",type:"slider",min:1e-4,max:25,step:1e-4,default:1,info:"Higher = more compression. Maps infinite space to [-1,1]"}]}},Xt=class extends se{constructor(){super("sigmoid","Logistic Sigmoid (smooth S-curve)")}generateHelpers(e){return`
// Helper: sigmoid(x) = 1 / (1 + exp(-x))
float sigmoid_scalar(float x) {
    return 1.0 / (1.0 + exp(-x));
}
`}generateForward(e){let t=`vec${e}`;return`
${t} transform_forward(${t} x) {
    float k = u_transform_params.x;
    ${t} result;
    ${Array.from({length:e},(i,r)=>{let o=["x","y","z","w"][r]||`[${r}]`;return`result.${o} = 2.0 * sigmoid_scalar(k * x.${o}) - 1.0;`}).join(`
    `)}
    return result;
}`}generateInverse(e){let t=`vec${e}`;return`
${t} transform_inverse(${t} y) {
    float k = u_transform_params.x;
    // Inverse: x = ln((y+1)/(1-y)) / k
    ${t} result;
    ${Array.from({length:e},(i,r)=>{let o=["x","y","z","w"][r]||`[${r}]`;return`{
        float y_clamped = clamp(y.${o}, -0.99999, 0.99999);
        result.${o} = log((y_clamped + 1.0) / (1.0 - y_clamped)) / k;
    }`}).join(`
    `)}
    return result;
}`}generateJacobian(e){let t=`vec${e}`;return`
${t} transform_jacobian(${t} x) {
    float k = u_transform_params.x;
    // Jacobian: d/dx [2*sigmoid(k*x) - 1] = 2k * sigmoid(k*x) * (1 - sigmoid(k*x))
    ${t} result;
    ${Array.from({length:e},(i,r)=>{let o=["x","y","z","w"][r]||`[${r}]`;return`{
        float sig = sigmoid_scalar(k * x.${o});
        result.${o} = 2.0 * k * sig * (1.0 - sig);
    }`}).join(`
    `)}
    return result;
}`}getParameters(){return[{name:"k",label:"Steepness (k)",type:"slider",min:1e-4,max:25,step:1e-4,default:1,info:"Higher = steeper transition. Maps infinite space to [-1,1] with logistic curve."}]}},Wt=class extends se{constructor(){super("rational","Rational (bell-shaped Jacobian)")}generateForward(e){let t=`vec${e}`;return`
${t} transform_forward(${t} x) {
    float a = u_transform_params.x;
    ${t} result;
    ${Array.from({length:e},(i,r)=>{let o=["x","y","z","w"][r]||`[${r}]`;return`result.${o} = x.${o} / sqrt(x.${o} * x.${o} + a);`}).join(`
    `)}
    return result;
}`}generateInverse(e){let t=`vec${e}`;return`
${t} transform_inverse(${t} y) {
    float a = u_transform_params.x;
    // Inverse: x = y * sqrt(a / (1 - y^2))
    // Note: y is bounded to [-1, 1] regardless of a
    ${t} result;
    ${Array.from({length:e},(i,r)=>{let o=["x","y","z","w"][r]||`[${r}]`;return`{
        float y_clamped = clamp(y.${o}, -0.99999, 0.99999);
        float y_sq = y_clamped * y_clamped;
        result.${o} = y_clamped * sqrt(a / (1.0 - y_sq));
    }`}).join(`
    `)}
    return result;
}`}generateJacobian(e){let t=`vec${e}`;return`
${t} transform_jacobian(${t} x) {
    float a = u_transform_params.x;
    // Jacobian: d/dx [x/sqrt(x^2+a)] = a/(x^2+a)^(3/2)
    // This is bell-shaped! Peaks at x=0, decays at infinity
    ${t} result;
    ${Array.from({length:e},(i,r)=>{let o=["x","y","z","w"][r]||`[${r}]`;return`{
        float x_sq = x.${o} * x.${o};
        float denom = x_sq + a;
        result.${o} = a / (denom * sqrt(denom));
    }`}).join(`
    `)}
    return result;
}`}getParameters(){return[{name:"a",label:"Width (a)",type:"slider",min:1e-4,max:25,step:1e-4,default:1,info:"Controls bell curve width. Higher = wider/shallower, lower = narrower/sharper."}]}},Jt=class extends se{constructor(){super("sine","Sine wave distortion (periodic speed bumps)")}generateForward(e){let t=`vec${e}`;return`
${t} transform_forward(${t} x) {
    float amplitude = u_transform_params.x;
    float frequency = u_transform_params.y;
    return x + amplitude * sin(frequency * x);
}`}generateInverse(e){let t=`vec${e}`;return`
${t} transform_inverse(${t} y) {
    float amplitude = u_transform_params.x;
    float frequency = u_transform_params.y;

    // Newton's method: x_{n+1} = x_n - (f(x_n) - y) / f'(x_n)
    // where f(x) = x + a*sin(f*x)
    // f'(x) = 1 + a*f*cos(f*x)
    ${t} x = y; // Initial guess
    for (int iter = 0; iter < 5; iter++) {
        ${t} fx = x + amplitude * sin(frequency * x);
        ${t} dfx = ${t}(1.0) + amplitude * frequency * cos(frequency * x);
        x = x - (fx - y) / dfx;
    }
    return x;
}`}generateJacobian(e){let t=`vec${e}`;return`
${t} transform_jacobian(${t} x) {
    float amplitude = u_transform_params.x;
    float frequency = u_transform_params.y;
    return ${t}(1.0) + amplitude * frequency * cos(frequency * x);
}`}getParameters(){return[{name:"amplitude",label:"Amplitude",type:"slider",min:1e-4,max:25,step:1e-4,default:.5,info:"Strength of distortion"},{name:"frequency",label:"Frequency",type:"slider",min:1e-4,max:25,step:1e-4,default:1,info:"Number of waves per unit length"}]}},qt=class extends se{constructor(){super("radial_power","Radial power (compress/expand by distance)")}generateForward(e){let t=`vec${e}`;return e===2?`
${t} transform_forward(${t} x) {
    float alpha = u_transform_params.x;
    float r = length(x);
    if (r < 1e-8) return x;
    float r_new = pow(r, alpha);
    return x * (r_new / r);
}`:`
${t} transform_forward(${t} x) {
    float alpha = u_transform_params.x;
    float r = length(x);
    if (r < 1e-8) return x;
    float r_new = pow(r, alpha);
    return x * (r_new / r);
}`}generateInverse(e){let t=`vec${e}`;return`
${t} transform_inverse(${t} y) {
    float alpha = u_transform_params.x;
    float inv_alpha = 1.0 / alpha;
    float r = length(y);
    if (r < 1e-8) return y;
    float r_new = pow(r, inv_alpha);
    return y * (r_new / r);
}`}generateJacobian(e){let t=`vec${e}`;return`
${t} transform_jacobian(${t} x) {
    float alpha = u_transform_params.x;
    float r = length(x);
    float jacobian_scalar = alpha * pow(r + 1e-8, alpha - 1.0);
    return ${t}(jacobian_scalar);
}`}getParameters(){return[{name:"alpha",label:"Radial Exponent (\u03B1)",type:"slider",min:.1,max:3,step:.1,default:.5,info:"\u03B1 < 1.0: zoom into origin; \u03B1 > 1.0: compress origin"}]}},Kt=class extends se{constructor(){super("log","Logarithmic (stretch near zero)")}generateForward(e){let t=`vec${e}`;return`
${t} transform_forward(${t} x) {
    ${t} result;
    ${Array.from({length:e},(i,r)=>{let o=["x","y","z","w"][r]||`[${r}]`;return`result.${o} = sign(x.${o}) * log(abs(x.${o}) + 1.0);`}).join(`
    `)}
    return result;
}`}generateInverse(e){let t=`vec${e}`;return`
${t} transform_inverse(${t} y) {
    ${t} result;
    ${Array.from({length:e},(i,r)=>{let o=["x","y","z","w"][r]||`[${r}]`;return`result.${o} = sign(y.${o}) * (exp(abs(y.${o})) - 1.0);`}).join(`
    `)}
    return result;
}`}generateJacobian(e){let t=`vec${e}`;return`
${t} transform_jacobian(${t} x) {
    // Jacobian: d/dx [sign(x)*log(|x|+1)] = 1/(|x|+1)
    ${t} result;
    ${Array.from({length:e},(i,r)=>{let o=["x","y","z","w"][r]||`[${r}]`;return`result.${o} = 1.0 / (abs(x.${o}) + 1.0);`}).join(`
    `)}
    return result;
}`}getParameters(){return[]}},Yt=class extends se{constructor(){super("exp","Exponential (compress near zero)")}generateForward(e){let t=`vec${e}`;return`
${t} transform_forward(${t} x) {
    float alpha = u_transform_params.x;
    ${t} result;
    ${Array.from({length:e},(i,r)=>{let o=["x","y","z","w"][r]||`[${r}]`;return`result.${o} = sign(x.${o}) * (exp(alpha * abs(x.${o})) - 1.0);`}).join(`
    `)}
    return result;
}`}generateInverse(e){let t=`vec${e}`;return`
${t} transform_inverse(${t} y) {
    float alpha = u_transform_params.x;
    ${t} result;
    ${Array.from({length:e},(i,r)=>{let o=["x","y","z","w"][r]||`[${r}]`;return`result.${o} = sign(y.${o}) * log(abs(y.${o}) + 1.0) / alpha;`}).join(`
    `)}
    return result;
}`}generateJacobian(e){let t=`vec${e}`;return`
${t} transform_jacobian(${t} x) {
    float alpha = u_transform_params.x;
    // Jacobian: d/dx [sign(x)*(exp(\u03B1|x|)-1)] = \u03B1*exp(\u03B1|x|)
    ${t} result;
    ${Array.from({length:e},(i,r)=>{let o=["x","y","z","w"][r]||`[${r}]`;return`result.${o} = alpha * exp(alpha * abs(x.${o}));`}).join(`
    `)}
    return result;
}`}getParameters(){return[{name:"alpha",label:"Growth Rate (\u03B1)",type:"slider",min:.1,max:2,step:.1,default:.5,info:"Higher \u03B1 = stronger exponential growth. Use small values (0.1-0.5) to avoid overflow."}]}},Zt=class extends se{constructor(){super("softsign","Soft-sign (smooth compression to [-1,1])")}generateForward(e){let t=`vec${e}`;return`
${t} transform_forward(${t} x) {
    ${t} result;
    ${Array.from({length:e},(i,r)=>{let o=["x","y","z","w"][r]||`[${r}]`;return`result.${o} = x.${o} / (1.0 + abs(x.${o}));`}).join(`
    `)}
    return result;
}`}generateInverse(e){let t=`vec${e}`;return`
${t} transform_inverse(${t} y) {
    ${t} result;
    ${Array.from({length:e},(i,r)=>{let o=["x","y","z","w"][r]||`[${r}]`;return`{
        float y_clamped = clamp(y.${o}, -0.99999, 0.99999);
        result.${o} = y_clamped / (1.0 - abs(y_clamped));
    }`}).join(`
    `)}
    return result;
}`}generateJacobian(e){let t=`vec${e}`;return`
${t} transform_jacobian(${t} x) {
    // Jacobian: d/dx [x/(1+|x|)] = 1/(1+|x|)^2
    ${t} result;
    ${Array.from({length:e},(i,r)=>{let o=["x","y","z","w"][r]||`[${r}]`;return`{
        float denom = 1.0 + abs(x.${o});
        result.${o} = 1.0 / (denom * denom);
    }`}).join(`
    `)}
    return result;
}`}getParameters(){return[]}},Qt=class extends se{constructor(){super("custom","Custom (user-defined GLSL)"),this.forwardCode="",this.inverseCode="",this.jacobianCode=""}setCode(e,t,i){this.forwardCode=e,this.inverseCode=t,this.jacobianCode=i}generateForward(e){return this.forwardCode||new Pe().generateForward(e)}generateInverse(e){return this.inverseCode||new Pe().generateInverse(e)}generateJacobian(e){return this.jacobianCode||new Pe().generateJacobian(e)}},qi={identity:new Pe,power:new Ht,log:new Kt,exp:new Yt,softsign:new Zt,tanh:new jt,sigmoid:new Xt,rational:new Wt,sine:new Jt,radial_power:new qt,custom:new Qt};function ht(n){return qi[n]||qi.identity}function Ki(n,e){let t=`vec${e}`,r={white:{name:"Solid White",code:`
// Simple solid white particles
vec3 getColor(${t} pos, ${t} velocity, ${t} velocity_proj) {
    return vec3(1.0, 1.0, 1.0);
}
`},velocity_magnitude:{name:"Velocity Magnitude",usesMaxVelocity:!0,code:`
// Color based on speed (velocity magnitude)
// Uses full N-dimensional velocity magnitude
vec3 getColor(${t} pos, ${t} velocity, ${t} velocity_proj) {
    float speed = length(velocity);

    // Normalize speed to [0, 1] range using max velocity
    // Add small epsilon to avoid division by zero
    float normalized = clamp(speed / max(u_max_velocity, 0.1), 0.0, 1.0);

    // Create color gradient: blue (slow) -> cyan -> green -> yellow -> red (fast)
    vec3 color;
    if (normalized < 0.25) {
        // Blue to cyan
        color = mix(vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 1.0), normalized * 4.0);
    } else if (normalized < 0.5) {
        // Cyan to green
        color = mix(vec3(0.0, 1.0, 1.0), vec3(0.0, 1.0, 0.0), (normalized - 0.25) * 4.0);
    } else if (normalized < 0.75) {
        // Green to yellow
        color = mix(vec3(0.0, 1.0, 0.0), vec3(1.0, 1.0, 0.0), (normalized - 0.5) * 4.0);
    } else {
        // Yellow to red
        color = mix(vec3(1.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), (normalized - 0.75) * 4.0);
    }

    return color;
}
`},velocity_angle:{name:"Velocity Angle",code:`
// Color based on velocity direction in projected 2D space
vec3 getColor(${t} pos, ${t} velocity, ${t} velocity_proj) {
    // Use angle of PROJECTED velocity in x-y plane
    float angle = atan(velocity_proj.y, velocity_proj.x);

    // Convert angle [-\u03C0, \u03C0] to hue [0, 1]
    float hue = (angle + 3.14159265) / (2.0 * 3.14159265);

    // HSV to RGB conversion (saturation = 1, value = 1)
    float h = hue * 6.0;
    float x = 1.0 - abs(mod(h, 2.0) - 1.0);

    vec3 color;
    if (h < 1.0) color = vec3(1.0, x, 0.0);
    else if (h < 2.0) color = vec3(x, 1.0, 0.0);
    else if (h < 3.0) color = vec3(0.0, 1.0, x);
    else if (h < 4.0) color = vec3(0.0, x, 1.0);
    else if (h < 5.0) color = vec3(x, 0.0, 1.0);
    else color = vec3(1.0, 0.0, x);

    return color;
}
`},velocity_combined:{name:"Velocity Angle + Magnitude",usesMaxVelocity:!0,code:`
// Color by projected angle, saturation by full magnitude
vec3 getColor(${t} pos, ${t} velocity, ${t} velocity_proj) {
    float speed = length(velocity);

    // Use angle of PROJECTED velocity in x-y plane for hue
    float angle = atan(velocity_proj.y, velocity_proj.x);
    float hue = (angle + 3.14159265) / (2.0 * 3.14159265);

    // Normalize speed to [0, 1] for saturation
    float saturation = clamp(speed / max(u_max_velocity, 0.1), 0.0, 1.0);

    // HSV to RGB conversion with variable saturation (value = 1)
    float h = hue * 6.0;
    float c = saturation; // Chroma
    float x = c * (1.0 - abs(mod(h, 2.0) - 1.0));

    vec3 rgb;
    if (h < 1.0) rgb = vec3(c, x, 0.0);
    else if (h < 2.0) rgb = vec3(x, c, 0.0);
    else if (h < 3.0) rgb = vec3(0.0, c, x);
    else if (h < 4.0) rgb = vec3(0.0, x, c);
    else if (h < 5.0) rgb = vec3(x, 0.0, c);
    else rgb = vec3(c, 0.0, x);

    // Mix with neutral grey to desaturate (slow particles \u2192 grey, fast \u2192 vibrant)
    const vec3 grey = vec3(0.5, 0.5, 0.5);
    vec3 color = rgb + grey * (1.0 - saturation);

    return color;
}
`},expression:{name:"Expression",usesMaxVelocity:!1,requiresExpression:!0,code:null},custom:{name:"Custom (Advanced)",code:`
// Custom color function
// Inputs: pos (position vector), velocity (full N-D velocity), velocity_proj (projected 2D velocity)
// Output: RGB color vec3
vec3 getColor(${t} pos, ${t} velocity, ${t} velocity_proj) {
    return vec3(1.0, 1.0, 1.0);
}
`}}[n];if(!r)throw new Error(`Unknown color mode: ${n}`);return r}function Yi(n,e,t){let i=`vec${n}`,r=[],o=["x","y","z","w","u","v"],s=["dx","dy","dz","dw","du","dv"];for(let l=0;l<n;l++)r.push(`float ${o[l]} = pos.${o[l]};`),r.push(`float ${s[l]} = velocity.${o[l]};`);return`
${t}

vec3 getColor(${i} pos, ${i} velocity, ${i} velocity_proj) {
    // Unpack position and FULL velocity components for user expression
    ${r.join(`
    `)}

    // Evaluate user expression
    float value = ${e};

    // Map through gradient
    return evaluateGradient(value);
}
`}function Zi(n,e,t){let i=`vec${e}`,r;switch(n){case"velocity_magnitude":r=`
    // Use full N-dimensional velocity magnitude
    float speed = length(velocity);
    float normalized;
    if (u_velocity_log_scale > 0.5) {
        // Logarithmic scaling: log(1 + speed) / log(1 + max_velocity)
        normalized = clamp(log(1.0 + speed) / log(1.0 + max(u_max_velocity, 0.1)), 0.0, 1.0);
    } else {
        // Linear scaling
        normalized = clamp(speed / max(u_max_velocity, 0.1), 0.0, 1.0);
    }
    return evaluateGradient(normalized);`;break;case"velocity_angle":r=`
    // Use projected 2D velocity angle
    float angle = atan(velocity_proj.y, velocity_proj.x);
    float hue = (angle + 3.14159265) / (2.0 * 3.14159265);
    return evaluateGradient(hue);`;break;case"velocity_combined":r=`
    // Full velocity for magnitude, projected velocity for angle
    float speed = length(velocity);
    float angle = atan(velocity_proj.y, velocity_proj.x);
    float hue = (angle + 3.14159265) / (2.0 * 3.14159265);
    float saturation;
    if (u_velocity_log_scale > 0.5) {
        // Logarithmic scaling: log(1 + speed) / log(1 + max_velocity)
        saturation = clamp(log(1.0 + speed) / log(1.0 + max(u_max_velocity, 0.1)), 0.0, 1.0);
    } else {
        // Linear scaling
        saturation = clamp(speed / max(u_max_velocity, 0.1), 0.0, 1.0);
    }

    // Get color from gradient based on angle
    vec3 fullColor = evaluateGradient(hue);

    // Desaturate based on speed (slow \u2192 grey, fast \u2192 full color)
    const vec3 grey = vec3(0.5, 0.5, 0.5);
    return mix(grey, fullColor, saturation);`;break;default:throw new Error(`Cannot create gradient version of color mode: ${n}`)}return`
${t}

vec3 getColor(${i} pos, ${i} velocity, ${i} velocity_proj) {
    ${r}
}
`}function ei(n){let e=[...n].sort((i,r)=>i.position-r.position);if(e.length<2)throw new Error("Gradient must have at least 2 color stops");e.forEach(i=>{if(i.position<0||i.position>1)throw new Error(`Stop position must be in [0, 1], got ${i.position}`)});let t=`vec3 evaluateGradient(float t) {
    t = clamp(t, 0.0, 1.0);
`;for(let i=0;i<e.length-1;i++){let r=e[i],o=e[i+1],s=Qi(r.color),l=Qi(o.color),c=r.position.toFixed(6),d=o.position.toFixed(6);i===0?t+=`    if (t <= ${d}) {
`:i===e.length-2?t+=`    } else {
`:t+=`    } else if (t <= ${d}) {
`,t+=`        float segmentT = (t - ${c}) / (${d} - ${c});
`,t+=`        return mix(${s}, ${l}, segmentT);
`}return t+=`    }
`,t+=`}
`,t}function Qi(n){return`vec3(${n[0].toFixed(6)}, ${n[1].toFixed(6)}, ${n[2].toFixed(6)})`}function mt(){return io()}function io(){return[{position:0,color:[1,0,0]},{position:.17,color:[1,.5,0]},{position:.33,color:[1,1,0]},{position:.5,color:[0,1,0]},{position:.67,color:[0,1,1]},{position:.83,color:[0,0,1]},{position:1,color:[.5,0,1]}]}function er(n){n=n.replace("#","");let e=parseInt(n.substring(0,2),16)/255,t=parseInt(n.substring(2,4),16)/255,i=parseInt(n.substring(4,6),16)/255;return[e,t,i]}function ti(n){let e=Math.round(n[0]*255).toString(16).padStart(2,"0"),t=Math.round(n[1]*255).toString(16).padStart(2,"0"),i=Math.round(n[2]*255).toString(16).padStart(2,"0");return`#${e}${t}${i}`}function ro(n){let e={linear:{name:"Linear (No Tone Mapping)",description:"Direct exposure and gamma, no compression. Values > 1 will clip.",usesWhitePoint:!1,defaultExposure:1},reinhard:{name:"Reinhard",description:"Simple, preserves hues. Formula: color / (1 + color)",usesWhitePoint:!1,defaultExposure:1},reinhard_extended:{name:"Reinhard Extended",description:"Reinhard with adjustable white point for highlight control",usesWhitePoint:!0,defaultExposure:1,defaultWhitePoint:2},filmic:{name:"Filmic (ACES Approximation)",description:"Film-like S-curve, industry standard look",usesWhitePoint:!1,defaultExposure:1},uncharted2:{name:"Uncharted 2",description:"Popular in games, punchy highlights and saturated colors",usesWhitePoint:!0,defaultExposure:2,defaultWhitePoint:11.2},aces:{name:"ACES (Academy Color)",description:"Academy standard, natural film-like response",usesWhitePoint:!1,defaultExposure:1},hable:{name:"Hable (Uncharted 2 Filmic)",description:"John Hable's filmic curve, excellent highlight rolloff",usesWhitePoint:!0,defaultExposure:2,defaultWhitePoint:11.2},luminance_reinhard:{name:"Luminance Reinhard (Hue Preserving)",description:"Tone maps brightness only, preserves color hue/saturation perfectly. Ideal for attractors.",usesWhitePoint:!1,defaultExposure:1},luminance_extended:{name:"Luminance Extended (Hue Preserving)",description:"Extended Reinhard on luminance only. Best for colorful attractor density visualization.",usesWhitePoint:!0,defaultExposure:1,defaultWhitePoint:5}};return e[n]||e.linear}function tr(n,e={}){let t=ro(n),i=e.exposure!==void 0?e.exposure:t.defaultExposure,r=e.gamma!==void 0?e.gamma:2.2,o=e.whitePoint!==void 0?e.whitePoint:t.defaultWhitePoint||1,s=e.luminanceGamma!==void 0?e.luminanceGamma:1,l=`
// Tone mapping operator: ${t.name}
// ${t.description}

`;switch(n){case"linear":l+=`
vec3 tonemap(vec3 color) {
    // Simple exposure, no compression
    return color * ${i.toFixed(6)};
}
`;break;case"reinhard":l+=`
vec3 tonemap(vec3 color) {
    // Reinhard tone mapping: color / (1 + color)
    color *= ${i.toFixed(6)};
    return color / (vec3(1.0) + color);
}
`;break;case"reinhard_extended":l+=`
vec3 tonemap(vec3 color) {
    // Reinhard with white point
    color *= ${i.toFixed(6)};
    float whitePoint = ${o.toFixed(6)};
    vec3 numerator = color * (vec3(1.0) + (color / (whitePoint * whitePoint)));
    return numerator / (vec3(1.0) + color);
}
`;break;case"filmic":case"aces":l+=`
// ACES approximation (simplified)
vec3 tonemap(vec3 color) {
    color *= ${i.toFixed(6)};

    // ACES fitted curve
    const float a = 2.51;
    const float b = 0.03;
    const float c = 2.43;
    const float d = 0.59;
    const float e = 0.14;

    return clamp((color * (a * color + b)) / (color * (c * color + d) + e), 0.0, 1.0);
}
`;break;case"uncharted2":case"hable":l+=`
// Uncharted 2 filmic tone mapping by John Hable
vec3 uncharted2Curve(vec3 x) {
    const float A = 0.15; // Shoulder strength
    const float B = 0.50; // Linear strength
    const float C = 0.10; // Linear angle
    const float D = 0.20; // Toe strength
    const float E = 0.02; // Toe numerator
    const float F = 0.30; // Toe denominator
    return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;
}

vec3 tonemap(vec3 color) {
    color *= ${i.toFixed(6)};

    // Apply curve
    vec3 curr = uncharted2Curve(color);

    // White point scaling
    float whitePoint = ${o.toFixed(6)};
    vec3 whiteScale = vec3(1.0) / uncharted2Curve(vec3(whitePoint));

    return curr * whiteScale;
}
`;break;case"luminance_reinhard":l+=`
// Luminance-based Reinhard (hue-preserving)
// Tone maps brightness only, keeps color ratios intact
vec3 tonemap(vec3 color) {
    color *= ${i.toFixed(6)};

    // Calculate luminance (Rec. 709)
    float luma = dot(color, vec3(0.2126, 0.7152, 0.0722));

    // Avoid division by zero
    if (luma < 0.0001) return vec3(0.0);

    // Apply Reinhard to luminance only
    float toneMappedLuma = luma / (1.0 + luma);

    // Scale color to match tone-mapped luminance
    // This preserves hue and saturation perfectly
    return color * (toneMappedLuma / luma);
}
`;break;case"luminance_extended":l+=`
// Luminance-based Extended Reinhard (hue-preserving)
// Best for attractor visualization with dense bright regions
vec3 tonemap(vec3 color) {
    color *= ${i.toFixed(6)};

    // Calculate luminance (Rec. 709)
    float luma = dot(color, vec3(0.2126, 0.7152, 0.0722));

    // Avoid division by zero
    if (luma < 0.0001) return vec3(0.0);

    // Extended Reinhard with white point on luminance only
    float whitePoint = ${o.toFixed(6)};
    float numerator = luma * (1.0 + (luma / (whitePoint * whitePoint)));
    float toneMappedLuma = numerator / (1.0 + luma);

    // Scale color to match tone-mapped luminance
    // This preserves hue and saturation perfectly
    return color * (toneMappedLuma / luma);
}
`;break;default:l+=`
vec3 tonemap(vec3 color) {
    return color * ${i.toFixed(6)};
}
`}return l+=`
vec3 applyGamma(vec3 color) {
    return pow(color, vec3(1.0 / ${r.toFixed(6)}));
}

vec3 applyLuminanceGamma(vec3 color) {
    // Luminance-preserving gamma: adjusts brightness only, preserves hue
    float luma = dot(color, vec3(0.2126, 0.7152, 0.0722));

    // Avoid division by zero
    if (luma < 0.0001) return vec3(0.0);

    // Apply gamma to luminance only
    float gammaCorrectedLuma = pow(luma, 1.0 / ${s.toFixed(6)});

    // Scale color to match gamma-corrected luminance
    // This preserves hue and saturation perfectly
    return color * (gammaCorrectedLuma / luma);
}
`,l}Le();X();var De=class{constructor(e){this.gl=e}getTextureFormat(){throw new Error("getTextureFormat() must be implemented by subclass")}getArrayType(){throw new Error("getArrayType() must be implemented by subclass")}getComponentsPerValue(){throw new Error("getComponentsPerValue() must be implemented by subclass")}requiresExtension(){return!1}getExtensionName(){return null}encodeValue(e,t,i){throw new Error("encodeValue() must be implemented by subclass")}decodeValue(e,t,i){throw new Error("decodeValue() must be implemented by subclass")}normalizeWorld(e,t,i){throw new Error("normalizeWorld() must be implemented by subclass")}denormalizeWorld(e,t,i){throw new Error("denormalizeWorld() must be implemented by subclass")}getGLSLConstants(){throw new Error("getGLSLConstants() must be implemented by subclass")}getGLSLDecodeFunction(){throw new Error("getGLSLDecodeFunction() must be implemented by subclass")}getGLSLEncodeFunction(){throw new Error("getGLSLEncodeFunction() must be implemented by subclass")}getGLSLNormalizeFunction(){throw new Error("getGLSLNormalizeFunction() must be implemented by subclass")}getGLSLDenormalizeFunction(){throw new Error("getGLSLDenormalizeFunction() must be implemented by subclass")}getName(){throw new Error("getName() must be implemented by subclass")}};ni();var Xe=class extends De{constructor(e){super(e)}getName(){return"RGBA Fixed-Point Encoding"}getTextureFormat(){let e=this.gl;return{internalFormat:e.RGBA,format:e.RGBA,type:e.UNSIGNED_BYTE}}getArrayType(){return Uint8Array}getComponentsPerValue(){return 4}requiresExtension(){return!1}getExtensionName(){return null}encodeValue(e,t,i){let r=(e-t)/(i-t),o=new Uint8Array(4);return ri(r,o,0),o}decodeValue(e,t,i){let r=oi(e[0],e[1],e[2],e[3]);return t+r*(i-t)}normalizeWorld(e,t,i){return(e-t)/(i-t)}denormalizeWorld(e,t,i){return t+e*(i-t)}getGLSLConstants(){return`
// Map to [0, 1] range for maximum precision at any zoom level
const float FIXED_POINT_SCALE = 4294967295.0; // 2^32 - 1
`}getGLSLDecodeFunction(){return`
// Decode RGBA bytes back to float in [0, 1] range
float decodeFloat(vec4 rgba) {
    // Reconstruct 32-bit integer from bytes (big-endian)
    vec4 bytes = rgba * 255.0;
    float intValue = bytes.r * 16777216.0 + bytes.g * 65536.0 + bytes.b * 256.0 + bytes.a;

    // Map from [0, 2^32-1] back to [0, 1]
    return intValue / FIXED_POINT_SCALE;
}
`}getGLSLEncodeFunction(){return`
// Encode float in [0, 1] range to RGBA bytes
vec4 encodeFloat(float v) {
    // Clamp to [0, 1]
    v = clamp(v, 0.0, 1.0);

    // Map to [0, 2^32-1]
    float normalized = v * FIXED_POINT_SCALE;

    // Split into 4 bytes (big-endian)
    float byte0 = floor(normalized / 16777216.0);  // 2^24
    normalized -= byte0 * 16777216.0;
    float byte1 = floor(normalized / 65536.0);      // 2^16
    normalized -= byte1 * 65536.0;
    float byte2 = floor(normalized / 256.0);        // 2^8
    normalized -= byte2 * 256.0;
    float byte3 = floor(normalized);

    return vec4(byte0, byte1, byte2, byte3) / 255.0;
}
`}getGLSLNormalizeFunction(){return`
// Helper to normalize world coordinate to [0, 1] relative to viewport
float normalizeToViewport(float worldValue, float minVal, float maxVal) {
    return (worldValue - minVal) / (maxVal - minVal);
}
`}getGLSLDenormalizeFunction(){return`
// Helper to denormalize from [0, 1] back to world coordinates
float denormalizeFromViewport(float normalized, float minVal, float maxVal) {
    return minVal + normalized * (maxVal - minVal);
}
`}};X();var ft=class extends De{constructor(e){if(super(e),!e.getExtension("OES_texture_float"))throw new Error("OES_texture_float extension not supported");a.info("Float texture support detected",{extension:"OES_texture_float"})}getName(){return"Float Textures (Direct Storage)"}getTextureFormat(){let e=this.gl;return{internalFormat:e.RGBA,format:e.RGBA,type:e.FLOAT}}getArrayType(){return Float32Array}getComponentsPerValue(){return 4}requiresExtension(){return!0}getExtensionName(){return"OES_texture_float"}encodeValue(e,t,i){let r=new Float32Array(4);return r[0]=e,r[1]=0,r[2]=0,r[3]=1,r}decodeValue(e,t,i){return e[0]}normalizeWorld(e,t,i){return e}denormalizeWorld(e,t,i){return e}getGLSLConstants(){return`
// Float strategy: no constants needed
`}getGLSLDecodeFunction(){return`
// Decode float from RGBA - just read the red channel directly
float decodeFloat(vec4 rgba) {
    return rgba.r;
}
`}getGLSLEncodeFunction(){return`
// Encode float to RGBA - store in red channel
vec4 encodeFloat(float v) {
    return vec4(v, 0.0, 0.0, 1.0);
}
`}getGLSLNormalizeFunction(){return`
// Float strategy: no normalization needed, pass through directly
float normalizeToViewport(float worldValue, float minVal, float maxVal) {
    return worldValue;
}
`}getGLSLDenormalizeFunction(){return`
// Float strategy: no denormalization needed, pass through directly
float denormalizeFromViewport(float normalized, float minVal, float maxVal) {
    return normalized;
}
`}};var pt=class{constructor(e,t={}){if(this.canvas=e,this.gl=e.getContext("webgl",{alpha:!1,depth:!1,stencil:!1,antialias:!1,preserveDrawingBuffer:!0}),!this.gl)throw new Error("WebGL not supported");let i=this.gl;i.disable(i.DEPTH_TEST),i.disable(i.STENCIL_TEST),i.enable(i.BLEND);let r=t.storageStrategy||"rgba";try{r==="float"?(this.strategy=new ft(i),a.info("Using Float texture strategy")):(this.strategy=new Xe(i),a.info("Using RGBA encoded texture strategy"))}catch(x){a.warn(`Failed to initialize ${r} strategy: ${x.message}`),a.info("Falling back to RGBA strategy"),this.strategy=new Xe(i)}this.dimensions=2,this.expressions=["-y","x"],this.coordinateSystem=ue(this.dimensions);try{let x=this.coordinateSystem.getVariableNames();this.velocityEvaluators=Nt(this.expressions,x),a.verbose("Initial velocity evaluators created",{coordinateSystem:this.coordinateSystem.name,variables:x})}catch(x){a.warn("Failed to create initial velocity evaluators",x),this.velocityEvaluators=null}this.integratorType="rk4",this.integratorParams={iterations:3},this.integratorCostFactor=1,this.solutionMethod="fixed-point",this.transformType="identity",this.transformParams={},this.mapperType="select",this.mapperParams={dim1:0,dim2:1},this.colorMode="white",this.colorExpression="x * y",this.colorGradient=mt(),this.useCustomGradient=!1,this.velocityScaleMode="percentile95",this.velocityLogScale=!1,this.useHDR=t.useHDR!==void 0?t.useHDR:!0,this.tonemapOperator=t.tonemapOperator||"aces",this.exposure=t.exposure!==void 0?t.exposure:1,this.gamma=t.gamma!==void 0?t.gamma:2.2,this.luminanceGamma=t.luminanceGamma!==void 0?t.luminanceGamma:1,this.highlightCompression=t.highlightCompression!==void 0?t.highlightCompression:0,this.compressionThreshold=t.compressionThreshold!==void 0?t.compressionThreshold:1,this.whitePoint=t.whitePoint!==void 0?t.whitePoint:2,this.particleIntensity=t.particleIntensity!==void 0?t.particleIntensity:1,this.particleSize=t.particleSize!==void 0?t.particleSize:1,this.particleRenderMode=t.particleRenderMode||"points",this.useDepthTest=t.useDepthTest!==void 0?t.useDepthTest:!1,this.colorSaturation=t.colorSaturation!==void 0?t.colorSaturation:1,this.brightnessDesaturation=t.brightnessDesaturation!==void 0?t.brightnessDesaturation:0,this.brightnessSaturation=t.brightnessSaturation!==void 0?t.brightnessSaturation:0,this.bloomEnabled=t.bloomEnabled!==void 0?t.bloomEnabled:!1,this.bloomIntensity=t.bloomIntensity!==void 0?t.bloomIntensity:.3,this.bloomRadius=t.bloomRadius!==void 0?t.bloomRadius:1,this.bloomAlpha=t.bloomAlpha!==void 0?t.bloomAlpha:1,this.currentBloomTexture=null,this.smaaEnabled=t.smaaEnabled!==void 0?t.smaaEnabled:!0,this.smaaIntensity=t.smaaIntensity!==void 0?t.smaaIntensity:.75,this.smaaThreshold=t.smaaThreshold!==void 0?t.smaaThreshold:.1,this.bilateralEnabled=t.bilateralEnabled!==void 0?t.bilateralEnabled:!1,this.bilateralSpatialSigma=t.bilateralSpatialSigma!==void 0?t.bilateralSpatialSigma:4,this.bilateralIntensitySigma=t.bilateralIntensitySigma!==void 0?t.bilateralIntensitySigma:.2;let o=t.supersampleFactor!==void 0?t.supersampleFactor:1;(typeof o!="number"||isNaN(o)||o<=0)&&(a.warn(`Invalid supersampleFactor: ${o}, using default 1.0`),o=1),this.supersampleFactor=Math.max(.5,Math.min(4,o)),a.info(`Initial render scale factor set to: ${this.supersampleFactor}`),this.timestep=.01,this.fadeOpacity=.99,this.dropProbability=.003,this.dropLowVelocity=!1,this.animationAlpha=0,this.lockShaderRecompilation=!1,this.enableDebugStats=!1,this.maxVelocity=5,this.prevMaxVelocity=5,this.velocityEMAAlpha=.1,this.velocitySampleInterval=10,this.velocitySampleIntervalMin=5,this.velocitySampleIntervalMax=60,this.framesSinceLastSample=0,this.lowVelocityThreshold=.02;let c=10*(e.width/e.height);this.bbox={min:[-c/2,-5],max:[c/2,5]},this.particleSystem=new ct(1e4,this.dimensions,this.bbox,this.strategy),this.textureManager=new Ve(i,this.dimensions,this.particleSystem.getResolution(),this.strategy),this.particleRenderMode==="lines"&&this.textureManager.setLineMode(!0),this.updateFramebuffer=i.createFramebuffer();let d=Math.max(1,e.width||800),u=Math.max(1,e.height||600);this.renderWidth=Math.max(1,Math.floor(d*this.supersampleFactor)),this.renderHeight=Math.max(1,Math.floor(u*this.supersampleFactor)),a.verbose("Render dimensions calculated",{canvasSize:`${d}x${u}`,renderSize:`${this.renderWidth}x${this.renderHeight}`,supersampleFactor:this.supersampleFactor}),a.info("Initializing HDR rendering system...",{requested:this.useHDR,canvasSize:`${e.width}x${e.height}`,renderSize:`${this.renderWidth}x${this.renderHeight}`,supersampleFactor:this.supersampleFactor}),this.framebufferManager=new Ne(i,this.renderWidth,this.renderHeight,{useHDR:this.useHDR,usePingPong:!0});let h=this.framebufferManager.getHDRSupport();a.info("HDR rendering system initialized",{hdrEnabled:h.enabled,hdrSupported:h.supported,textureFormat:h.format,extensions:{floatColorBuffer:h.hasFloatColorBuffer,halfFloatColorBuffer:h.hasHalfFloatColorBuffer,linearFiltering:h.hasLinearFiltering},exposure:this.exposure,gamma:this.gamma}),this.useHDR&&!h.supported&&a.warn("HDR rendering requested but not supported by device. Using LDR fallback."),h.enabled&&!h.hasLinearFiltering&&a.warn("Linear filtering not available for HDR textures. Bloom quality will be affected."),a.info("Initializing bloom system...",{enabled:this.bloomEnabled,intensity:this.bloomIntensity,threshold:this.whitePoint}),this.bloomManager=new tt(i,this.renderWidth,this.renderHeight,{enabled:this.bloomEnabled&&h.enabled,intensity:this.bloomIntensity,threshold:this.whitePoint,radius:this.bloomRadius}),a.info("Bloom system initialized",{enabled:this.bloomManager.isEnabled(),bloomSize:this.bloomManager.isEnabled()?`${this.bloomManager.getBloomSize().width}x${this.bloomManager.getBloomSize().height}`:"N/A"}),this.smaaManager=new st(i,this.renderWidth,this.renderHeight,{enabled:this.smaaEnabled,intensity:this.smaaIntensity,threshold:this.smaaThreshold}),a.info("SMAA system initialized",{enabled:this.smaaManager.isEnabled(),intensity:this.smaaIntensity,threshold:this.smaaThreshold}),this.bilateralManager=new nt(i,this.renderWidth,this.renderHeight,{enabled:this.bilateralEnabled,spatialSigma:this.bilateralSpatialSigma,intensitySigma:this.bilateralIntensitySigma}),a.info("Bilateral filter initialized",{enabled:this.bilateralManager.isEnabled(),spatialSigma:this.bilateralSpatialSigma,intensitySigma:this.bilateralIntensitySigma}),this.ldrFramebuffer=i.createFramebuffer(),this.ldrTexture=i.createTexture(),i.bindTexture(i.TEXTURE_2D,this.ldrTexture),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.LINEAR),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.LINEAR),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_S,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_T,i.CLAMP_TO_EDGE),i.texImage2D(i.TEXTURE_2D,0,i.RGBA,this.renderWidth,this.renderHeight,0,i.RGBA,i.UNSIGNED_BYTE,null),i.bindFramebuffer(i.FRAMEBUFFER,this.ldrFramebuffer),i.framebufferTexture2D(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,this.ldrTexture,0);let g=i.checkFramebufferStatus(i.FRAMEBUFFER);g!==i.FRAMEBUFFER_COMPLETE&&a.error("LDR framebuffer incomplete",{status:g}),i.bindFramebuffer(i.FRAMEBUFFER,null),a.info("LDR framebuffer created for tone mapping output"),this.finalFramebuffer=i.createFramebuffer(),this.finalTexture=i.createTexture(),i.bindTexture(i.TEXTURE_2D,this.finalTexture),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.LINEAR),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.LINEAR),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_S,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_T,i.CLAMP_TO_EDGE),i.texImage2D(i.TEXTURE_2D,0,i.RGBA,this.renderWidth,this.renderHeight,0,i.RGBA,i.UNSIGNED_BYTE,null),i.bindFramebuffer(i.FRAMEBUFFER,this.finalFramebuffer),i.framebufferTexture2D(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,this.finalTexture,0);let f=i.checkFramebufferStatus(i.FRAMEBUFFER);f!==i.FRAMEBUFFER_COMPLETE&&a.error("Final framebuffer incomplete",{status:f}),i.bindFramebuffer(i.FRAMEBUFFER,null),a.info("Final framebuffer created for supersampling output"),this.bufferStatsManager=new at(i),this.velocityStatsManager=new lt(i),this.statsUpdateInterval=60,this.statsUpdateIntervalSlow=120,this.statsCoarseMode=!0,this.quadBuffer=this.createBuffer(new Float32Array([0,0,1,0,0,1,0,1,1,0,1,1])),this.smaaManager.setQuadBuffer(this.quadBuffer),this.bilateralManager.setQuadBuffer(this.quadBuffer),a.info("Compiling shaders...",{dimensions:this.dimensions,integrator:this.integratorType});let p=this.compileShaders();if(p)throw a.error("Shader compilation failed",p),new Error(`Shader compilation failed: ${p}`);a.info("Shaders compiled successfully"),a.info("Initializing particle textures...",{resolution:this.particleSystem.getResolution(),particleCount:this.particleSystem.getActualParticleCount()}),this.textureManager.initializeData(this.particleSystem.getAllData()),this.indexBufferPoints=this.createBuffer(this.particleSystem.getIndices()),this.indexBufferLines=this.createLineIndexBuffer(this.particleSystem.getActualParticleCount()),this.vertexIdBufferLines=this.createLineVertexIdBuffer(this.particleSystem.getActualParticleCount()),this.isRunning=!1,this.frame=0,this.hdrLogged=!1}createBuffer(e){let t=this.gl,i=t.createBuffer();return t.bindBuffer(t.ARRAY_BUFFER,i),t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW),i}createLineIndexBuffer(e){let t=this.gl,i=new Float32Array(e*2);for(let o=0;o<e;o++)i[o*2]=o,i[o*2+1]=o;let r=t.createBuffer();return t.bindBuffer(t.ARRAY_BUFFER,r),t.bufferData(t.ARRAY_BUFFER,i,t.STATIC_DRAW),r}createLineVertexIdBuffer(e){let t=this.gl,i=new Float32Array(e*2);for(let o=0;o<e*2;o++)i[o]=o%2;let r=t.createBuffer();return t.bindBuffer(t.ARRAY_BUFFER,r),t.bufferData(t.ARRAY_BUFFER,i,t.STATIC_DRAW),r}compileShaders(){let e=this.gl;try{let t=this.coordinateSystem.getVariableNames(),i=this.coordinateSystem.name.includes("Cartesian"),r=i?"pos":"pos_native",o=Ci(this.expressions,t,r);a.verbose("Generated velocity GLSL",{expressions:this.expressions,coordinateSystem:this.coordinateSystem.name,variables:t,posVarName:r,glsl:o});let s=null;if(!i){let R=["x","y","z","w","u","v"].slice(0,this.dimensions),I=this.coordinateSystem.getVariableNames();s={name:this.coordinateSystem.name,nativeVars:I,forwardTransform:this.coordinateSystem.generateForwardTransformGLSL(R,(B,z)=>de(B,z.length,z)),inverseTransform:this.coordinateSystem.generateInverseTransformGLSL(I,(B,z)=>de(B,z.length,z))},a.verbose("Generated coordinate system code",{name:s.name,forward:s.forwardTransform,inverse:s.inverseTransform})}let l={...this.integratorParams,expressions:this.expressions,solutionMethod:this.solutionMethod},c=Wi(this.integratorType,this.dimensions,l);this.integratorCostFactor=c.costFactor||1;let d=Ji(this.mapperType,this.dimensions,this.mapperParams),u=null;if(this.transformType!=="identity"){let R=ht(this.transformType);u={helpers:R.generateHelpers(this.dimensions),forward:R.generateForward(this.dimensions),inverse:R.generateInverse(this.dimensions),jacobian:R.generateJacobian(this.dimensions)}}let h=Ki(this.colorMode,this.dimensions),g=h.code,f=h.usesMaxVelocity||!1;if(this.colorMode==="expression"){let R=de(this.colorExpression,this.dimensions),I=ei(this.colorGradient);g=Yi(this.dimensions,R,I)}else if(this.useCustomGradient&&(this.colorMode==="velocity_magnitude"||this.colorMode==="velocity_angle"||this.colorMode==="velocity_combined")){let R=ei(this.colorGradient);g=Zi(this.colorMode,this.dimensions,R),f=this.colorMode==="velocity_magnitude"||this.colorMode==="velocity_combined"}let p=Di(),x=Bi(this.dimensions,o,c.code,this.strategy,u,s);this.updateProgram=J(e,p,x);let y=this.particleRenderMode==="lines",b=Ii(this.dimensions,d.code,o,this.strategy,y,s),v=Ui(this.dimensions,g,f);this.drawProgram=J(e,b,v),this.usesMaxVelocity=f,this.shaderSource={updateVertex:p,updateFragment:x,drawVertex:b,drawFragment:v,velocityField:o},this.dumpShadersOnCompile&&(console.log(`
========== SHADER DUMP ==========`),console.log(`Config: ${this.dimensions}D, ${this.integratorType}, ${this.mapperType}, ${this.colorMode}`),console.log(`
--- UPDATE VERTEX SHADER ---`),console.log(p),console.log(`
--- UPDATE FRAGMENT SHADER ---`),console.log(x),console.log(`
--- DRAW VERTEX SHADER ---`),console.log(b),console.log(`
--- DRAW FRAGMENT SHADER ---`),console.log(v),console.log(`
=================================
`),this.dumpShadersOnCompile=!1),this.velocityStatsManager&&(this.velocityStatsManager.dispose(),this.velocityStatsManager.initialize(this.dimensions,o,s)?a.verbose("Velocity stats manager initialized"):a.warn("Failed to initialize velocity stats manager"));let w=zi(),S=Vi(),M=tr(this.tonemapOperator,{exposure:this.exposure,gamma:this.gamma,luminanceGamma:this.luminanceGamma,whitePoint:this.whitePoint}),E=Ni(M);if(this.screenFadeProgram=J(e,w,S),this.tonemapProgram=J(e,w,E),this.bloomManager.isEnabled()){let R=ki(),I=kt(!0,this.bloomRadius),B=kt(!1,this.bloomRadius),z=Oi();this.bloomBrightPassProgram=J(e,w,R),this.bloomBlurHProgram=J(e,w,I),this.bloomBlurVProgram=J(e,w,B),this.bloomCombineProgram=J(e,w,z),a.verbose("Bloom shaders compiled",{threshold:this.whitePoint,intensity:this.bloomIntensity,radius:this.bloomRadius})}return this.shaderSource.screenFade=S,this.shaderSource.tonemap=E,a.verbose("Tone mapping operator compiled",{operator:this.tonemapOperator,exposure:this.exposure,gamma:this.gamma,whitePoint:this.whitePoint}),this.shadersJustRecompiled=!0,null}catch(t){return t.message}}updatePositions(){let e=this.gl,t=this.updateProgram;this.enableDebugStats&&this.frame%60===0&&this.sampleParticleData(),this.frame%600===0&&a.verbose(`Frame ${this.frame}: Shader uniforms`,{u_min:[this.bbox.min[0],this.bbox.min[1]],u_max:[this.bbox.max[0],this.bbox.max[1]],u_h:this.timestep*(this.integratorCostFactor||1),timestep_base:this.timestep,costFactor:this.integratorCostFactor||1,u_drop_rate:this.dropProbability}),e.useProgram(t);let i=e.getAttribLocation(t,"a_pos");e.bindBuffer(e.ARRAY_BUFFER,this.quadBuffer),e.enableVertexAttribArray(i),e.vertexAttribPointer(i,2,e.FLOAT,!1,0,0),this.textureManager.bindReadTextures(t);let r=this.particleSystem.getResolution(),o=Math.random();e.uniform2f(e.getUniformLocation(t,"u_min"),this.bbox.min[0],this.bbox.min[1]),e.uniform2f(e.getUniformLocation(t,"u_max"),this.bbox.max[0],this.bbox.max[1]),e.uniform1f(e.getUniformLocation(t,"u_h"),this.timestep*(this.integratorCostFactor||1)),e.uniform1f(e.getUniformLocation(t,"u_rand_seed"),o),e.uniform1f(e.getUniformLocation(t,"u_drop_rate"),this.dropProbability),e.uniform1f(e.getUniformLocation(t,"u_particles_res"),r);let s=this.getVelocityScale();e.uniform1f(e.getUniformLocation(t,"u_max_velocity"),s),e.uniform1f(e.getUniformLocation(t,"u_drop_low_velocity"),this.dropLowVelocity?1:0),e.uniform1f(e.getUniformLocation(t,"u_velocity_threshold"),this.lowVelocityThreshold);let l=e.getUniformLocation(t,"u_alpha");if(l!==null&&e.uniform1f(l,this.animationAlpha),this.transformType!=="identity"){let c=this.transformParams||{},d=[c.alpha||c.beta||c.k||c.amplitude||.5,c.frequency||0,0,0];e.uniform4f(e.getUniformLocation(t,"u_transform_params"),d[0],d[1],d[2],d[3])}for(let c=0;c<this.dimensions;c++){e.uniform1i(e.getUniformLocation(t,"u_out_coordinate"),c);let d=this.textureManager.getWriteTexture(c);e.bindFramebuffer(e.FRAMEBUFFER,this.updateFramebuffer),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,d,0),e.viewport(0,0,r,r),e.drawArrays(e.TRIANGLES,0,6)}this.textureManager.swap(),this.frame++}drawParticles(){let e=this.gl,t=this.drawProgram;if(e.useProgram(t),e.blendFunc(e.SRC_ALPHA,e.ONE),this.framesSinceLastSample++,this.framesSinceLastSample>=this.velocitySampleInterval){if(this.framesSinceLastSample=0,this.velocityStatsManager&&this.velocityStatsManager.initialized){let d=this.textureManager.getReadTextures(),u=this.velocityStatsManager.compute(d,this.bbox,this.particleSystem.getResolution(),this.animationAlpha);if(this.frame%600===0&&u.sampleCount>0&&a.debug(`GPU velocity stats: avg=${u.avgVelocity.toFixed(3)}, max=${u.maxVelocity.toFixed(3)} (${u.sampleCount} samples)`),u.maxVelocity>0){let h=u.maxVelocity>this.maxVelocity?this.velocityEMAAlpha*2:this.velocityEMAAlpha;this.prevMaxVelocity=this.maxVelocity,this.maxVelocity=h*u.maxVelocity+(1-h)*this.maxVelocity}}else this.velocityStatsWarningLogged||(a.warn("Velocity stats manager not initialized - max velocity will not be computed"),this.velocityStatsWarningLogged=!0);let s=Math.abs(this.maxVelocity-this.prevMaxVelocity)/Math.max(this.maxVelocity,.1),l=.05,c=.01;if(s>l)this.velocitySampleInterval=this.velocitySampleIntervalMin;else if(s<c)this.velocitySampleInterval=this.velocitySampleIntervalMax;else{let d=(s-c)/(l-c);this.velocitySampleInterval=Math.round(this.velocitySampleIntervalMax*(1-d)+this.velocitySampleIntervalMin*d)}}this.maxVelocity=Math.max(this.maxVelocity,.5);let i=e.getAttribLocation(t,"a_index"),r=this.particleRenderMode==="lines"?this.indexBufferLines:this.indexBufferPoints;if(e.bindBuffer(e.ARRAY_BUFFER,r),e.enableVertexAttribArray(i),e.vertexAttribPointer(i,1,e.FLOAT,!1,0,0),this.particleRenderMode==="lines"){let s=e.getAttribLocation(t,"a_vertex_id");s!==-1&&(e.bindBuffer(e.ARRAY_BUFFER,this.vertexIdBufferLines),e.enableVertexAttribArray(s),e.vertexAttribPointer(s,1,e.FLOAT,!1,0,0))}this.textureManager.bindReadTextures(t),this.textureManager.bindPrevTextures(t),e.uniform1f(e.getUniformLocation(t,"u_particles_res"),this.particleSystem.getResolution()),e.uniform2f(e.getUniformLocation(t,"u_min"),this.bbox.min[0],this.bbox.min[1]),e.uniform2f(e.getUniformLocation(t,"u_max"),this.bbox.max[0],this.bbox.max[1]),e.uniform1f(e.getUniformLocation(t,"u_particle_intensity"),this.particleIntensity),e.uniform1f(e.getUniformLocation(t,"u_particle_size"),this.particleSize),e.uniform2f(e.getUniformLocation(t,"u_viewport_size"),this.renderWidth,this.renderHeight),e.uniform2f(e.getUniformLocation(t,"u_canvas_size"),this.canvas.width,this.canvas.height),e.uniform1f(e.getUniformLocation(t,"u_color_saturation"),this.colorSaturation);let o=e.getUniformLocation(t,"u_alpha");if(o!==null&&e.uniform1f(o,this.animationAlpha),this.usesMaxVelocity){let s=this.getVelocityScale();e.uniform1f(e.getUniformLocation(t,"u_max_velocity"),s),e.uniform1f(e.getUniformLocation(t,"u_velocity_log_scale"),this.velocityLogScale?1:0)}this.particleRenderMode==="lines"?e.drawArrays(e.LINES,0,this.particleSystem.getActualParticleCount()*2):e.drawArrays(e.POINTS,0,this.particleSystem.getActualParticleCount())}getVelocityScale(){if(!this.velocityStatsManager||!this.velocityStatsManager.initialized)return this.maxVelocity;let e=this.velocityStatsManager.getCached();switch(this.velocityScaleMode){case"max":return e.maxVelocity||this.maxVelocity;case"average":return e.avgVelocity||this.maxVelocity;case"percentile90":return e.percentile90||e.avgVelocity||this.maxVelocity;case"percentile95":return e.percentile95||e.avgVelocity||this.maxVelocity;default:return this.maxVelocity}}fadeScreen(){let e=this.gl,t=this.framebufferManager.getCurrentTexture();this.framebufferManager.swap(),this.framebufferManager.bind(),e.viewport(0,0,this.renderWidth,this.renderHeight),e.disable(e.BLEND),e.useProgram(this.screenFadeProgram);let i=e.getAttribLocation(this.screenFadeProgram,"a_pos");e.bindBuffer(e.ARRAY_BUFFER,this.quadBuffer),e.enableVertexAttribArray(i),e.vertexAttribPointer(i,2,e.FLOAT,!1,0,0),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,t),e.uniform1i(e.getUniformLocation(this.screenFadeProgram,"u_screen"),0),e.uniform1f(e.getUniformLocation(this.screenFadeProgram,"u_fade"),this.fadeOpacity),e.drawArrays(e.TRIANGLES,0,6),e.enable(e.BLEND)}applyBloom(){if(!this.bloomManager.isEnabled())return;let e=this.gl,t=this.bloomManager.getBloomSize();e.bindFramebuffer(e.FRAMEBUFFER,this.bloomManager.getBrightFBO()),e.viewport(0,0,t.width,t.height),e.disable(e.BLEND),e.useProgram(this.bloomBrightPassProgram);let i=e.getAttribLocation(this.bloomBrightPassProgram,"a_pos");e.bindBuffer(e.ARRAY_BUFFER,this.quadBuffer),e.enableVertexAttribArray(i),e.vertexAttribPointer(i,2,e.FLOAT,!1,0,0),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,this.framebufferManager.getCurrentTexture()),e.uniform1i(e.getUniformLocation(this.bloomBrightPassProgram,"u_screen"),0),e.uniform1f(e.getUniformLocation(this.bloomBrightPassProgram,"u_threshold"),this.whitePoint),e.drawArrays(e.TRIANGLES,0,6);let r=this.bloomManager.getBlurFBOs(),o=this.bloomManager.getBlurTextures();e.bindFramebuffer(e.FRAMEBUFFER,r[0]),e.useProgram(this.bloomBlurHProgram);let s=e.getAttribLocation(this.bloomBlurHProgram,"a_pos");e.bindBuffer(e.ARRAY_BUFFER,this.quadBuffer),e.enableVertexAttribArray(s),e.vertexAttribPointer(s,2,e.FLOAT,!1,0,0),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,this.bloomManager.getBrightTexture()),e.uniform1i(e.getUniformLocation(this.bloomBlurHProgram,"u_texture"),0),e.uniform2f(e.getUniformLocation(this.bloomBlurHProgram,"u_texel_size"),1/t.width,1/t.height),e.uniform1f(e.getUniformLocation(this.bloomBlurHProgram,"u_radius"),this.bloomRadius),e.drawArrays(e.TRIANGLES,0,6),e.bindFramebuffer(e.FRAMEBUFFER,r[1]),e.useProgram(this.bloomBlurVProgram);let l=e.getAttribLocation(this.bloomBlurVProgram,"a_pos");e.bindBuffer(e.ARRAY_BUFFER,this.quadBuffer),e.enableVertexAttribArray(l),e.vertexAttribPointer(l,2,e.FLOAT,!1,0,0),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,o[0]),e.uniform1i(e.getUniformLocation(this.bloomBlurVProgram,"u_texture"),0),e.uniform2f(e.getUniformLocation(this.bloomBlurVProgram,"u_texel_size"),1/t.width,1/t.height),e.uniform1f(e.getUniformLocation(this.bloomBlurVProgram,"u_radius"),this.bloomRadius),e.drawArrays(e.TRIANGLES,0,6),this.currentBloomTexture=o[1]}downsampleToCanvas(){let e=this.gl;e.bindFramebuffer(e.FRAMEBUFFER,null),e.viewport(0,0,this.canvas.width,this.canvas.height),e.useProgram(this.screenFadeProgram);let t=e.getAttribLocation(this.screenFadeProgram,"a_pos");e.bindBuffer(e.ARRAY_BUFFER,this.quadBuffer),e.enableVertexAttribArray(t),e.vertexAttribPointer(t,2,e.FLOAT,!1,0,0),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,this.finalTexture),e.uniform1i(e.getUniformLocation(this.screenFadeProgram,"u_screen"),0),e.uniform1f(e.getUniformLocation(this.screenFadeProgram,"u_fade"),1),e.drawArrays(e.TRIANGLES,0,6)}render(e=!0){let t=this.gl;if(!this.hdrLogged){let l=this.framebufferManager.getHDRSupport();a.info("First frame render",{renderingMode:l.enabled?"HDR":"LDR",textureFormat:l.format,exposure:this.exposure,gamma:this.gamma}),this.hdrLogged=!0}this.updatePositions(),this.fadeScreen(),this.framebufferManager.bind(),this.useDepthTest&&(t.enable(t.DEPTH_TEST),t.depthFunc(t.LESS),t.clear(t.DEPTH_BUFFER_BIT)),this.drawParticles(),this.useDepthTest&&t.disable(t.DEPTH_TEST),this.applyBloom(),t.bindFramebuffer(t.FRAMEBUFFER,this.ldrFramebuffer),t.viewport(0,0,this.renderWidth,this.renderHeight),t.disable(t.BLEND),t.useProgram(this.tonemapProgram);let i=t.getAttribLocation(this.tonemapProgram,"a_pos");t.bindBuffer(t.ARRAY_BUFFER,this.quadBuffer),t.enableVertexAttribArray(i),t.vertexAttribPointer(i,2,t.FLOAT,!1,0,0),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,this.framebufferManager.getCurrentTexture()),t.uniform1i(t.getUniformLocation(this.tonemapProgram,"u_screen"),0),this.bloomManager.isEnabled()&&this.currentBloomTexture?(t.activeTexture(t.TEXTURE1),t.bindTexture(t.TEXTURE_2D,this.currentBloomTexture),t.uniform1i(t.getUniformLocation(this.tonemapProgram,"u_bloom"),1),t.uniform1i(t.getUniformLocation(this.tonemapProgram,"u_bloom_enabled"),1),t.uniform1f(t.getUniformLocation(this.tonemapProgram,"u_bloom_intensity"),this.bloomIntensity),t.uniform1f(t.getUniformLocation(this.tonemapProgram,"u_bloom_alpha"),this.bloomAlpha)):t.uniform1i(t.getUniformLocation(this.tonemapProgram,"u_bloom_enabled"),0);let r=this.bufferStatsManager.getCached();t.uniform1f(t.getUniformLocation(this.tonemapProgram,"u_exposure"),this.exposure),t.uniform1f(t.getUniformLocation(this.tonemapProgram,"u_gamma"),this.gamma),t.uniform1f(t.getUniformLocation(this.tonemapProgram,"u_whitePoint"),this.whitePoint),t.uniform1f(t.getUniformLocation(this.tonemapProgram,"u_highlight_compression"),this.highlightCompression),t.uniform1f(t.getUniformLocation(this.tonemapProgram,"u_compression_threshold"),this.compressionThreshold),t.uniform1f(t.getUniformLocation(this.tonemapProgram,"u_brightness_desat"),this.brightnessDesaturation),t.uniform1f(t.getUniformLocation(this.tonemapProgram,"u_brightness_sat"),this.brightnessSaturation),t.uniform1f(t.getUniformLocation(this.tonemapProgram,"u_hdr_max_brightness"),r.maxBrightness),t.uniform1f(t.getUniformLocation(this.tonemapProgram,"u_hdr_avg_brightness"),r.avgBrightness),t.drawArrays(t.TRIANGLES,0,6);let o=this.bilateralManager.apply(this.ldrTexture);this.smaaManager.applyToFramebuffer(o,this.finalFramebuffer,this.quadBuffer),e&&this.downsampleToCanvas(),this.frame||(this.frame=0),this.frame++;let s=this.isRunning?this.statsUpdateInterval:this.statsUpdateIntervalSlow;if(this.frame%s===0){let l=this.framebufferManager.getCurrentTexture(),c=this.bufferStatsManager.compute(l,this.renderWidth,this.renderHeight,!0);this.enableDebugStats&&this.frame%(s*10)===0&&a.info("HDR Buffer Stats (sampled)",{avgBrightness:c.avgBrightness.toFixed(2),maxBrightness:c.maxBrightness.toFixed(2),sampledPixels:c.sampledPixels,sampleRate:c.sampleRate})}}getBufferStats(){let e=this.bufferStatsManager.getCached(),t=this.velocityStatsManager?this.velocityStatsManager.getCached():null;return e.maxVelocity=this.maxVelocity,e.avgVelocity=t?t.avgVelocity:0,e.velocitySampleCount=t?t.sampleCount:0,e}logBufferStats(){let e=this.getBufferStats(),t=Date.now()-e.timestamp;a.info("=== HDR Buffer Statistics (Sampled) ==="),a.info(`Cached age: ${(t/1e3).toFixed(1)}s`),a.info(`Sample rate: every ${e.sampleRate}th pixel (${e.sampledPixels} total)`),a.info(`Red   - Min: ${e.red.min.toFixed(6)}, Max: ${e.red.max.toFixed(6)}, Avg: ${e.red.avg.toFixed(6)}`),a.info(`Green - Min: ${e.green.min.toFixed(6)}, Max: ${e.green.max.toFixed(6)}, Avg: ${e.green.avg.toFixed(6)}`),a.info(`Blue  - Min: ${e.blue.min.toFixed(6)}, Max: ${e.blue.max.toFixed(6)}, Avg: ${e.blue.avg.toFixed(6)}`),a.info(`Max Brightness: ${e.maxBrightness.toFixed(6)}`),a.info(`Avg Brightness: ${e.avgBrightness.toFixed(6)}`),a.info(`Max Velocity: ${e.maxVelocity.toFixed(6)} (GPU-sampled, ${e.velocitySampleCount} particles, EMA-smoothed)`),e.avgVelocity&&a.info(`Avg Velocity: ${e.avgVelocity.toFixed(6)}`)}calculateParticleStatistics_REMOVED(){let e=this.particleSystem.getResolution(),t=[];for(let c=0;c<this.dimensions;c++)t.push(this.textureManager.readTexture(c));let i=[],r=[],o=this.strategy.getComponentsPerValue(),s=this.strategy.getArrayType(),l=[];for(let c=0;c<this.particleSystem.getActualParticleCount();c++){let d=[];for(let u=0;u<this.dimensions;u++){let h=t[u],g=c*o,f=new s(o);for(let b=0;b<o;b++)f[b]=h[g+b];let p=u===0?this.bbox.min[0]:u===1?this.bbox.min[1]:-10,x=u===0?this.bbox.max[0]:u===1?this.bbox.max[1]:10,y=this.strategy.decodeValue(f,p,x);d.push(y)}l.push(d)}for(let c=0;c<this.dimensions;c++){let d=1/0,u=-1/0,h=0;for(let f of l)d=Math.min(d,f[c]),u=Math.max(u,f[c]),h+=f[c];let g=["x","y","z","w"][c]||`dim${c}`;i.push({dim:g,min:d.toFixed(3),max:u.toFixed(3),avg:(h/l.length).toFixed(3)})}if(this.velocityEvaluators)for(let c=0;c<this.dimensions;c++){let d=1/0,u=-1/0,h=0;try{for(let f of l){let p=this.velocityEvaluators[c](...f);d=Math.min(d,p),u=Math.max(u,p),h+=p}let g=["x","y","z","w"][c]||`dim${c}`;r.push({dim:`v${g}`,min:d.toFixed(3),max:u.toFixed(3),avg:(h/l.length).toFixed(3)})}catch(g){a.warn(`Error computing velocity for dim ${c}`,g)}}a.verbose(`Frame ${this.frame}: Particle statistics`,{bounds:`[${this.bbox.min[0].toFixed(3)}, ${this.bbox.min[1].toFixed(3)}] to [${this.bbox.max[0].toFixed(3)}, ${this.bbox.max[1].toFixed(3)}]`,position:i,velocity:r.length>0?r:"N/A"})}sampleParticleVelocity(){let e=this.gl,t=[];for(let c=0;c<this.dimensions;c++)t.push(this.textureManager.readTexture(c));let i=this.strategy.getComponentsPerValue(),r=this.strategy.getArrayType(),s=Math.floor(Math.random()*this.particleSystem.getActualParticleCount())*i,l=[];for(let c=0;c<this.dimensions;c++){let d=t[c],u=new r(i);for(let p=0;p<i;p++)u[p]=d[s+p];let h=c===0?this.bbox.min[0]:c===1?this.bbox.min[1]:-10,g=c===0?this.bbox.max[0]:c===1?this.bbox.max[1]:10,f=this.strategy.decodeValue(u,h,g);l.push(f)}if(!this.velocityEvaluators||this.velocityEvaluators.length===0)return 0;try{let c=[];for(let h=0;h<this.dimensions;h++){let g=this.velocityEvaluators[h](...l);c.push(g)}let d=c.reduce((h,g)=>h+g*g,0),u=Math.sqrt(d);return isFinite(u)?u:(this.velocityNaNWarningLogged||(a.warn("Invalid velocity magnitude detected",{position:l,velocity:c,magnitude:u}),this.velocityNaNWarningLogged=!0),0)}catch(c){return this.velocityErrorLogged||(a.error("Error computing velocity",c),this.velocityErrorLogged=!0),0}}sampleParticleData(){let t=this.particleSystem.getResolution(),i=[],r=[];for(let l=0;l<this.dimensions;l++)r.push(this.textureManager.readTexture(l));let o=this.strategy.getComponentsPerValue(),s=this.strategy.getArrayType();for(let l=0;l<5;l++){let c=Math.floor(Math.random()*this.particleSystem.getActualParticleCount()),d=c*o,u=[];for(let f=0;f<this.dimensions;f++){let p=r[f],x=new s(o);for(let w=0;w<o;w++)x[w]=p[d+w];let y=f===0?this.bbox.min[0]:f===1?this.bbox.min[1]:-10,b=f===0?this.bbox.max[0]:f===1?this.bbox.max[1]:10,v=this.strategy.decodeValue(x,y,b);u.push(v.toFixed(3))}let h=r[0],g=o===4?h[d+3]:1;i.push({particle:c,position:u.join(", "),age:g.toFixed(2)})}a.verbose(`Frame ${this.frame}: Sampled 5 particles (with age)`,{bounds:`[${this.bbox.min[0].toFixed(3)}, ${this.bbox.min[1].toFixed(3)}] to [${this.bbox.max[0].toFixed(3)}, ${this.bbox.max[1].toFixed(3)}]`,samples:i})}decodeFloatRGBA(e,t,i,r){return((e<<24|t<<16|i<<8|r)>>>0)/4294967295}start(){this.isRunning=!0,this.frameCount=0,this.totalFrames=0,this.lastFpsUpdate=performance.now(),this.fps=0,this.frameLimitEnabled===void 0&&(this.frameLimitEnabled=!1),this.frameLimit===void 0&&(this.frameLimit=1e3),a.verbose(`Starting render loop (frameLimitEnabled: ${this.frameLimitEnabled}, frameLimit: ${this.frameLimit})`);let e=()=>{if(!this.isRunning)return;this.frameCount++,this.totalFrames++;let t=performance.now(),i=t-this.lastFpsUpdate;if(i>=500&&(this.fps=Math.round(this.frameCount*1e3/i),this.frameCount=0,this.lastFpsUpdate=t),this.render(),this.frameLimitEnabled&&this.totalFrames>=this.frameLimit){let o=performance.now()-this.lastFpsUpdate;o>0&&(this.fps=Math.round(this.frameCount*1e3/o)),a.info(`Frame limit reached (${this.frameLimit} frames), stopping render loop`),this.stop();return}requestAnimationFrame(e)};e()}stop(){this.isRunning=!1}setAnimationAlpha(e){this.animationAlpha=Math.max(0,Math.min(1,e))}clearRenderBuffer(e=!1){this.framebufferManager.clearAll(0,0,0,1),this.totalFrames=0,!this.isRunning&&!e&&(a.info("Restarting render loop after render buffer clear"),this.start()),a.verbose("Render buffer cleared (particles preserved)")}resetParticles(e=!1){if(this.particleSystem.initializeParticles(),this.textureManager.initializeData(this.particleSystem.getAllData()),a.verbose("Particles reinitialized to random positions"),e){a.info("Recompiling shaders after particle reset...");try{this.compileShaders(),a.info("Shaders recompiled successfully")}catch(t){a.error("Failed to recompile shaders:",t)}}}step(e=1){for(let t=0;t<e;t++)this.updatePositions()}clearScreen(){this.framebufferManager.clearAll(0,0,0,1),this.particleSystem.initializeParticles(),this.textureManager.initializeData(this.particleSystem.getAllData()),this.totalFrames=0,this.isRunning||(a.info("Restarting render loop after screen clear"),this.start()),a.verbose("Screen cleared and particles reinitialized")}captureRenderBuffer(){return new Promise((e,t)=>{let i=this.gl;try{i.bindFramebuffer(i.FRAMEBUFFER,this.finalFramebuffer);let r=new Uint8Array(this.renderWidth*this.renderHeight*4);i.readPixels(0,0,this.renderWidth,this.renderHeight,i.RGBA,i.UNSIGNED_BYTE,r),i.bindFramebuffer(i.FRAMEBUFFER,null);let o=document.createElement("canvas");o.width=this.renderWidth,o.height=this.renderHeight;let s=o.getContext("2d"),l=s.createImageData(this.renderWidth,this.renderHeight);l.data.set(r),s.save(),s.scale(1,-1),s.translate(0,-this.renderHeight),s.putImageData(l,0,0),s.restore(),o.toBlob(c=>{c?e(c):t(new Error("Failed to create blob from canvas"))},"image/png")}catch(r){a.error("Failed to capture render buffer:",r),t(r)}})}resize(e,t){let i=this.gl;if(!e||!t||e<=0||t<=0){a.warn(`Invalid resize dimensions: ${e}x${t}, skipping resize`);return}this.canvas.width=e,this.canvas.height=t,this.renderWidth=Math.max(1,Math.floor(e*this.supersampleFactor)),this.renderHeight=Math.max(1,Math.floor(t*this.supersampleFactor)),a.info("Resizing renderer",{canvasSize:`${e}x${t}`,renderSize:`${this.renderWidth}x${this.renderHeight}`,supersampleFactor:this.supersampleFactor}),this.framebufferManager.resize(this.renderWidth,this.renderHeight),this.bloomManager.resize(this.renderWidth,this.renderHeight),this.bilateralManager.resize(this.renderWidth,this.renderHeight),this.smaaManager.resize(this.renderWidth,this.renderHeight),i.bindTexture(i.TEXTURE_2D,this.ldrTexture),i.texImage2D(i.TEXTURE_2D,0,i.RGBA,this.renderWidth,this.renderHeight,0,i.RGBA,i.UNSIGNED_BYTE,null),i.bindTexture(i.TEXTURE_2D,null),i.bindTexture(i.TEXTURE_2D,this.finalTexture),i.texImage2D(i.TEXTURE_2D,0,i.RGBA,this.renderWidth,this.renderHeight,0,i.RGBA,i.UNSIGNED_BYTE,null),i.bindTexture(i.TEXTURE_2D,null),this.gl.viewport(0,0,e,t),this.clearScreen()}updateConfig(e){a.info("Updating configuration",e);let t=!1;if(e.dimensions!==void 0&&e.dimensions!==this.dimensions&&(a.info(`Changing dimensions: ${this.dimensions} \u2192 ${e.dimensions}`),this.dimensions=e.dimensions,t=!0,this.particleSystem.setDimensions(this.dimensions),this.textureManager.dispose(),this.textureManager=new Ve(this.gl,this.dimensions,this.particleSystem.getResolution(),this.strategy),this.particleRenderMode==="lines"&&this.textureManager.setLineMode(!0),this.textureManager.initializeData(this.particleSystem.getAllData())),e.coordinateSystem!==void 0&&(a.info(`Updating coordinate system: ${this.coordinateSystem.name} \u2192 ${e.coordinateSystem.name}`),this.coordinateSystem=e.coordinateSystem,t=!0,a.info("  needsRecompile flag set to true (coordinate system change)")),e.expressions!==void 0){a.info("Updating vector field expressions",e.expressions),this.expressions=e.expressions;try{let i;this.coordinateSystem&&typeof this.coordinateSystem.getVariableNames=="function"?i=this.coordinateSystem.getVariableNames():(a.warn("coordinateSystem missing getVariableNames(), using Cartesian fallback"),i=["x","y","z","w","u","v"].slice(0,this.dimensions)),this.velocityEvaluators=Nt(e.expressions,i),a.verbose("Velocity evaluators created successfully",{coordinateSystem:this.coordinateSystem?this.coordinateSystem.name:"unknown",variables:i})}catch(i){a.warn("Failed to create velocity evaluators",i),this.velocityEvaluators=null}t=!0,a.info("  needsRecompile flag set to true (expressions change)")}if(e.integratorType!==void 0&&e.integratorType!==this.integratorType&&(a.info(`Changing integrator: ${this.integratorType} \u2192 ${e.integratorType}`),this.integratorType=e.integratorType,t=!0),e.integratorParams!==void 0&&(a.verbose("Updating integrator parameters",e.integratorParams),this.integratorParams={...this.integratorParams,...e.integratorParams},t=!0),e.solutionMethod!==void 0&&e.solutionMethod!==this.solutionMethod&&(a.info(`Changing solution method: ${this.solutionMethod} \u2192 ${e.solutionMethod}`),this.solutionMethod=e.solutionMethod,t=!0,a.info("  needsRecompile flag set to true (solutionMethod change)")),a.info("Solution method update complete, continuing..."),e.transformType!==void 0&&e.transformType!==this.transformType&&(a.info(`Changing transform: ${this.transformType} \u2192 ${e.transformType}`),this.transformType=e.transformType,t=!0),e.transformParams!==void 0&&(a.verbose("Updating transform parameters",e.transformParams),this.transformParams=e.transformParams,t=!0),e.mapperType!==void 0&&e.mapperType!==this.mapperType&&(a.info(`Changing mapper: ${this.mapperType} \u2192 ${e.mapperType}`),this.mapperType=e.mapperType,t=!0),e.mapperParams!==void 0&&(a.verbose("Updating mapper parameters",e.mapperParams),this.mapperParams=e.mapperParams,t=!0),e.colorMode!==void 0&&e.colorMode!==this.colorMode&&(a.info(`Changing color mode: ${this.colorMode} \u2192 ${e.colorMode}`),this.colorMode=e.colorMode,t=!0),e.colorExpression!==void 0&&e.colorExpression!==this.colorExpression&&(a.info(`Changing color expression: ${this.colorExpression} \u2192 ${e.colorExpression}`),this.colorExpression=e.colorExpression,t=!0),e.colorGradient!==void 0&&JSON.stringify(e.colorGradient)!==JSON.stringify(this.colorGradient)&&(a.info("Changing color gradient"),this.colorGradient=e.colorGradient,t=!0),e.useCustomGradient!==void 0&&e.useCustomGradient!==this.useCustomGradient&&(a.info(`Changing custom gradient usage: ${this.useCustomGradient} \u2192 ${e.useCustomGradient}`),this.useCustomGradient=e.useCustomGradient,t=!0),e.velocityScaleMode!==void 0&&e.velocityScaleMode!==this.velocityScaleMode&&(a.info(`Changing velocity scale mode: ${this.velocityScaleMode} \u2192 ${e.velocityScaleMode}`),this.velocityScaleMode=e.velocityScaleMode),e.velocityLogScale!==void 0&&e.velocityLogScale!==this.velocityLogScale&&(a.info(`Changing velocity log scale: ${this.velocityLogScale} \u2192 ${e.velocityLogScale}`),this.velocityLogScale=e.velocityLogScale,t=!0),e.timestep!==void 0&&(a.verbose(`Timestep: ${this.timestep} \u2192 ${e.timestep}`),this.timestep=e.timestep),e.fadeOpacity!==void 0&&(a.verbose(`Fade opacity: ${this.fadeOpacity} \u2192 ${e.fadeOpacity}`),this.fadeOpacity=e.fadeOpacity),e.dropProbability!==void 0&&(a.verbose(`Drop probability: ${this.dropProbability} \u2192 ${e.dropProbability}`),this.dropProbability=e.dropProbability),e.dropLowVelocity!==void 0&&(a.verbose(`Drop low velocity: ${this.dropLowVelocity} \u2192 ${e.dropLowVelocity}`),this.dropLowVelocity=e.dropLowVelocity),e.lockShaderRecompilation!==void 0&&(a.info(`Shader recompilation lock: ${this.lockShaderRecompilation} \u2192 ${e.lockShaderRecompilation}`),this.lockShaderRecompilation=e.lockShaderRecompilation),e.useHDR!==void 0&&e.useHDR!==this.useHDR){a.info(`Changing HDR rendering: ${this.useHDR} \u2192 ${e.useHDR}`),this.useHDR=e.useHDR,this.framebufferManager.dispose(),this.framebufferManager=new Ne(this.gl,this.canvas.width,this.canvas.height,{useHDR:this.useHDR,usePingPong:!0});let i=this.framebufferManager.getHDRSupport();a.info("HDR rendering system reconfigured",{hdrEnabled:i.enabled,hdrSupported:i.supported,textureFormat:i.format}),this.useHDR&&!i.supported&&a.warn("HDR requested but not supported. Falling back to LDR."),this.clearScreen()}if(e.exposure!==void 0&&(a.verbose(`Exposure: ${this.exposure} \u2192 ${e.exposure}`),this.exposure=e.exposure,t=!0),e.gamma!==void 0&&(a.verbose(`Gamma: ${this.gamma} \u2192 ${e.gamma}`),this.gamma=e.gamma,t=!0),e.luminanceGamma!==void 0&&(a.verbose(`Luminance Gamma: ${this.luminanceGamma} \u2192 ${e.luminanceGamma}`),this.luminanceGamma=e.luminanceGamma,t=!0),e.highlightCompression!==void 0&&(a.verbose(`Highlight Compression: ${this.highlightCompression} \u2192 ${e.highlightCompression}`),this.highlightCompression=e.highlightCompression),e.compressionThreshold!==void 0&&(a.verbose(`Compression Threshold: ${this.compressionThreshold} \u2192 ${e.compressionThreshold}`),this.compressionThreshold=e.compressionThreshold),e.whitePoint!==void 0&&(a.verbose(`White point: ${this.whitePoint} \u2192 ${e.whitePoint}`),this.whitePoint=e.whitePoint,t=!0,this.bloomManager.updateConfig({threshold:e.whitePoint})),e.tonemapOperator!==void 0&&e.tonemapOperator!==this.tonemapOperator&&(a.info(`Tone mapping operator: ${this.tonemapOperator} \u2192 ${e.tonemapOperator}`),this.tonemapOperator=e.tonemapOperator,t=!0),e.particleIntensity!==void 0&&(a.verbose(`Particle intensity: ${this.particleIntensity} \u2192 ${e.particleIntensity}`),this.particleIntensity=e.particleIntensity),e.particleSize!==void 0&&(a.verbose(`Particle size: ${this.particleSize} \u2192 ${e.particleSize}`),this.particleSize=e.particleSize),e.particleRenderMode!==void 0&&e.particleRenderMode!==this.particleRenderMode){a.info(`Particle render mode: ${this.particleRenderMode} \u2192 ${e.particleRenderMode}`),this.particleRenderMode=e.particleRenderMode;let i=this.particleRenderMode==="lines";this.textureManager.setLineMode(i),t=!0}if(e.colorSaturation!==void 0&&(a.verbose(`Color saturation: ${this.colorSaturation} \u2192 ${e.colorSaturation}`),this.colorSaturation=e.colorSaturation),e.brightnessDesaturation!==void 0&&(a.verbose(`Brightness desaturation: ${this.brightnessDesaturation} \u2192 ${e.brightnessDesaturation}`),this.brightnessDesaturation=e.brightnessDesaturation),e.brightnessSaturation!==void 0&&(a.verbose(`Brightness saturation: ${this.brightnessSaturation} \u2192 ${e.brightnessSaturation}`),this.brightnessSaturation=e.brightnessSaturation),e.useDepthTest!==void 0&&(a.verbose(`Depth testing: ${this.useDepthTest} \u2192 ${e.useDepthTest}`),this.useDepthTest=e.useDepthTest),e.bloomEnabled!==void 0&&(a.verbose(`Bloom enabled: ${this.bloomEnabled} \u2192 ${e.bloomEnabled}`),this.bloomEnabled=e.bloomEnabled,this.bloomManager.updateConfig({enabled:e.bloomEnabled})),e.bloomIntensity!==void 0&&(a.verbose(`Bloom intensity: ${this.bloomIntensity} \u2192 ${e.bloomIntensity}`),this.bloomIntensity=e.bloomIntensity,this.bloomManager.updateConfig({intensity:e.bloomIntensity})),e.bloomRadius!==void 0&&(a.verbose(`Bloom radius: ${this.bloomRadius} \u2192 ${e.bloomRadius}`),this.bloomRadius=e.bloomRadius,this.bloomManager.updateConfig({radius:e.bloomRadius}),t=!0),e.bloomAlpha!==void 0&&(a.verbose(`Bloom alpha: ${this.bloomAlpha} \u2192 ${e.bloomAlpha}`),this.bloomAlpha=e.bloomAlpha),e.smaaEnabled!==void 0&&(a.verbose(`SMAA enabled: ${this.smaaEnabled} \u2192 ${e.smaaEnabled}`),this.smaaEnabled=e.smaaEnabled,this.smaaManager.updateConfig({enabled:e.smaaEnabled})),e.smaaIntensity!==void 0&&(a.verbose(`SMAA intensity: ${this.smaaIntensity} \u2192 ${e.smaaIntensity}`),this.smaaIntensity=e.smaaIntensity,this.smaaManager.updateConfig({intensity:e.smaaIntensity})),e.smaaThreshold!==void 0&&(a.verbose(`SMAA threshold: ${this.smaaThreshold} \u2192 ${e.smaaThreshold}`),this.smaaThreshold=e.smaaThreshold,this.smaaManager.updateConfig({threshold:e.smaaThreshold})),e.bilateralEnabled!==void 0&&(a.verbose(`Bilateral filter enabled: ${this.bilateralEnabled} \u2192 ${e.bilateralEnabled}`),this.bilateralEnabled=e.bilateralEnabled,this.bilateralManager.updateConfig({enabled:e.bilateralEnabled})),e.bilateralSpatialSigma!==void 0&&(a.verbose(`Bilateral spatial sigma: ${this.bilateralSpatialSigma} \u2192 ${e.bilateralSpatialSigma}`),this.bilateralSpatialSigma=e.bilateralSpatialSigma,this.bilateralManager.updateConfig({spatialSigma:e.bilateralSpatialSigma})),e.bilateralIntensitySigma!==void 0&&(a.verbose(`Bilateral intensity sigma: ${this.bilateralIntensitySigma} \u2192 ${e.bilateralIntensitySigma}`),this.bilateralIntensitySigma=e.bilateralIntensitySigma,this.bilateralManager.updateConfig({intensitySigma:e.bilateralIntensitySigma})),e.supersampleFactor!==void 0&&e.supersampleFactor!==this.supersampleFactor){a.info(`Render scale factor: ${this.supersampleFactor} \u2192 ${e.supersampleFactor}`);let i=Math.max(.5,Math.min(4,e.supersampleFactor));i!==e.supersampleFactor&&a.warn(`Invalid render scale factor ${e.supersampleFactor}, clamping to ${i}`),this.supersampleFactor=i,a.info(`Applying render scale factor: ${this.supersampleFactor}`),this.resize(this.canvas.width,this.canvas.height)}if(e.particleCount!==void 0&&e.particleCount!==this.particleSystem.particleCount&&(this.particleSystem.setParticleCount(e.particleCount),this.textureManager.resize(this.particleSystem.getResolution()),this.textureManager.initializeData(this.particleSystem.getAllData()),this.gl.deleteBuffer(this.indexBufferPoints),this.gl.deleteBuffer(this.indexBufferLines),this.gl.deleteBuffer(this.vertexIdBufferLines),this.indexBufferPoints=this.createBuffer(this.particleSystem.getIndices()),this.indexBufferLines=this.createLineIndexBuffer(this.particleSystem.getActualParticleCount()),this.vertexIdBufferLines=this.createLineVertexIdBuffer(this.particleSystem.getActualParticleCount())),e.bbox!==void 0&&(this.bbox=e.bbox,this.particleSystem.setBBox(this.bbox),e.reinitializeParticles&&(this.particleSystem.initializeParticles(),this.textureManager.initializeData(this.particleSystem.getAllData()),a.info("Particles reinitialized to new viewport bounds")),this.clearScreen()),a.info(`Checking needsRecompile flag: ${t}`),t)if(this.lockShaderRecompilation)a.info("Shader recompilation needed but LOCKED - skipping recompilation");else{a.info("Recompiling shaders...");try{let i=this.compileShaders();if(i){a.error("Recompilation failed",i),a.warn("Shader compilation failed - visualization will not render until error is resolved");return}this.frame=0,a.info("Clearing screen after recompilation..."),this.clearScreen(),a.info("Configuration updated successfully, shaders recompiled")}catch(i){a.error("EXCEPTION during shader recompilation:",i),a.error("Stack trace:",i.stack),a.warn("Shader compilation exception - visualization will not render until error is resolved")}}else a.info("Configuration updated (no recompile needed)");a.info("Current settings applied",{dimensions:this.dimensions,expressions:this.expressions,integrator:this.integratorType,mapper:this.mapperType,timestep:this.timestep,particleCount:this.particleSystem.particleCount,fadeOpacity:this.fadeOpacity,dropProbability:this.dropProbability,bbox:`[${this.bbox.min[0].toFixed(3)}, ${this.bbox.min[1].toFixed(3)}] to [${this.bbox.max[0].toFixed(3)}, ${this.bbox.max[1].toFixed(3)}]`})}testEncodeDecodeSymmetry(){let{encodeFloatRGBA:e,decodeFloatRGBA:t}=(ni(),Br(lr)),i=[0,.1,.25,.5,.75,.9,1];for(let u=0;u<100;u++)i.push(Math.random());let r=0,o=0,s=[],l=[];a.info("Testing encode/decode symmetry...");for(let u of i){let h=new Uint8Array(4);e(u,h,0);let g=t(h[0],h[1],h[2],h[3]),f=Math.abs(u-g);s.push(f),o+=f,r=Math.max(r,f),f>1e-6&&l.push({original:u,encoded:`[${h[0]}, ${h[1]}, ${h[2]}, ${h[3]}]`,decoded:g,error:f})}o/=i.length,a.info("Encode/Decode symmetry test results:",{testCount:i.length,maxError:r.toExponential(3),avgError:o.toExponential(3),problematicCount:l.length,problematicSamples:l.slice(0,5)}),a.info("Testing world coordinate round-trip [-5, 5]...");let c=[-5,-4,-2.5,0,2.5,4,5],d=[];for(let u of c){let h=(u-this.bbox.min[0])/(this.bbox.max[0]-this.bbox.min[0]),g=new Uint8Array(4);e(h,g,0);let f=t(g[0],g[1],g[2],g[3]),p=this.bbox.min[0]+f*(this.bbox.max[0]-this.bbox.min[0]),x=Math.abs(u-p);d.push({world:u.toFixed(3),normalized:h.toFixed(6),decoded:p.toFixed(6),error:x.toExponential(3)})}return a.info("World coordinate round-trip results:",{tests:d}),{maxError:r,avgError:o,problematic:l.length}}logBufferStats(){let e=this.gl;if(!this.framebufferManager){a.warn("No framebuffer manager available");return}let t=this.framebufferManager.currentIndex;e.bindFramebuffer(e.FRAMEBUFFER,this.framebufferManager.framebuffers[t]);let i=this.canvas.width,r=this.canvas.height,o=i*r,s=this.framebufferManager.isHDR(),l=s?new Float32Array(o*4):new Uint8Array(o*4);e.readPixels(0,0,i,r,e.RGBA,s?e.FLOAT:e.UNSIGNED_BYTE,l);let c=1/0,d=1/0,u=1/0,h=-1/0,g=-1/0,f=-1/0,p=0,x=0,y=0,b=-1/0,v=0;for(let E=0;E<o;E++){let R=E*4,I=l[R],B=l[R+1],z=l[R+2];s||(I/=255,B/=255,z/=255),c=Math.min(c,I),d=Math.min(d,B),u=Math.min(u,z),h=Math.max(h,I),g=Math.max(g,B),f=Math.max(f,z),p+=I,x+=B,y+=z;let K=Math.max(I,B,z);b=Math.max(b,K),K>1&&v++}let w=p/o,S=x/o,M=y/o;a.info("=== HDR Buffer Statistics ==="),a.info(`Framebuffer: ${i}x${r} (${o.toLocaleString()} pixels)`),a.info(`Format: ${s?"HDR Float":"LDR RGBA8"}`),a.info(`Red   - Min: ${c.toFixed(6)}, Max: ${h.toFixed(6)}, Avg: ${w.toFixed(6)}`),a.info(`Green - Min: ${d.toFixed(6)}, Max: ${g.toFixed(6)}, Avg: ${S.toFixed(6)}`),a.info(`Blue  - Min: ${u.toFixed(6)}, Max: ${f.toFixed(6)}, Avg: ${M.toFixed(6)}`),a.info(`Max Brightness (max of R/G/B): ${b.toFixed(6)}`),a.info(`Pixels above 1.0: ${v.toLocaleString()} (${(v/o*100).toFixed(2)}%)`),e.bindFramebuffer(e.FRAMEBUFFER,null)}logShaders(){if(!this.shaderSource){console.warn("No shader source available");return}console.log("=== UPDATE VERTEX SHADER ==="),console.log(this.shaderSource.updateVertex),console.log(`=== END SHADER ===
`),console.log("=== UPDATE FRAGMENT SHADER ==="),console.log(this.shaderSource.updateFragment),console.log(`=== END SHADER ===
`),console.log("=== DRAW VERTEX SHADER ==="),console.log(this.shaderSource.drawVertex),console.log(`=== END SHADER ===
`),console.log("=== DRAW FRAGMENT SHADER ==="),console.log(this.shaderSource.drawFragment),console.log("=== END SHADER ==="),a.info("Shaders logged to console")}logUpdateShader(){if(!this.shaderSource){console.warn("No shader source available");return}console.log("=== UPDATE FRAGMENT SHADER (Integrator + Jacobian) ==="),console.log(this.shaderSource.updateFragment),console.log("=== END SHADER ==="),a.info("Update shader logged to browser console")}logDrawShader(){if(!this.shaderSource){console.warn("No shader source available");return}console.log("=== DRAW VERTEX SHADER ==="),console.log(this.shaderSource.drawVertex),console.log("=== END VERTEX SHADER ==="),console.log(""),console.log("=== DRAW FRAGMENT SHADER (Color Mode) ==="),console.log(this.shaderSource.drawFragment),console.log("=== END FRAGMENT SHADER ==="),a.info("Draw shaders (vertex + fragment) logged to browser console")}logScreenShader(){if(!this.shaderSource||!this.shaderSource.screenFragment){console.warn("No screen shader source available");return}console.log("=== SCREEN FRAGMENT SHADER (Tone Mapping) ==="),console.log(this.shaderSource.screenFragment),console.log("=== END SHADER ==="),a.info("Screen shader logged to browser console")}logStatsShaders(){if(a.info("=== DIAGNOSTIC STATS SHADERS ==="),this.velocityStatsManager&&this.velocityStatsManager.getShaderSource){let e=this.velocityStatsManager.getShaderSource();e?(console.log("=== VELOCITY STATS FRAGMENT SHADER ==="),console.log(e),console.log("=== END SHADER ===")):console.warn("Velocity stats shader not available")}else console.warn("VelocityStatsManager not initialized or no getShaderSource method");if(this.bufferStatsManager&&this.bufferStatsManager.getShaderSource){let e=this.bufferStatsManager.getShaderSource();e?(console.log("=== BRIGHTNESS STATS FRAGMENT SHADER ==="),console.log(e),console.log("=== END SHADER ===")):console.warn("Buffer stats shader not available")}else console.warn("BufferStatsManager not initialized or no getShaderSource method");a.info("Stats shaders logged to browser console")}readPixelAt(e,t){let i=this.gl,r=Math.floor(e*(this.renderWidth/this.canvas.width)),o=Math.floor(t*(this.renderHeight/this.canvas.height)),s=this.renderHeight-o-1;if(r<0||r>=this.renderWidth||s<0||s>=this.renderHeight)return null;let l={hdr:null,ldr:null};if(this.useHDR&&this.framebufferManager){let c=this.framebufferManager.getCurrentTexture(),d=this.framebufferManager.framebuffers[this.framebufferManager.currentIndex];if(i.bindFramebuffer(i.FRAMEBUFFER,d),this.framebufferManager.hdrType===i.FLOAT){let u=new Float32Array(4);i.readPixels(r,s,1,1,i.RGBA,i.FLOAT,u),l.hdr=[u[0],u[1],u[2]]}else{let u=new Uint8Array(4);i.readPixels(r,s,1,1,i.RGBA,i.UNSIGNED_BYTE,u),l.hdr=[u[0]/255,u[1]/255,u[2]/255]}}if(this.ldrFramebuffer&&this.ldrTexture){i.bindFramebuffer(i.FRAMEBUFFER,this.ldrFramebuffer);let c=new Uint8Array(4);i.readPixels(r,s,1,1,i.RGBA,i.UNSIGNED_BYTE,c),l.ldr=[c[0]/255,c[1]/255,c[2]/255]}return i.bindFramebuffer(i.FRAMEBUFFER,null),l}};Le();var q=class{constructor(e,t,i={}){this.id=e,this.defaultValue=t,this.settingsKey=i.settingsKey||e,this.onChange=i.onChange||null,this.element=null}getValue(){throw new Error("getValue() must be implemented by subclass")}setValue(e){throw new Error("setValue() must be implemented by subclass")}reset(){this.setValue(this.defaultValue)}attachListeners(e){throw new Error("attachListeners() must be implemented by subclass")}getMousePositionInElement(e,t){let r=$(t).offset();return{x:e.pageX-r.left,y:e.pageY-r.top}}handleButtonAction(e){return!1}saveToSettings(e){e[this.settingsKey]=this.getValue()}restoreFromSettings(e){e&&e[this.settingsKey]!=null&&this.setValue(e[this.settingsKey])}},ee=class extends q{constructor(e,t,i={}){super(e,t,i),this.min=i.min||0,this.max=i.max||100,this.step=i.step||1,this.displayId=i.displayId||null,this.displayFormat=i.displayFormat||(r=>r.toFixed(2)),this.transform=i.transform||(r=>r),this.inverseTransform=i.inverseTransform||(r=>r)}getValue(){let e=$(`#${this.id}`),t=parseFloat(e.val());return this.transform(t)}setValue(e){let t=$(`#${this.id}`),i=this.inverseTransform(e);t.val(i),this.updateDisplay(e)}updateDisplay(e){this.displayId&&$(`#${this.displayId}`).text(this.displayFormat(e))}handleButtonAction(e){let t=$(`#${this.id}`);if(!t.length)return!1;let i=parseFloat(t.val()),r=parseFloat(t.attr("min")),o=parseFloat(t.attr("max")),s=parseFloat(t.attr("step"))||this.step,l=s;(e==="increase-large"||e==="decrease-large")&&(l=s*10);let c=i;if(e==="increase"||e==="increase-large")c=Math.min(o,i+l);else if(e==="decrease"||e==="decrease-large")c=Math.max(r,i-l);else if(e==="reset")c=this.inverseTransform(this.defaultValue);else return!1;return c!==i?(t.val(c).trigger("input"),!0):!1}attachListeners(e){let t=$(`#${this.id}`);this.element=t,t.attr("min",this.min),t.attr("max",this.max),t.attr("step",this.step),this.setValue(this.defaultValue);let i=()=>{let r=this.getValue();this.updateDisplay(r),this.onChange&&this.onChange(r),e&&e()};t.on("input change",i)}},le=class extends q{constructor(e,t,i={}){super(e,t,i),this.minValue=i.minValue||.01,this.maxValue=i.maxValue||100,this.displayId=i.displayId||null,this.displayFormat=i.displayFormat||(r=>r.toFixed(3))}linearToLog(e){let t=Math.log(this.minValue),r=(Math.log(this.maxValue)-t)/100;return Math.exp(t+r*e)}logToLinear(e){let t=Math.log(this.minValue),r=(Math.log(this.maxValue)-t)/100;return(Math.log(e)-t)/r}getValue(){let e=$(`#${this.id}`),t=parseFloat(e.val());return this.linearToLog(t)}setValue(e){let t=$(`#${this.id}`),i=this.logToLinear(e);t.val(i),this.updateDisplay(e)}updateDisplay(e){this.displayId&&$(`#${this.displayId}`).text(this.displayFormat(e))}handleButtonAction(e){let t=$(`#${this.id}`);if(!t.length)return!1;let i=parseFloat(t.val()),r=0,o=100,s=1;(e==="increase-large"||e==="decrease-large")&&(s=10);let l=i;if(e==="increase"||e==="increase-large")l=Math.min(o,i+s);else if(e==="decrease"||e==="decrease-large")l=Math.max(r,i-s);else if(e==="reset")l=this.logToLinear(this.defaultValue);else return!1;return l!==i?(t.val(l).trigger("input"),!0):!1}attachListeners(e){let t=$(`#${this.id}`);this.element=t,t.attr("min",0),t.attr("max",100),t.attr("step",.1),this.setValue(this.defaultValue),t.on("input",()=>{let i=this.getValue();this.updateDisplay(i),this.onChange&&this.onChange(i),e&&e()})}},gt=class extends q{constructor(e,t,i={}){super(e,t,i),this.trim=i.trim!==void 0?i.trim:!0}getValue(){let t=$(`#${this.id}`).val();return this.trim&&(t=t.trim()),t}setValue(e){$(`#${this.id}`).val(e)}attachListeners(e){let t=$(`#${this.id}`);this.element=t,this.setValue(this.defaultValue),t.on("input",()=>{let i=this.getValue();this.onChange&&this.onChange(i),e&&e()})}},ce=class extends q{constructor(e,t,i={}){super(e,t,i)}getValue(){let t=$(`#${this.id}`).val();return t??this.defaultValue}setValue(e){$(`#${this.id}`).val(e)}attachListeners(e){let t=$(`#${this.id}`);this.element=t,this.setValue(this.defaultValue),t.on("change",()=>{let i=this.getValue();this.onChange&&this.onChange(i),e&&e()})}},W=class extends q{constructor(e,t,i={}){super(e,t,i)}getValue(){return $(`#${this.id}`).prop("checked")}setValue(e){$(`#${this.id}`).prop("checked",e)}attachListeners(e){let t=$(`#${this.id}`);this.element=t,this.setValue(this.defaultValue),t.on("change",()=>{let i=this.getValue();this.onChange&&this.onChange(i),e&&e()})}},he=class extends q{constructor(e,t,i={}){super(e,t,i),this.min=i.min||0,this.max=i.max||100,this.step=i.step||.1,this.displayId=i.displayId||null,this.displayFormat=i.displayFormat||(r=>r.toFixed(2))}getValue(){let e=$(`#${this.id}`);return parseFloat(e.val())/100}setValue(e){let t=$(`#${this.id}`),i=e*100;t.val(i),this.updateDisplay(e)}updateDisplay(e){this.displayId&&$(`#${this.displayId}`).text(this.displayFormat(e))}handleButtonAction(e){let t=$(`#${this.id}`);if(!t.length)return!1;let i=parseFloat(t.val()),r=parseFloat(t.attr("min")),o=parseFloat(t.attr("max")),s=parseFloat(t.attr("step"))||this.step,l=s;(e==="increase-large"||e==="decrease-large")&&(l=s*10);let c=i;if(e==="increase"||e==="increase-large")c=Math.min(o,i+l);else if(e==="decrease"||e==="decrease-large")c=Math.max(r,i-l);else if(e==="reset")c=this.defaultValue*100;else return!1;return c!==i?(t.val(c).trigger("input"),!0):!1}attachListeners(e){let t=$(`#${this.id}`);this.element=t,t.attr("min",this.min),t.attr("max",this.max),t.attr("step",this.step),this.setValue(this.defaultValue),t.on("input",()=>{let i=this.getValue();this.updateDisplay(i),this.onChange&&this.onChange(i),e&&e()})}};var bt=class{constructor(e={}){this.controls=new Map,this.storageKey=e.storageKey||"settings",this.onApply=e.onApply||null,this.debounceTime=e.debounceTime||300,this.applyTimeout=null,this.renderer=e.renderer||null}register(e){return this.controls.set(e.id,e),e}registerAll(e){e.forEach(t=>this.register(t))}initializeControls(){let e=()=>this.debouncedApply();for(let t of this.controls.values())t.attachListeners(e)}attachAllListeners(){this.initializeControls()}applySettings(e){this.setSettings(e)}get(e){return this.controls.get(e)}getSettings(){let e={};for(let t of this.controls.values())t.saveToSettings(e);return e}setSettings(e){if(e.coordinateSystem&&e.dimensions)try{let t=e.coordinateSystem,i=j.fromJSON(t);if(i.dimensions===e.dimensions){this.renderer&&(this.renderer.coordinateSystem=i);let r=this.get("dimension-inputs");r&&r.setCoordinateSystem&&r.setCoordinateSystem(i,!1)}}catch(t){console.error("Failed to restore coordinate system from settings:",t)}for(let t of this.controls.values())t.restoreFromSettings(e);for(let t of this.controls.values())t.onChange&&e&&e[t.settingsKey]!==void 0&&t.onChange(t.getValue())}resetAll(){for(let e of this.controls.values())e.reset()}saveToStorage(){let e=this.getSettings();return localStorage.setItem(this.storageKey,JSON.stringify(e)),e}loadFromStorage(){try{let e=localStorage.getItem(this.storageKey);if(e){let t=JSON.parse(e);return this.setSettings(t),t}}catch(e){console.warn("Failed to load settings from localStorage:",e)}return null}clearStorage(){localStorage.removeItem(this.storageKey)}debouncedApply(){this.applyTimeout&&clearTimeout(this.applyTimeout),this.applyTimeout=setTimeout(()=>{if(this.onApply){let e=this.getSettings();this.onApply(e)}},this.debounceTime)}apply(){if(this.onApply){let e=this.getSettings();this.onApply(e)}}};function fe(n,e=0){setTimeout(()=>{let t;if(typeof n=="string"?t=$(n):t=n,!t.length){console.warn("resizeAccordion: Element not found",n);return}let i=t.closest(".accordion-section");i.length&&!i.hasClass("collapsed")&&i.css("max-height",i[0].scrollHeight+"px")},e)}var we=class n extends ee{constructor(e,t,i={}){super(e,t,i),this.animationEnabled=!1,this.animationMin=i.animationMin!==void 0?i.animationMin:this.transform(this.min),this.animationMax=i.animationMax!==void 0?i.animationMax:this.transform(this.max),this.currentAlpha=0,this.isAnimating=!1}setAnimationEnabled(e){this.animationEnabled=e,this.updateAnimationUI()}setAnimationBounds(e,t){this.animationMin=Math.min(e,t),this.animationMax=Math.max(e,t),this.updateBoundsDisplay()}updateFromAlpha(e){if(!this.animationEnabled)return;this.currentAlpha=e;let t=this.animationMin+e*(this.animationMax-this.animationMin);this.isAnimating=!0,this.setValue(t),this.updateCurrentIndicator(e),this.isAnimating=!1}updateCurrentIndicator(e){let t=$(`#${this.id}-current-indicator`);t.length&&t.css("left",`${e*100}%`)}updateBoundsDisplay(){let e=$(`#${this.id}-min-handle`),t=$(`#${this.id}-max-handle`),i=$(`#${this.id}-min-display`),r=$(`#${this.id}-max-display`),o=$(`#${this.id}-range`);if(e.length&&t.length){let s=this.inverseTransform(this.animationMin),l=this.inverseTransform(this.animationMax),c=(s-this.min)/(this.max-this.min)*100,d=(l-this.min)/(this.max-this.min)*100;e.css("left",`${c}%`),t.css("left",`${d}%`),o.css({left:`${c}%`,width:`${d-c}%`}),i.length&&i.text(this.displayFormat(this.animationMin)),r.length&&r.text(this.displayFormat(this.animationMax))}}updateAnimationUI(){let e=$(`#${this.id}-animation-bounds`),t=$(`#${this.id}-anim-btn`);this.animationEnabled?(e.slideDown(200,()=>{fe(`#${this.id}`,0)}),t.addClass("active"),t.attr("title","Disable animation (\u{1F3AC})"),this.updateBoundsDisplay()):(e.slideUp(200,()=>{fe(`#${this.id}`,0)}),t.removeClass("active"),t.attr("title","Enable animation (\u{1F3AC})"))}attachListeners(e){super.attachListeners(e);let i=$(`#${this.id}`).closest(".slider-control"),r=$("<button>").attr("id",`${this.id}-anim-btn`).addClass("slider-btn anim-btn").attr("title","Enable animation (\u{1F3AC})").html("\u{1F3AC}").on("click",s=>{s.stopPropagation(),this.setAnimationEnabled(!this.animationEnabled)});i.append(r);let o=`
            <div id="${this.id}-animation-bounds" class="animation-bounds-slider" style="display: none;">
                <div class="bounds-labels">
                    <span>Min: <span id="${this.id}-min-display">${this.displayFormat(this.animationMin)}</span></span>
                    <span>Max: <span id="${this.id}-max-display">${this.displayFormat(this.animationMax)}</span></span>
                </div>
                <div class="multi-thumb-slider">
                    <div class="slider-track"></div>
                    <div id="${this.id}-range" class="slider-range"></div>
                    <div id="${this.id}-current-indicator" class="slider-current-indicator"></div>
                    <div id="${this.id}-min-handle" class="slider-thumb min-thumb" data-bound="min">
                        <span class="thumb-label">MIN</span>
                    </div>
                    <div id="${this.id}-max-handle" class="slider-thumb max-thumb" data-bound="max">
                        <span class="thumb-label">MAX</span>
                    </div>
                </div>
            </div>
        `;i.after(o),this.attachThumbDragHandlers()}attachThumbDragHandlers(){let e=$(`#${this.id}-min-handle`),t=$(`#${this.id}-max-handle`),i=e.parent();[{handle:e,bound:"min"},{handle:t,bound:"max"}].forEach(({handle:o,bound:s})=>{let l=!1;o.on("mousedown",c=>{l=!0,o.addClass("dragging"),$("body").css("user-select","none"),c.preventDefault()}),$(document).on("mousemove",c=>{if(!l)return;let d=this.getMousePositionInElement(c,i),u=i.width(),h=d.x/u*100;h=Math.max(0,Math.min(100,h));let g=this.min+h/100*(this.max-this.min),f=this.transform(g);s==="min"?f<=this.animationMax&&(this.animationMin=f):f>=this.animationMin&&(this.animationMax=f),this.updateBoundsDisplay()}),$(document).on("mouseup",()=>{l&&(l=!1,o.removeClass("dragging"),$("body").css("user-select",""))})})}saveToSettings(e){super.saveToSettings(e),this.animationEnabled&&(e.animations||(e.animations={}),e.animations[this.settingsKey]={enabled:!0,min:this.animationMin,max:this.animationMax})}restoreFromSettings(e){if(super.restoreFromSettings(e),e.animations&&e.animations[this.settingsKey]){let t=e.animations[this.settingsKey];this.animationEnabled=t.enabled||!1,this.animationMin=t.min,this.animationMax=t.max,this.updateAnimationUI()}}static getAllAnimatableControls(e){let t=[];return e.controls.forEach(i=>{i instanceof n&&i.animationEnabled&&t.push(i)}),t}};var xt=class extends we{constructor(e,t,i={}){super(e,t,i),this.smallIncrement=i.smallIncrement||.001,this.largeIncrement=i.largeIncrement||.01}handleButtonAction(e){let t=$(`#${this.id}`);if(!t.length)return!1;let i=this.getValue(),r=this.min,o=this.max,s;if(e==="increase"||e==="decrease")s=this.smallIncrement;else if(e==="increase-large"||e==="decrease-large")s=this.largeIncrement;else if(e==="reset"){let c=this.defaultValue;return c!==i?(this.setValue(c),t.trigger("input"),!0):!1}else return!1;let l=i;return e==="increase"||e==="increase-large"?l=Math.min(o,i+s):(e==="decrease"||e==="decrease-large")&&(l=Math.max(r,i-s)),l!==i?(this.setValue(l),t.trigger("input"),!0):!1}};function co(n=2,e=10){return t=>{let i=Math.abs(t);return i>=e||i<1/e&&i!==0?t.toExponential(n):t.toFixed(n+1)}}function uo(n=2){return e=>e.toFixed(n)}function ho(){return n=>n.toFixed(0)}function cr(n,e,t){return n>0&&e/n>1e3?"adaptive":"linear"}function dr(n,e,t=!1){let i=Math.abs(n),r=i<e?e:Math.pow(10,Math.floor(Math.log10(i))-1);return r=Math.max(e,r),t&&(r*=10),r}function ur(n=!1){return n?10:1}function hr(n,e=!1){return e?n*10:n}function mr(n){if(typeof n.displayFormat=="function")return n.displayFormat;let e=n.displayPrecision??2;switch(n.displayFormat){case"scientific":return co(e,n.scientificThreshold??10);case"integer":return ho();case"decimal":default:return uo(e)}}var si=class extends q{constructor(e,t,i,r={}){super(e,i,r),this.parameterDef=t,this.scale=t.scale||cr(t.min,t.max,t.step),this.formatter=mr(t),this.displayElement=null}calculateIncrement(e,t=!1){switch(this.scale){case"adaptive":return dr(e,this.parameterDef.step,t);case"log":return ur(t);case"linear":default:return hr(this.parameterDef.step,t)}}handleButtonAction(e){let t=$(`#${this.id}`);if(!t.length)return!1;let i=this.getValue(),r=this.parameterDef.min,o=this.parameterDef.max,s=i;if(e==="reset")s=this.defaultValue;else{let l=this.calculateIncrement(i,e.includes("large"));if(e.startsWith("increase"))s=Math.min(o,i+l);else if(e.startsWith("decrease"))s=Math.max(r,i-l);else return!1}return s!==i?(this.setValue(s),t.trigger("input"),!0):!1}render(){let e=`${this.id}-display`,t=this.defaultValue;return`
            <div class="control-group">
                <label>
                    ${this.parameterDef.label}:
                    <span class="range-value" id="${e}">
                        ${this.formatter(t)}
                    </span>
                </label>
                <div class="slider-control">
                    <button class="slider-btn" data-slider="${this.id}" data-action="decrease-large">--</button>
                    <button class="slider-btn" data-slider="${this.id}" data-action="decrease">-</button>
                    <input type="range" id="${this.id}">
                    <button class="slider-btn" data-slider="${this.id}" data-action="increase">+</button>
                    <button class="slider-btn" data-slider="${this.id}" data-action="increase-large">++</button>
                </div>
                ${this.parameterDef.info?`<div class="info">${this.parameterDef.info}</div>`:""}
            </div>
        `}attachListeners(e){let t=$(`#${this.id}`);if(this.element=t,this.displayElement=$(`#${this.id}-display`),!t.length){console.error(`ParameterControl: Element #${this.id} not found in DOM`);return}t.attr("min",this.parameterDef.min),t.attr("max",this.parameterDef.max),t.attr("step",this.parameterDef.step),t.val(this.defaultValue),this.updateDisplay(this.defaultValue),t.on("input",()=>{let i=this.getValue();this.updateDisplay(i),this.onChange&&this.onChange(i),e&&e()})}updateDisplay(e){this.displayElement&&this.displayElement.length&&this.displayElement.text(this.formatter(e))}getValue(){return!this.element||!this.element.length?this.defaultValue:parseFloat(this.element.val())}setValue(e){this.element&&this.element.length&&(this.element.val(e),this.updateDisplay(e))}reset(){this.setValue(this.defaultValue)}},Be=class extends si{constructor(e,t,i,r={}){super(e,t,i,r),this.animationEnabled=!1;let o=t.max-t.min;this.animationMin=r.animationMin??t.min+o*.25,this.animationMax=r.animationMax??t.min+o*.75,this.currentAlpha=0,this.isAnimating=!1}setAnimationEnabled(e){this.animationEnabled=e,this.updateAnimationUI()}setAnimationBounds(e,t){this.animationMin=Math.min(e,t),this.animationMax=Math.max(e,t),this.updateBoundsDisplay()}updateFromAlpha(e){if(!this.animationEnabled)return;this.currentAlpha=e;let t=this.animationMin+e*(this.animationMax-this.animationMin);this.isAnimating=!0,this.setValue(t),this.updateCurrentIndicator(e),this.isAnimating=!1}updateCurrentIndicator(e){let t=$(`#${this.id}-current-indicator`);t.length&&t.css("left",`${e*100}%`)}updateBoundsDisplay(){let e=$(`#${this.id}-min-handle`),t=$(`#${this.id}-max-handle`),i=$(`#${this.id}-min-display`),r=$(`#${this.id}-max-display`),o=$(`#${this.id}-range`);if(e.length&&t.length){let s=this.parameterDef.min,l=this.parameterDef.max,c=(this.animationMin-s)/(l-s)*100,d=(this.animationMax-s)/(l-s)*100;e.css("left",`${c}%`),t.css("left",`${d}%`),o.css({left:`${c}%`,width:`${d-c}%`}),i.length&&i.text(this.formatter(this.animationMin)),r.length&&r.text(this.formatter(this.animationMax))}}updateAnimationUI(){let e=$(`#${this.id}-animation-bounds`),t=$(`#${this.id}-anim-btn`);this.animationEnabled?(e.slideDown(200),t.addClass("active"),t.attr("title","Disable animation (\u{1F3AC})"),this.updateBoundsDisplay(),setTimeout(()=>{this.updateAccordionHeight()},0),setTimeout(()=>{this.updateAccordionHeight()},250)):(e.slideUp(200),t.removeClass("active"),t.attr("title","Enable animation (\u{1F3AC})"),setTimeout(()=>{this.updateAccordionHeight()},250))}updateAccordionHeight(){fe("#transform-controls",0)}render(){let e=`${this.id}-display`,t=this.defaultValue;return`
            <div class="control-group">
                <label>
                    ${this.parameterDef.label}:
                    <span class="range-value" id="${e}">
                        ${this.formatter(t)}
                    </span>
                </label>
                <div class="slider-control">
                    <button class="slider-btn" data-slider="${this.id}" data-action="decrease-large">--</button>
                    <button class="slider-btn" data-slider="${this.id}" data-action="decrease">-</button>
                    <input type="range" id="${this.id}">
                    <button class="slider-btn" data-slider="${this.id}" data-action="increase">+</button>
                    <button class="slider-btn" data-slider="${this.id}" data-action="increase-large">++</button>
                    <button class="slider-btn anim-btn" id="${this.id}-anim-btn" title="Enable animation (\u{1F3AC})">\u{1F3AC}</button>
                </div>
                ${this.parameterDef.info?`<div class="info">${this.parameterDef.info}</div>`:""}
            </div>
        `}attachListeners(e){super.attachListeners(e),setTimeout(()=>{let t=$(`#${this.id}`);if(!t.length)return;let i=$(`#${this.id}-anim-btn`);if(!i.length)return;i.on("click",s=>{s.stopPropagation(),this.setAnimationEnabled(!this.animationEnabled)});let r=`
                <div id="${this.id}-animation-bounds" class="animation-bounds-slider" style="display: none;">
                    <div class="bounds-labels">
                        <span>Min: <span id="${this.id}-min-display">${this.formatter(this.animationMin)}</span></span>
                        <span>Max: <span id="${this.id}-max-display">${this.formatter(this.animationMax)}</span></span>
                    </div>
                    <div class="multi-thumb-slider">
                        <div class="slider-track"></div>
                        <div id="${this.id}-range" class="slider-range"></div>
                        <div id="${this.id}-current-indicator" class="slider-current-indicator"></div>
                        <div id="${this.id}-min-handle" class="slider-thumb min-thumb" data-bound="min">
                            <span class="thumb-label">MIN</span>
                        </div>
                        <div id="${this.id}-max-handle" class="slider-thumb max-thumb" data-bound="max">
                            <span class="thumb-label">MAX</span>
                        </div>
                    </div>
                </div>
            `,o=t.closest(".control-group");o.length?(o.after(r),this.attachThumbDragHandlers()):console.warn(`AnimatableParameterControl: Could not find .control-group parent for #${this.id}`)},0)}attachThumbDragHandlers(){let e=$(`#${this.id}-min-handle`),t=$(`#${this.id}-max-handle`),i=e.parent();[{handle:e,bound:"min"},{handle:t,bound:"max"}].forEach(({handle:o,bound:s})=>{let l=!1,c=0,d=0;o.on("mousedown",u=>{l=!0,c=u.pageX,d=parseFloat(o.css("left"))||0,o.addClass("dragging"),e.css("z-index","10"),t.css("z-index","10"),o.css("z-index","11"),$("body").css("user-select","none"),u.preventDefault()}),$(document).on("mousemove",u=>{if(!l)return;let h=i.offset(),g=i.width(),p=(u.pageX-h.left)/g*100;p=Math.max(0,Math.min(100,p));let x=this.parameterDef.min,y=this.parameterDef.max,b=x+p/100*(y-x);s==="min"?b<=this.animationMax&&(this.animationMin=b):b>=this.animationMin&&(this.animationMax=b),this.updateBoundsDisplay()}),$(document).on("mouseup",()=>{l&&(l=!1,o.removeClass("dragging"),$("body").css("user-select",""))})})}saveToSettings(e){super.saveToSettings(e),this.animationEnabled&&(e.animations||(e.animations={}),e.animations[this.settingsKey]={enabled:!0,min:this.animationMin,max:this.animationMax})}restoreFromSettings(e){if(super.restoreFromSettings(e),e.animations&&e.animations[this.settingsKey]){let t=e.animations[this.settingsKey];this.animationEnabled=t.enabled||!1,this.animationMin=t.min,this.animationMax=t.max,this.updateAnimationUI()}}};X();var yt=class extends q{constructor(e,t={}){super("dimension-inputs",e,t),this.dimensionsControl=null,this.varNames=["x","y","z","w","u","v"],this.coordinateSystem=null}setDimensionsControl(e){this.dimensionsControl=e}setCoordinateSystem(e,t=!0){this.coordinateSystem=e,e&&e.getDisplayLabels?this.varNames=e.getDisplayLabels():this.varNames=["x","y","z","w","u","v"],t&&this.updateInputs()}getDimensions(){return this.dimensionsControl?this.dimensionsControl.getValue():parseInt($("#dimensions").val())||2}getValue(){let e=this.getDimensions(),t=[];for(let i=0;i<e;i++){let r=$(`#expr-${i}`).val().trim();r&&window.UnicodeAutocomplete&&window.UnicodeAutocomplete.unicodeToAscii&&(r=window.UnicodeAutocomplete.unicodeToAscii(r)),t.push(r||"0")}return t}setValue(e){Array.isArray(e)&&this.updateInputs(e.length,e)}updateInputs(e=null,t=null){e===null&&(e=this.getDimensions()),a.verbose("updateInputs called with dimensions:",e);let i=$("#dimension-inputs");if(a.verbose("Container found:",i.length),i.length===0){a.error("Could not find #dimension-inputs element");return}let r;if(t&&Array.isArray(t))r=t,a.verbose("Using provided newValues");else{let o=$("#expr-0");a.verbose("firstElement exists:",o.length>0);try{o.length>0?(r=this.getValue(),a.verbose("Got current values from getValue()")):(r=this.defaultValue,a.verbose("Using defaultValue"))}catch(s){a.error("Error getting values:",s),r=this.defaultValue}}a.verbose("Values to use:",r),i.empty(),a.verbose("Container emptied, now creating",e,"inputs");for(let o=0;o<e;o++){let s=this.varNames[o],l=r[o]||this.defaultValue[o]||"0",c=$('<div class="dimension-input"></div>');c.append(`<label>d${s}/dt =</label>`),c.append(`<input type="text" id="expr-${o}" value="${l}">`),i.append(c),a.verbose("Created input",o,"with value:",l)}a.verbose("All inputs created, container now has",i.children().length,"children"),this.attachInputListeners(),window.unicodeAutocomplete&&window.unicodeAutocomplete.attachToAll('[id^="expr-"]'),this.updateAccordionHeight()}updateAccordionHeight(){fe("#dimension-inputs",0)}attachInputListeners(){let e=this.onChangeCallback;$(document).off("input",'[id^="expr-"]'),$(document).on("input",'[id^="expr-"]',()=>{this.onChange&&this.onChange(this.getValue()),e&&e()})}attachListeners(e){this.onChangeCallback=e,this.updateInputs(),this.attachInputListeners()}reset(){this.setValue(this.defaultValue)}},vt=class extends q{constructor(e,t={}){super("mapper-params",e,t),this.dimensionsControl=null,this.mapperControl=null,this.varNames=["x","y","z","w","u","v"]}setRelatedControls(e,t){this.dimensionsControl=e,this.mapperControl=t}getContext(){let e=this.dimensionsControl?this.dimensionsControl.getValue():2,t=this.mapperControl?this.mapperControl.getValue():"select";return{dimensions:e,mapper:t}}getValue(){let{mapper:e}=this.getContext();if(e==="custom"){let r=$("#mapper-horizontal-expr"),o=$("#mapper-vertical-expr"),s=$("#mapper-depth-expr");return r.length&&o.length?{horizontalExpr:r.val()||"x",verticalExpr:o.val()||"y",depthExpr:s.val()||""}:this.currentParams||{horizontalExpr:"x",verticalExpr:"y",depthExpr:""}}let t=$("#mapper-dim1"),i=$("#mapper-dim2");if(t.length&&i.length){let r=parseInt(t.val()),o=parseInt(i.val());return isNaN(r)||isNaN(o)?(console.warn("Invalid mapper dimensions, using defaults"),this.defaultValue):{dim1:r,dim2:o}}return this.defaultValue}setValue(e){this.currentParams=e,this.updateControls()}updateControls(){let{dimensions:e,mapper:t}=this.getContext(),i=$("#mapper-controls");if(i.length!==0){if(i.empty(),t==="select"){let r=$('<div class="control-row"></div>'),o=$('<div class="control-group" style="flex: 1;"></div>');o.append("<label>Horizontal</label>");let s=$('<select id="mapper-dim1"></select>'),l=this.currentParams?this.currentParams.dim1:this.defaultValue.dim1;for(let h=0;h<e;h++){let g=h===l?"selected":"";s.append(`<option value="${h}" ${g}>${this.varNames[h]}</option>`)}o.append(s);let c=$('<div class="control-group" style="flex: 1;"></div>');c.append("<label>Vertical</label>");let d=$('<select id="mapper-dim2"></select>'),u=this.currentParams?this.currentParams.dim2:this.defaultValue.dim2;for(let h=0;h<e;h++){let g=h===u?"selected":"";d.append(`<option value="${h}" ${g}>${this.varNames[h]}</option>`)}c.append(d),r.append(o),r.append(c),i.append(r),this.attachSelectListeners()}else if(t==="project"){let r=$('<div class="info">Linear projection uses default 2D projection</div>');i.append(r)}else if(t==="custom"){let r=this.varNames.slice(0,e).join(", "),o=$('<div class="control-group"></div>');o.append("<label>Horizontal (X):</label>");let s=this.currentParams?.horizontalExpr||"x",l=$(`<input type="text" id="mapper-horizontal-expr" value="${s}" placeholder="e.g., sin(x) + sin(y)" style="font-family: monospace; width: 100%;" />`);o.append(l),i.append(o);let c=$('<div class="control-group"></div>');c.append("<label>Vertical (Y):</label>");let d=this.currentParams?.verticalExpr||"y",u=$(`<input type="text" id="mapper-vertical-expr" value="${d}" placeholder="e.g., -cos(x) - cos(y)" style="font-family: monospace; width: 100%;" />`);c.append(u),i.append(c);let h=$('<div class="control-group"></div>');h.append("<label>Depth (Z, optional):</label>");let g=this.currentParams?.depthExpr||"",f=$(`<input type="text" id="mapper-depth-expr" value="${g}" placeholder="optional, e.g., z" style="font-family: monospace; width: 100%;" />`);h.append(f),i.append(h);let p=$('<div class="info">Define math expressions using variables: '+r+". Functions: sin, cos, tan, exp, log, sqrt, abs, etc.</div>");i.append(p),this.attachCustomListener()}}}attachSelectListeners(){let e=this.onChangeCallback;$(document).off("change","#mapper-dim1, #mapper-dim2"),$("#mapper-dim1, #mapper-dim2").on("change",()=>{this.currentParams=this.getValue(),this.onChange&&this.onChange(this.currentParams),e&&e()})}attachCustomListener(){let e=this.onChangeCallback;$(document).off("input","#mapper-horizontal-expr, #mapper-vertical-expr, #mapper-depth-expr"),$("#mapper-horizontal-expr, #mapper-vertical-expr, #mapper-depth-expr").on("input",()=>{this.currentParams=this.getValue(),this.onChange&&this.onChange(this.currentParams),e&&e()})}attachListeners(e){this.onChangeCallback=e,this.currentParams=this.defaultValue,this.updateControls()}reset(){this.currentParams=this.defaultValue,this.updateControls()}},$t=class extends q{constructor(e,t={}){super("color-gradient",e,t),this.gradientEditor=null}setGradientEditor(e){this.gradientEditor=e}getValue(){return this.gradientEditor&&this.gradientEditor.getGradient?this.gradientEditor.getGradient():this.currentGradient||this.defaultValue}setValue(e){this.currentGradient=e,this.gradientEditor&&this.gradientEditor.setGradient&&this.gradientEditor.setGradient(e)}attachListeners(e){this.onChangeCallback=e}notifyChange(e){this.currentGradient=e,this.onChange&&this.onChange(e),this.onChangeCallback&&this.onChangeCallback()}reset(){this.setValue(this.defaultValue)}saveToSettings(e){e[this.settingsKey]=this.getValue()}restoreFromSettings(e){e&&e[this.settingsKey]!==void 0&&this.setValue(e[this.settingsKey])}},_t=class extends q{constructor(e,t={}){super("transform-params",e,t),this.transformControl=null,this.currentParams=e||{},this.parameterControls=new Map}setTransformControl(e){this.transformControl=e}getTransformType(){return this.transformControl?this.transformControl.getValue():"identity"}getValue(){let e={};for(let[t,i]of this.parameterControls.entries()){let r=i.settingsKey;e[r]=i.getValue()}return e}setValue(e){this.currentParams=e||{},this.updateControls()}updateControls(){let e=this.getTransformType(),t=$("#transform-controls");if(t.length===0)return;t.empty(),this.parameterControls.clear();let i=ht(e);if(!i){a.warn(`Transform not found: ${e}`),this.updateAccordionHeight();return}let r=i.getParameters();if(r.length===0){this.updateAccordionHeight();return}r.forEach((o,s)=>{let l=`transform-param-${s}`,c=this.currentParams[o.name]??o.default,d=new Be(l,o,c,{settingsKey:o.name,onChange:u=>{this.currentParams[o.name]=u,this.onChange&&this.onChange(this.currentParams)}});t.append(d.render()),d.attachListeners(this.onChangeCallback),this.parameterControls.set(l,d)}),this.updateAccordionHeight()}updateAccordionHeight(){fe("#transform-controls",0)}handleTransformParamButton(e,t){let i=this.parameterControls.get(e);return i?i.handleButtonAction(t):!1}attachListeners(e){this.onChangeCallback=e,this.updateControls()}reset(){this.currentParams=this.defaultValue,this.updateControls()}saveToSettings(e){e[this.settingsKey]=this.getValue()}restoreFromSettings(e){e&&e[this.settingsKey]!==void 0&&this.setValue(e[this.settingsKey])}};function fr(n,e,t){let i=$(`#${n}`);if(!i.length)return console.error(`Gradient editor container #${n} not found`),null;let r=e.map(d=>({...d}));function o(){let d=[...r].sort((h,g)=>h.position-g.position),u='<div class="gradient-stops">';d.forEach((h,g)=>{let f=r.indexOf(h),p=ti(h.color);u+=`
                <div class="gradient-stop" data-index="${f}">
                    <input type="color" class="color-picker" value="${p}" data-index="${f}">
                    <input type="number" class="stop-position" min="0" max="1" step="0.01" value="${h.position.toFixed(2)}" data-index="${f}">
                    ${r.length>2?`<button class="remove-stop" data-index="${f}">\xD7</button>`:""}
                </div>
            `}),u+="</div>",u+='<button id="add-stop" class="secondary" style="margin-top: 5px;">Add Color Stop</button>',u+='<div class="gradient-preview" id="gradient-preview"></div>',i.html(u),s(),l()}function s(){let d=$("#gradient-preview");if(!d.length)return;let h=[...r].sort((g,f)=>g.position-f.position).map(g=>`${ti(g.color)} ${(g.position*100).toFixed(1)}%`).join(", ");d.css("background",`linear-gradient(to right, ${h})`)}function l(){$(".color-picker").off("change").on("change",function(){let d=parseInt($(this).data("index")),u=$(this).val();r[d].color=er(u),s(),t(r)}),$(".stop-position").off("change").on("change",function(){let d=parseInt($(this).data("index")),u=parseFloat($(this).val());u=Math.max(0,Math.min(1,u)),r[d].position=u,o(),t(r)}),$(".remove-stop").off("click").on("click",function(){let d=parseInt($(this).data("index"));r.length>2&&(r.splice(d,1),o(),t(r))}),$("#add-stop").off("click").on("click",function(){let d=[...r].sort((p,x)=>p.position-x.position),u=.5,h=0,g=.5;for(let p=0;p<d.length-1;p++){let x=d[p+1].position-d[p].position;x>h&&(h=x,g=(d[p].position+d[p+1].position)/2)}u=g;let f=c(r,u);r.push({position:u,color:f}),o(),t(r)})}function c(d,u){let h=[...d].sort((g,f)=>g.position-f.position);if(u<=h[0].position)return[...h[0].color];if(u>=h[h.length-1].position)return[...h[h.length-1].color];for(let g=0;g<h.length-1;g++)if(u>=h[g].position&&u<=h[g+1].position){let f=h[g].position,p=h[g+1].position,x=(u-f)/(p-f),y=h[g].color,b=h[g+1].color;return[y[0]+(b[0]-y[0])*x,y[1]+(b[1]-y[1])*x,y[2]+(b[2]-y[2])*x]}return[.5,.5,.5]}return o(),{getGradient:()=>r.map(d=>({...d})),setGradient:d=>{r=d.map(u=>({...u})),o()}}}Le();X();function pr(n,e,t,i){if(a.info("=== SYMBOLIC INVERSE SOLVING ==="),a.info("Forward transforms:",n),a.info("Cartesian vars:",t),a.info("Native vars:",i),!window.nerdamer)return a.error("Nerdamer not loaded - cannot solve inverse symbolically"),null;try{window.nerdamer.clear&&window.nerdamer.clear("all");let r=[];if(e===2&&mo(n))return a.info("Detected 2D polar coordinates - using standard inverse"),[`${i[0]}*cos(${i[1]})`,`${i[0]}*sin(${i[1]})`];if(e===3&&fo(n))return a.info("Detected 3D cylindrical coordinates - using standard inverse"),[`${i[0]}*cos(${i[1]})`,`${i[0]}*sin(${i[1]})`,i[2]];if(e===3&&po(n))return a.info("Detected 3D spherical coordinates - using standard inverse"),[`${i[0]}*sin(${i[1]})*cos(${i[2]})`,`${i[0]}*sin(${i[1]})*sin(${i[2]})`,`${i[0]}*cos(${i[1]})`];a.info("Attempting general symbolic solve...");for(let o=0;o<e;o++){let s=t[o],l=null;for(let c=0;c<e;c++){let d=i[c],u=n[c];try{let h=`${d} - (${u})`,g=window.nerdamer.solve(h,s);if(g){let f=g.toString();if(a.verbose(`Solved ${s} from equation ${c}:`,f),!t.some((x,y)=>y!==o&&f.includes(x))){l=f;break}}}catch(h){a.verbose(`Failed to solve ${s} from equation ${c}:`,h.message)}}if(!l)return a.warn(`Could not solve for ${s} - symbolic solving failed`),null;r.push(l)}return a.info("Successfully solved inverse transforms:",r),r}catch(r){return a.error("Symbolic inverse solving failed:",r.message),null}}function mo(n){if(n.length!==2)return!1;let e=n[0],t=n[1],i=/sqrt\s*\(\s*x\s*\^?\*?\*?\s*2\s*\+\s*y\s*\^?\*?\*?\s*2/.test(e),r=/atan2\s*\(\s*y\s*,\s*x\s*\)/.test(t);return i&&r}function fo(n){if(n.length!==3)return!1;let e=n[0],t=n[1],i=n[2],r=/sqrt\s*\(\s*x\s*\^?\*?\*?\s*2\s*\+\s*y\s*\^?\*?\*?\s*2/.test(e),o=/atan2\s*\(\s*y\s*,\s*x\s*\)/.test(t),s=i.trim()==="z";return r&&o&&s}function po(n){if(n.length!==3)return!1;let e=n[0],t=n[1],i=n[2],r=/sqrt\s*\(\s*x\s*\^?\*?\*?\s*2\s*\+\s*y\s*\^?\*?\*?\s*2\s*\+\s*z\s*\^?\*?\*?\s*2/.test(e),o=/acos/.test(t),s=/atan2\s*\(\s*y\s*,\s*x\s*\)/.test(i);return r&&o&&s}function go(n,e,t,i){let r=$(`#${n}`);if(!r.length)return console.error(`Coordinate editor container #${n} not found`),null;let o=t||ue(e),s=e,l={render:c,update:h,getCurrentSystem:()=>o,setDimensions:g};function c(){let f=ii(s),p='<div class="coordinate-editor-content">';p+='<div class="control-group">',p+='<label for="coord-preset">Preset</label>',p+='<select id="coord-preset">';let x="custom";for(let[b,v]of Object.entries(Ae))if(v.name===o.name&&v.dimensions===o.dimensions){x=b;break}p+='<option value="custom">Custom</option>',f.forEach(({key:b,system:v})=>{p+=`<option value="${b}" ${b===x?"selected":""}>${v.name}</option>`}),p+="</select>",p+="</div>",p+='<div class="coordinate-variables">',p+='<div style="font-weight: bold;">Coordinate Variables:</div>';for(let b=0;b<s;b++){let v=o.variables[b]||{label:"x",displayLabel:"x"},w=o.forwardTransforms[b]||"x",S=["x","y","z","w","u","v"][b];p+='<div class="coord-var-row">',p+=`<input type="text" class="coord-var-label" data-index="${b}" value="${v.displayLabel}" placeholder="${S}" title="Variable label (can use Greek letters like \u03B8)">`,p+="<span>=</span>",p+=`<input type="text" class="coord-var-transform coord-math-input" data-index="${b}" value="${w}" placeholder="${S}" title="Transformation expression in Cartesian coordinates">`,p+="</div>"}p+="</div>",p+='<div class="coordinate-inverse">',p+='<div style="font-weight: bold; margin-top: 15px;">Inverse Transform (Native \u2192 Cartesian):</div>';let y=o.useIterativeSolver||!1;for(let b=0;b<s;b++){let v=["x","y","z","w","u","v"][b],w=o.inverseTransforms&&o.inverseTransforms[b]?o.inverseTransforms[b]:"",S=o.variables.map(M=>M.label||M.displayLabel).join(", ");p+='<div class="coord-var-row">',p+=`<span style="min-width: 20px;">${v}</span>`,p+="<span>=</span>",p+=`<input type="text" class="coord-inverse-transform coord-math-input" data-index="${b}" value="${w}" placeholder="(e.g., r*cos(theta))" title="Inverse transformation from native coordinates" ${y?"disabled":""}>`,p+="</div>"}p+="</div>",p+='<div class="coordinate-tools" style="margin-top: 10px;">',p+='<button id="coord-solve-inverse" class="secondary" title="Attempt to solve inverse transforms automatically using symbolic math">\u26A1 Solve Inverse Symbolically</button>',p+='<div style="margin-top: 8px;">',p+='<label style="display: flex; align-items: center; font-size: 0.9em;">',p+=`<input type="checkbox" id="coord-use-iterative" ${y?"checked":""} style="margin-right: 5px;">`,p+=`<span title="Use GPU-based Newton's method to compute inverse. Slower but works for any transform.">Use iterative Newton solver (GLSL)</span>`,p+="</label>",p+="</div>",p+="</div>",p+='<div class="info-text" style="margin-top: 15px;">',p+="<strong>Forward Transform:</strong> Define each native coordinate in terms of Cartesian variables (x, y, z, w, ...). ",p+="<strong>Inverse Transform:</strong> Define each Cartesian coordinate in terms of native variables. ",p+='Use the "Solve" button to attempt automatic computation, or enable iterative solver for complex transforms. ',p+='Type "theta", "phi", etc. to insert Greek letters.',p+="</div>",p+='<div class="coordinate-editor-buttons">',p+='<button id="coord-apply" class="primary">Apply</button>',p+='<button id="coord-cancel" class="secondary">Cancel</button>',p+="</div>",p+="</div>",r.html(p),d(),window.unicodeAutocomplete&&($(".coord-math-input").each(function(){window.unicodeAutocomplete.attach(this)}),$(".coord-var-label").each(function(){window.unicodeAutocomplete.attach(this)}))}function d(){$("#coord-preset").off("change").on("change",function(){let f=$(this).val();if(f==="custom")return;let p=Ae[f];p&&(o=p,c())}),$(".coord-var-label").off("input").on("input",function(){let f=parseInt($(this).data("index")),p=$(this).val().trim();o.variables[f]||(o.variables[f]={label:"",displayLabel:""}),o.variables[f].displayLabel=p,o.variables[f].label=p,$("#coord-preset").val("custom")}),$(".coord-var-transform").off("input").on("input",function(){let f=parseInt($(this).data("index")),p=$(this).val().trim();o.forwardTransforms[f],o.forwardTransforms[f]=p,$("#coord-preset").val("custom")}),$(".coord-inverse-transform").off("input").on("input",function(){let f=parseInt($(this).data("index")),p=$(this).val().trim();o.inverseTransforms||(o.inverseTransforms=new Array(s).fill("")),o.inverseTransforms[f]=p,$("#coord-preset").val("custom")}),$("#coord-solve-inverse").off("click").on("click",function(){let f=$(this);f.prop("disabled",!0);let p=f.text();f.text("Solving...");try{let x=["x","y","z","w","u","v"].slice(0,s),y=o.variables.map(v=>v.label||v.displayLabel),b=pr(o.forwardTransforms,s,x,y);b?(o.inverseTransforms=b,$(".coord-inverse-transform").each(function(){let v=parseInt($(this).data("index"));$(this).val(b[v])}),f.text("\u2713 Solved!"),setTimeout(()=>{f.text(p),f.prop("disabled",!1)},1500)):(alert(`Could not solve inverse transforms symbolically. You can:
1. Define the inverse transforms manually
2. Enable "Use iterative Newton solver" checkbox`),f.text(p),f.prop("disabled",!1)),$("#coord-preset").val("custom")}catch(x){console.error("Error solving inverse:",x),alert("Error solving inverse: "+x.message),f.text(p),f.prop("disabled",!1)}}),$("#coord-use-iterative").off("change").on("change",function(){let f=$(this).is(":checked");o.useIterativeSolver=f,$(".coord-inverse-transform").prop("disabled",f),f?$(".coord-inverse-transform").css("opacity","0.5"):$(".coord-inverse-transform").css("opacity","1.0"),$("#coord-preset").val("custom")}),$("#coord-apply").off("click").on("click",function(){let f=$(this);f.prop("disabled",!0);let p=f.text();f.text("Applying...");try{if(u()){let y=o.forwardTransforms.map(w=>window.UnicodeAutocomplete&&window.UnicodeAutocomplete.unicodeToAscii?window.UnicodeAutocomplete.unicodeToAscii(w):w),b=o.inverseTransforms?o.inverseTransforms.map(w=>window.UnicodeAutocomplete&&window.UnicodeAutocomplete.unicodeToAscii?window.UnicodeAutocomplete.unicodeToAscii(w):w):null,v=new j(o.name,o.dimensions,o.variables,y,b,o.useIterativeSolver||!1);setTimeout(()=>{i(v),f.prop("disabled",!1),f.text(p)},100)}else alert("Invalid coordinate system. Please check your expressions."),f.prop("disabled",!1),f.text(p)}catch(x){console.error("Error in apply handler:",x),f.prop("disabled",!1),f.text(p)}}),$("#coord-cancel").off("click").on("click",function(){i(null)})}function u(){for(let f=0;f<s;f++)if(!o.variables[f]||!o.variables[f].label||!o.forwardTransforms[f]||o.forwardTransforms[f].trim()==="")return!1;return!0}function h(f){o=f,c()}function g(f){f!==s&&(s=f,o=ue(f),c())}return c(),l}function gr(n,e,t){let i=$("#coordinate-editor-panel");i.length||($("body").append(`
            <div id="coordinate-editor-panel" class="floating-panel" style="display: none;">
                <div class="panel-header">
                    <h3>Coordinate System</h3>
                    <button class="panel-close">&times;</button>
                </div>
                <div id="coordinate-editor-container" class="panel-content">
                </div>
            </div>
        `),i=$("#coordinate-editor-panel")),i.show();let r=go("coordinate-editor-container",n,e,c=>{c===null||t(c),i.hide()});$(".panel-close",i).off("click").on("click",function(){i.hide()});let o=!1,s=0,l=0;return $(".panel-header",i).off("mousedown").on("mousedown",function(c){o=!0,s=c.clientX-i.offset().left,l=c.clientY-i.offset().top,$(document).on("mousemove.panelDrag",function(d){o&&i.css({left:d.clientX-s,top:d.clientY-l})})}),$(document).on("mouseup.panelDrag",function(){o=!1,$(document).off("mousemove.panelDrag")}),r}Le();X();function yr(n,e){let t=new bt({renderer:n,storageKey:"vectorFieldSettings",debounceTime:300,onApply:m=>{m.implicitIterations!==void 0&&(m.integratorParams={iterations:m.implicitIterations}),n.updateConfig(m);let _=t.getSettings();n&&n.bbox&&(_.bbox={min:[...n.bbox.min],max:[...n.bbox.max]}),n&&n.coordinateSystem&&(_.coordinateSystem=n.coordinateSystem.toJSON()),localStorage.setItem("vectorFieldSettings",JSON.stringify(_)),$o()}}),i=t.register(new ee("dimensions",2,{min:2,max:6,step:1,displayId:"dim-value",displayFormat:m=>m.toFixed(0),onChange:m=>{a.verbose("Dimensions changed to:",m);let _=t.get("dimension-inputs");_&&n.coordinateSystem?(a.verbose("Updating dimension inputs with dimensions:",m),n.coordinateSystem.dimensions===m?(_.setCoordinateSystem(n.coordinateSystem),_.updateInputs(m)):a.warn(`Coordinate system dimension mismatch: ${n.coordinateSystem.dimensions}D coordinate system with ${m}D expressions - update coordinate system or expressions to match`)):a.verbose("Preserving existing coordinate system:",n.coordinateSystem.name);let T=t.get("mapper-params");T&&T.updateControls()}})),r=t.register(new ce("integrator","rk2",{settingsKey:"integratorType",onChange:m=>{let _=m.startsWith("implicit-")||m==="trapezoidal";$("#implicit-iterations-group").toggle(_),$("#solution-method-group").toggle(_),fe("#integrator",0)}})),o=t.register(new ce("solution-method","fixed-point",{settingsKey:"solutionMethod"})),s=t.register(new xt("timestep",.01,{min:.001,max:2.5,step:.001,smallIncrement:.001,largeIncrement:.01,displayId:"timestep-value",displayFormat:m=>m.toFixed(4),animationMin:.001,animationMax:.1})),l=t.register(new ee("implicit-iterations",4,{settingsKey:"implicitIterations",min:1,max:10,step:1,displayId:"implicit-iterations-value",displayFormat:m=>m.toFixed(0)})),c=t.register(new ee("particles",1e3,{settingsKey:"particleCount",min:100,max:5e6,step:1e4,displayId:"particles-value",displayFormat:m=>m.toFixed(0)})),d=t.register(new we("fade",.999,{settingsKey:"fadeOpacity",min:0,max:100,step:.1,displayId:"fade-value",displayFormat:m=>m.toFixed(4),transform:m=>{let _=Math.log(.9),P=(Math.log(.9999)-_)/100;return Math.exp(_+P*m)},inverseTransform:m=>{let _=Math.log(.9),P=(Math.log(.9999)-_)/100;return(Math.log(m)-_)/P},animationMin:.95,animationMax:.9995})),u=t.register(new ee("drop",0,{settingsKey:"dropProbability",min:0,max:.1,step:.001,displayId:"drop-value",displayFormat:m=>m.toFixed(4)})),h=t.register(new W("drop-low-velocity",!1,{settingsKey:"dropLowVelocity"})),g=t.register(new ce("transform","identity",{settingsKey:"transformType",onChange:m=>{let _=t.get("transform-params");_&&_.updateControls()}}));t.register(new _t({},{settingsKey:"transformParams"})).setTransformControl(g);let p=t.register(new ce("mapper","select",{settingsKey:"mapperType",onChange:m=>{let _=t.get("mapper-params");_&&_.updateControls()}}));t.register(new vt({dim1:0,dim2:1},{settingsKey:"mapperParams"})).setRelatedControls(i,p);let y=t.register(new ce("color-mode","velocity_angle",{settingsKey:"colorMode",onChange:m=>{br(m),li(m),xr(m)}})),b=t.register(new gt("color-expression","x * y",{settingsKey:"colorExpression"})),v=t.register(new W("use-custom-gradient",!1,{settingsKey:"useCustomGradient"})),w=t.register(new $t(mt(),{settingsKey:"colorGradient"})),S=t.register(new ce("velocity-scale-mode","percentile95",{settingsKey:"velocityScaleMode"})),M=t.register(new W("velocity-log-scale",!1,{settingsKey:"velocityLogScale"})),E=t.register(new yt(["-y","x"],{settingsKey:"expressions"}));E.setDimensionsControl(i),E.setCoordinateSystem(n.coordinateSystem,!1);let R=t.register(new W("use-hdr",!0,{settingsKey:"useHDR"})),I=t.register(new W("use-depth-test",!1,{settingsKey:"useDepthTest"})),B=t.register(new ee("supersample-factor",1,{min:.5,max:4,step:.5,displayId:"supersample-factor-value",displayFormat:m=>m.toFixed(1)+"x",settingsKey:"supersampleFactor"})),z=t.register(new W("smaa-enabled",!0,{settingsKey:"smaaEnabled"})),K=t.register(new he("smaa-intensity",.75,{displayId:"smaa-intensity-value",displayFormat:m=>m.toFixed(2)})),F=t.register(new he("smaa-threshold",.1,{displayId:"smaa-threshold-value",displayFormat:m=>m.toFixed(2)})),A=t.register(new W("bilateral-enabled",!1,{settingsKey:"bilateralEnabled"}));class C extends ee{getValue(){let _=$(`#${this.id}`);return parseFloat(_.val())/20}setValue(_){$(`#${this.id}`).val(_*20),this.updateDisplay(_)}}let V=t.register(new C("bilateral-spatial",4,{min:10,max:100,step:1,displayId:"bilateral-spatial-value",displayFormat:m=>m.toFixed(1),settingsKey:"bilateralSpatialSigma"}));class D extends ee{getValue(){let _=$(`#${this.id}`);return parseFloat(_.val())/100}setValue(_){$(`#${this.id}`).val(_*100),this.updateDisplay(_)}}let k=t.register(new D("bilateral-intensity",.2,{min:1,max:50,step:.1,displayId:"bilateral-intensity-value",displayFormat:m=>m.toFixed(2),settingsKey:"bilateralIntensitySigma"})),U=t.register(new ce("tonemap-operator","aces",{settingsKey:"tonemapOperator",onChange:m=>{ai(m)}})),G=t.register(new le("exposure",1,{minValue:1e-4,maxValue:10,displayId:"exposure-value",displayFormat:m=>m.toFixed(4)})),Y=t.register(new le("gamma",2.2,{minValue:.2,maxValue:10,displayId:"gamma-value",displayFormat:m=>m.toFixed(2)})),Re=t.register(new le("luminance-gamma",1,{settingsKey:"luminanceGamma",minValue:.2,maxValue:10,displayId:"luminance-gamma-value",displayFormat:m=>m.toFixed(2)})),At=t.register(new le("highlight-compression",0,{settingsKey:"highlightCompression",minValue:0,maxValue:10,displayId:"highlight-compression-value",displayFormat:m=>m.toFixed(2)})),fi=t.register(new le("compression-threshold",1,{settingsKey:"compressionThreshold",minValue:1e-4,maxValue:1e5,displayId:"compression-threshold-value",displayFormat:m=>m.toFixed(2)})),pi=t.register(new le("white-point",2,{settingsKey:"whitePoint",minValue:1,maxValue:1e3,displayId:"white-point-value",displayFormat:m=>m.toFixed(2)})),So=t.register(new le("particle-intensity",1,{settingsKey:"particleIntensity",minValue:.001,maxValue:100,displayId:"particle-intensity-value",displayFormat:m=>m.toFixed(3)})),Fo=t.register(new le("particle-size",1,{settingsKey:"particleSize",minValue:.1,maxValue:10,displayId:"particle-size-value",displayFormat:m=>m.toFixed(1)})),Ao=t.register(new ce("particle-render-mode","points",{settingsKey:"particleRenderMode"})),Ro=t.register(new he("color-saturation",1,{settingsKey:"colorSaturation",displayId:"color-saturation-value",displayFormat:m=>m.toFixed(2)})),Co=t.register(new he("brightness-desat",0,{settingsKey:"brightnessDesaturation",displayId:"brightness-desat-value",displayFormat:m=>m.toFixed(2)})),Mo=t.register(new he("saturation-buildup",0,{settingsKey:"brightnessSaturation",displayId:"saturation-buildup-value",displayFormat:m=>m.toFixed(2)})),Po=t.register(new W("bloom-enabled",!1,{settingsKey:"bloomEnabled"})),Lo=t.register(new he("bloom-intensity",.3,{settingsKey:"bloomIntensity",min:0,max:200,displayId:"bloom-intensity-value",displayFormat:m=>m.toFixed(2)})),Do=t.register(new ee("bloom-radius",1,{settingsKey:"bloomRadius",min:.5,max:3,step:.1,displayId:"bloom-radius-value",displayFormat:m=>m.toFixed(1)})),Bo=t.register(new he("bloom-alpha",1,{settingsKey:"bloomAlpha",displayId:"bloom-alpha-value",displayFormat:m=>m.toFixed(2)})),_r=t.register(new W("frame-limit-enabled",!1,{settingsKey:"frameLimitEnabled",onChange:m=>{if(window.renderer&&(window.renderer.frameLimitEnabled=m,m)){let _=gi.getValue();window.renderer.frameLimit=_,a.info(`Frame limit enabled: will stop at ${_} frames`)}}})),gi=t.register(new le("frame-limit",1e3,{minValue:100,maxValue:1e5,displayId:"frame-limit-value",displayFormat:m=>m>=1e3?`${Math.floor(m/1e3)}k`:Math.floor(m).toString(),settingsKey:"frameLimit",onChange:m=>{window.renderer&&(window.renderer.frameLimit=m,a.verbose(`Frame limit updated to: ${m} frames`))}})),ve=!1,Ce=null,Rt=1,bi=10,Ie=0,Je=!1,xi=95,Ct=.002,yi=xi/(100-xi)*Ct,wr=3,Er=10,te=null,Mt=null,Pt=0,qe=0,Ee=null,Te=null,ie=null,Ke=null,Io=new Set(["expressions","dimensions","integratorType","solutionMethod","transformType","transformParams","mapperType","mapperParams","colorMode"]),Lt=$("#animation-alpha-container");a.info(`Animation alpha container found: ${Lt.length>0}`),Lt.length?(Lt.html(`
            <div class="control-group">
                <label>Animation Alpha (a): <span class="range-value" id="animation-alpha-value">0.00%</span></label>
                <div class="slider-control">
                    <button class="slider-btn" data-slider="animation-alpha" data-action="decrease">-</button>
                    <input type="range" id="animation-alpha">
                    <button class="slider-btn" data-slider="animation-alpha" data-action="increase">+</button>
                    <button class="slider-btn" data-slider="animation-alpha" data-action="reset" title="Reset to 0.0">\u21BA</button>
                    <button id="animation-alpha-animate-btn" class="slider-btn" style="margin-left: 8px; background: #4CAF50; color: white;" title="Auto-animate">\u25B6</button>
                </div>
                <div class="info">Test time-based expressions with the 'a' variable (0.0 - 1.0). Use in expressions like: sin(x + a*PI), 0.01 + a*0.09</div>
            </div>
        `),a.info("Animation alpha control HTML injected")):a.warn("Animation alpha container not found!");let vi=$("#animation-speed-container");vi.length&&vi.html(`
            <div class="control-group">
                <label>Steps per Alpha Increment: <span class="range-value" id="animation-speed-value">10</span></label>
                <div class="slider-control">
                    <button class="slider-btn" data-slider="animation-speed" data-action="decrease">-</button>
                    <input type="range" id="animation-speed">
                    <button class="slider-btn" data-slider="animation-speed" data-action="increase">+</button>
                    <button class="slider-btn" data-slider="animation-speed" data-action="reset" title="Reset to 10">\u21BA</button>
                </div>
                <div class="info">Integration steps to perform before incrementing alpha by 0.01</div>
            </div>
        `);let $i=t.register(new he("animation-alpha",0,{settingsKey:"animationAlpha",displayId:"animation-alpha-value",displayFormat:m=>`${(m*100).toFixed(2)}%`,onChange:m=>{t.controls.forEach(T=>{T instanceof we&&T.animationEnabled&&T.updateFromAlpha(m)});let _=t.controls.get("transform-params");_&&_.parameterControls&&_.parameterControls.forEach(T=>{T.animationEnabled&&T.updateFromAlpha(m)}),window.renderer&&(window.renderer.setAnimationAlpha(m),$("#animation-clear-particles").is(":checked")&&window.renderer.resetParticles(),$("#animation-clear-screen").is(":checked")&&window.renderer.clearRenderBuffer())}})),Uo=t.register(new ee("animation-speed",10,{min:1,max:200,displayId:"animation-speed-value",displayFormat:m=>(bi=Math.round(m),Math.round(m).toString())}));t.register(new W("animation-clear-particles",!1,{settingsKey:"animationClearParticles"})),t.register(new W("animation-clear-screen",!1,{settingsKey:"animationClearScreen"})),t.register(new W("animation-smooth-timing",!1,{settingsKey:"animationSmoothTiming"})),t.register(new W("animation-lock-shaders",!1,{settingsKey:"animationLockShaders"})),a.info("Animation alpha control registered");let zo=t.register(new ce("theme-selector","dark",{settingsKey:"theme",onChange:m=>{m==="light"?$("body").addClass("light-theme"):$("body").removeClass("light-theme"),t.saveToStorage()}}));$("#preset-selector").on("change",function(){let m=$(this).val();m&&(di(m,t),$(this).val(""),We()[m]?($("#preset-name-input").val(m),$("#delete-preset-btn").show()):($("#preset-name-input").val(""),$("#delete-preset-btn").hide()))}),$("#save-preset-btn").on("click",function(){let m=$("#preset-name-input").val().trim();if(!m){alert("Please enter a preset name");return}let T={...t.getSettings(),name:m};wo(m,T),ci(),$("#delete-preset-btn").show(),a.info("Preset saved: "+m)}),$("#delete-preset-btn").on("click",function(){let m=$("#preset-name-input").val().trim();m&&confirm(`Delete preset "${m}"?`)&&(Eo(m),ci(),$("#preset-name-input").val(""),$("#delete-preset-btn").hide(),a.info("Preset deleted: "+m))}),ci(),$("#default-settings").on("click",function(){t.resetAll(),t.clearStorage(),t.apply()}),$("#share-url").on("click",function(){let m=t.getSettings();vo(m)}),$("#reset").on("click",function(){let m=n.gl.canvas,P=10*(m.width/m.height);n.updateConfig({bbox:{min:[-P/2,-5],max:[P/2,5]},reinitializeParticles:!0})}),$("#reset-particles").on("click",function(){n.clearScreen()}),$("#save-image").on("click",async function(){try{let m=await n.captureRenderBuffer(),_=URL.createObjectURL(m),T=document.createElement("a"),P=new Date().toISOString().replace(/[:.]/g,"-").slice(0,-5),Z=`${n.renderWidth}x${n.renderHeight}`;T.download=`vector-field-${P}-${Z}.png`,T.href=_,document.body.appendChild(T),T.click(),document.body.removeChild(T),URL.revokeObjectURL(_),a.info("Image saved: "+T.download)}catch(m){a.error("Failed to save image:",m),alert("Failed to save image. Check console for details.")}});let Tr=new URLSearchParams(window.location.search).get("storage")||"float";$("#storage-strategy").val(Tr),$("#storage-strategy").on("change",function(){let m=$(this).val(),_=t.getSettings();n&&n.bbox&&(_.bbox={min:[...n.bbox.min],max:[...n.bbox.max]}),n&&n.coordinateSystem&&(_.coordinateSystem=n.coordinateSystem.toJSON()),localStorage.setItem("vectorFieldSettings",JSON.stringify(_));let T=new URL(window.location);T.searchParams.set("storage",m),window.location.href=T.toString()}),$(document).on("click",".slider-btn",function(){let m=$(this).data("slider"),_=$(this).data("action"),T=t.get(m);if(T&&T.handleButtonAction){T.handleButtonAction(_);return}if(m.startsWith("transform-param-")){let P=t.get("transform-params");P&&P.handleTransformParamButton&&P.handleTransformParamButton(m,_);return}console.warn(`No button handler found for slider: ${m}`)});let Ye=null;function Sr(){let m=$("#gradient-panel");li(t.get("color-mode").getValue()),m.show(),Ye?Ye.setGradient(w.getValue()):(Ye=fr("main-gradient-editor",w.getValue(),_=>{w.notifyChange(_)}),w.setGradientEditor(Ye))}function Fr(){$("#gradient-panel").hide()}$("#open-gradient-editor").on("click",function(){Sr()}),$("#configure-coordinates").on("click",function(){let m=n.dimensions,_=n.coordinateSystem;(!_||_.dimensions!==m)&&(console.warn("Coordinate system dimension mismatch, resetting to Cartesian"),_=ue(m),n.coordinateSystem=_),gr(m,_,T=>{n.updateConfig({coordinateSystem:T}),E.setCoordinateSystem(T),t.apply()})}),$(document).on("click",function(m){let _=$("#gradient-panel"),T=$("#open-gradient-editor");$(m.target).is(T)||$(m.target).closest("#gradient-panel").length>0||_.is(":visible")&&Fr()}),$("#gradient-panel").on("click",function(m){m.stopPropagation()});function Ar(){$("#rendering-panel").show(),ai(t.get("tonemap-operator").getValue())}function Rr(){$("#rendering-panel").hide()}$("#open-rendering-settings").on("click",function(){Ar()}),$(document).on("click","#menu-settings",function(){window.appModal&&window.appModal.show()}),$(document).on("click","#menu-docs",function(){window.appModal&&window.appModal.show("docs")}),$(document).on("keydown",function(m){(m.ctrlKey||m.metaKey)&&m.key===","&&(m.preventDefault(),window.appModal&&window.appModal.show())}),$("#animation-section-toggle").on("click",function(){let m=$("#animation-section-content"),_=$("#animation-section-arrow"),T=$("#histogram-panel"),P=$("#cursor-position");m.is(":visible")?(m.slideUp(200),_.text("\u25BC"),T.removeClass("shifted"),P.removeClass("shifted")):(m.slideDown(200),_.text("\u25B2"),T.addClass("shifted"),P.addClass("shifted"))});let pe=[],Ze=null,Dt=0,Qe=0,Bt=.01;function _i(m={}){let{captureFrames:_=!1,totalFrames:T=0,loops:P=1,halfLoops:Z=!1,onProgress:re=null,onComplete:ge=null}=m;if(ve)return;_?(Ze="fixed",Dt=T,Qe=0,pe=[],Bt=P*(Z?1:2)/T):(Ze="continuous",Bt=.01),ve=!0,window.renderer&&window.renderer.stop(),Ie=0,te=null,Mt=null,Pt=0,qe=0,ie=null,$("#animation-lock-shaders").is(":checked")&&n?(n.lockShaderRecompilation=!0,Je=!0,a.info("Shader recompilation lock ENABLED (animation started)",null,!1)):Je=!1,Ke=a.verbosity,a.setVerbosity("silent"),Ee=[],t.controls.forEach(Q=>{Q instanceof we&&Ee.push(Q)}),Te=[];let be=t.controls.get("transform-params");be&&be.parameterControls&&be.parameterControls.forEach(Q=>{Q instanceof Be&&Te.push(Q)});let $e=()=>{if(!ve)return;let Q=$("#animation-clear-screen").is(":checked"),Fe=$("#animation-smooth-timing").is(":checked");if(Ie++,Ie===1&&(window.renderer&&window.renderer.shadersJustRecompiled&&(window.renderer.shadersJustRecompiled=!1),Mt=performance.now()),Ie>=bi){Ie=0,Q&&window.renderer&&(window.renderer.render(!1),window.renderer.downsampleToCanvas(),window.renderer.clearRenderBuffer(!0));let oe=performance.now()-Mt;Pt<wr?Pt++:te===null?te=oe:oe>te?te=yi*oe+(1-yi)*te:te=Ct*oe+(1-Ct)*te,Fe?(qe++,qe>=Er&&(qe=0,te===null?$("#step-time-counter").text(`Step: ${oe.toFixed(1)}ms (warming up...)`):$("#step-time-counter").text(`Step: ${oe.toFixed(1)}ms (EMA: ${te.toFixed(1)}ms)`),$("#step-time-counter").show())):$("#step-time-counter").hide();let H=$i.getValue();H+=Rt*Bt,H>=1?(H=1,Rt=-1):H<=0&&(H=0,Rt=1),$i.setValue(H);for(let N=0;N<Ee.length;N++)Ee[N].updateFromAlpha(H);for(let N=0;N<Te.length;N++)Te[N].updateFromAlpha(H);if(window.renderer){window.renderer.setAnimationAlpha(H);let N={};for(let ne=0;ne<Ee.length;ne++){let Me=Ee[ne],Ue=Me.getValue();(ie===null||Ue!==ie[Me.settingsKey])&&(N[Me.settingsKey]=Ue)}for(let ne=0;ne<Te.length;ne++){let Me=Te[ne],Ue=Me.getValue(),Ti=Me.parameterName;N.transformParams||(N.transformParams=ie?.transformParams?{...ie.transformParams}:{}),(ie===null||Ue!==ie.transformParams?.[Ti])&&(N.transformParams[Ti]=Ue)}if(Object.keys(N).length>0)try{window.renderer.updateConfig(N),ie===null&&(ie={}),Object.assign(ie,N)}catch(ne){a.error("Failed to apply animation settings:",ne)}else ie===null&&(ie={});$("#animation-clear-particles").is(":checked")&&window.renderer.resetParticles(),Q||window.renderer.render(!0),Ze==="fixed"&&window.renderer.captureRenderBuffer().then(function(ne){pe.push(ne),Qe++,re&&re(Qe,Dt,H),Qe>=Dt&&(et(),ge&&ge(pe))}).catch(function(ne){console.error("Failed to capture animation frame:",ne),et(),alert("Failed to capture animation frame. Check console for details.")})}if(Fe&&te!==null&&oe<te){let N=te-oe;setTimeout(()=>{ve&&(Ce=requestAnimationFrame($e))},N);return}}else window.renderer&&(Q?window.renderer.render(!1):window.renderer.render(!0));ve&&(Ce=requestAnimationFrame($e))};Ce=requestAnimationFrame($e)}function et(){ve=!1,Ce!==null&&(cancelAnimationFrame(Ce),Ce=null),window.renderer&&!window.renderer.isRunning&&window.renderer.start(),$("#step-time-counter").hide(),Ee=null,Te=null,ie=null,Ke!==null&&(a.setVerbosity(Ke),Ke=null),Je&&n&&(n.lockShaderRecompilation=!1,Je=!1,a.info("Shader recompilation lock DISABLED (animation stopped)")),Ze=null}$("#animation-alpha-animate-btn").on("click",function(m){m.stopPropagation();let _=$(this);ve?(et(),_.text("\u25B6"),_.css("background","#4CAF50"),_.attr("title","Auto-animate")):(_i(),_.text("\u23F8"),_.css("background","#FFA726"),_.attr("title","Stop auto-animate"))}),$("#animation-half-loops").on("change",function(){let _=$(this).is(":checked")?"Number of half cycles (1 = 0.0 \u2192 1.0, 2 = 0.0 \u2192 1.0 \u2192 0.0)":"Number of complete alpha cycles (0.0 \u2192 1.0 \u2192 0.0)";$("#animation-loops-info").text(_)}),$("#animation-create-btn").on("click",function(){let m=$(this);if(m.data("stop-animation")){et(),m.text("\u25B6 Create Animation"),m.css("background","#4CAF50"),m.data("stop-animation",!1),$("#animation-frames").prop("disabled",!1),$("#animation-loops").prop("disabled",!1),$("#animation-half-loops").prop("disabled",!1),$("#animation-download-btn").prop("disabled",pe.length===0),$("#progress-text").text(`Stopped: ${pe.length} frames captured`),a.info(`Animation stopped early: ${pe.length} frames captured`);return}if(ve)return;let _=$("#animation-frames"),T=$("#animation-loops"),P=$("#animation-half-loops"),Z=$("#animation-download-btn"),re=$("#animation-progress"),ge=$("#progress-bar"),Se=$("#progress-text"),be=$("#progress-alpha"),$e=parseInt(_.val())||100,Q=parseInt(T.val())||1,Fe=P.is(":checked");m.prop("disabled",!1),m.text("\u23F9 Stop Animation"),m.css("background","#f44336"),m.data("stop-animation",!0),_.prop("disabled",!0),T.prop("disabled",!0),P.prop("disabled",!0),Z.prop("disabled",!0),re.show(),ge.css("width","0%"),Se.text(`Frame 0 / ${$e}`),be.text("\u03B1: 0.00"),_i({captureFrames:!0,totalFrames:$e,loops:Q,halfLoops:Fe,onProgress:(ae,oe,H)=>{let N=ae/oe*100;ge.css("width",`${N}%`),Se.text(`Frame ${ae} / ${oe}`),be.text(`\u03B1: ${H.toFixed(2)}`)},onComplete:ae=>{m.prop("disabled",!1),m.text("\u25B6 Create Animation"),m.css("background","#4CAF50"),m.data("stop-animation",!1),_.prop("disabled",!1),T.prop("disabled",!1),P.prop("disabled",!1),Z.prop("disabled",!1),ge.css("width","100%"),Se.text(`Complete: ${ae.length} frames`),a.info(`Animation creation complete: ${ae.length} frames captured`)}})}),$("#animation-download-btn").on("click",async function(){if(pe.length===0){alert("No frames to download. Create an animation first.");return}let m=$(this);m.prop("disabled",!0),m.text("\u23F3 Creating ZIP...");try{let T=pe.length,P=Math.ceil(T/300),Z=new Date().toISOString().replace(/[:.]/g,"-").slice(0,-5);a.info(`Splitting ${T} frames into ${P} ZIP file(s)`);for(let re=0;re<P;re++){let ge=re*300,Se=Math.min((re+1)*300,T);m.text(`\u23F3 Creating ZIP ${re+1}/${P}...`);let be=new JSZip,$e=be.folder("frames");for(let H=ge;H<Se;H++){let N=String(H).padStart(5,"0");$e.file(`frame_${N}.png`,pe[H])}let Q=await be.generateAsync({type:"blob"}),Fe=URL.createObjectURL(Q),ae=document.createElement("a"),oe=P>1?`.${re+1}`:"";ae.download=`animation-${Z}${oe}.zip`,ae.href=Fe,document.body.appendChild(ae),ae.click(),document.body.removeChild(ae),URL.revokeObjectURL(Fe),a.info(`Part ${re+1}/${P} downloaded: frames ${ge}-${Se-1}`),re<P-1&&await new Promise(H=>setTimeout(H,500))}a.info(`Animation download complete: ${T} frames in ${P} ZIP file(s)`),P>1&&alert(`Animation split into ${P} ZIP files. Use create-video.sh with the base filename (without .1, .2, etc) to reconstruct.`)}catch(_){a.error("Failed to create ZIP:",_),alert("Failed to create ZIP file: "+_.message)}finally{m.prop("disabled",!1),m.text("\u{1F4BE} Download Animation (ZIP)")}}),$("#export-animation-json").on("click",function(){let m=t.getSettings();n&&n.bbox&&(m.bbox={min:[n.bbox.min[0],n.bbox.min[1]],max:[n.bbox.max[0],n.bbox.max[1]]}),delete m.animationAlpha;let _={name:"Untitled Animation",description:"Animation created from current settings",fps:30,baseSettings:m,timeline:[{time:0,settings:{},easing:"linear"},{time:10,settings:{},easing:"linear"}],frameConfig:{burnInSteps:5e3,clearAfterBurnIn:!0,accumulationSteps:2e3}},T=new Blob([JSON.stringify(_,null,2)],{type:"application/json"}),P=URL.createObjectURL(T),Z=document.createElement("a");Z.href=P,Z.download="animation-template.json",document.body.appendChild(Z),Z.click(),document.body.removeChild(Z),URL.revokeObjectURL(P),a.info("Exported animation template JSON")}),$(document).on("click",function(m){let _=$("#rendering-panel"),T=$("#open-rendering-settings");$(m.target).is(T)||$(m.target).closest("#rendering-panel").length>0||_.is(":visible")&&Rr()}),t.initializeControls();let O=bo();if(O){if(O.coordinateSystem&&O.dimensions)try{let m=O.coordinateSystem;m.forwardTransforms&&window.UnicodeAutocomplete&&(m.forwardTransforms=m.forwardTransforms.map(T=>typeof T=="string"&&window.UnicodeAutocomplete.unicodeToAscii?window.UnicodeAutocomplete.unicodeToAscii(T):T));let _=j.fromJSON(m);if(_.dimensions===O.dimensions)n.coordinateSystem=_,E.setCoordinateSystem(_,!1),console.log("Restored coordinate system:",_.name);else{console.warn(`Coordinate system dimension mismatch: system has ${_.dimensions}D but settings use ${O.dimensions}D. Resetting to Cartesian.`);let T=ue(O.dimensions);n.coordinateSystem=T,E.setCoordinateSystem(T,!1)}}catch(m){if(console.warn("Failed to restore coordinate system:",m),O.dimensions){let _=ue(O.dimensions);n.coordinateSystem=_,E.setCoordinateSystem(_,!1)}}if(O.expressions&&Array.isArray(O.expressions)&&window.UnicodeAutocomplete&&(O.expressions=O.expressions.map(m=>typeof m=="string"&&window.UnicodeAutocomplete.unicodeToAscii?window.UnicodeAutocomplete.unicodeToAscii(m):m)),O.mapperParams){let m=O.mapperParams;m.dim1!==void 0&&m.dim2!==void 0&&m.dim1===m.dim2&&(console.warn("Invalid mapper params: dim1 and dim2 are the same, fixing to default"),O.mapperParams={dim1:0,dim2:1})}t.applySettings(O),t.apply()}n&&(n.frameLimitEnabled=_r.getValue(),n.frameLimit=gi.getValue()),ai(t.get("tonemap-operator").getValue()),br(t.get("color-mode").getValue()),li(t.get("color-mode").getValue()),xr(t.get("color-mode").getValue());let wi=t.get("integrator").getValue()||"rk2",Ei=wi.startsWith("implicit-")||wi==="trapezoidal";$("#implicit-iterations-group").toggle(Ei),$("#solution-method-group").toggle(Ei),t.get("theme-selector").getValue()==="light"&&$("body").addClass("light-theme"),_o(),window.unicodeAutocomplete&&(window.unicodeAutocomplete.setEnabled(!0),window.unicodeAutocomplete.attachToAll('[id^="expr-"]'),window.unicodeAutocomplete.attachToAll("#mapper-expression"),window.unicodeAutocomplete.attachToAll("#color-expression"),window.unicodeAutocomplete.attachToAll("#custom-color-code"),window.unicodeAutocomplete.attachToAll("#custom-integrator-code"),console.log("Unicode autocomplete enabled for all math inputs"));function Cr(){let m=t.getSettings();return n&&n.bbox&&(m.bbox={min:[...n.bbox.min],max:[...n.bbox.max]}),n&&n.coordinateSystem&&(m.coordinateSystem=n.coordinateSystem.toJSON()),localStorage.setItem("vectorFieldSettings",JSON.stringify(m)),m}return e&&e({manager:t,state:t.getSettings(),saveSettings:Cr}),O&&O.bbox&&n.updateConfig({bbox:O.bbox,reinitializeParticles:!1}),t}function ai(n){let t=["reinhard_extended","uncharted2","hable","luminance_extended"].includes(n);$("#white-point-control").toggle(t)}function br(n){n==="expression"?$("#expression-controls").show():$("#expression-controls").hide()}function li(n){n==="expression"||n==="velocity_magnitude"||n==="velocity_angle"||n==="velocity_combined"?$("#gradient-button-container").show():$("#gradient-button-container").hide(),n==="expression"?$("#gradient-preset-toggle").hide():$("#gradient-preset-toggle").show()}function xr(n){n==="velocity_magnitude"||n==="velocity_combined"?($("#velocity-scaling-container").show(),$("#velocity-log-container").show()):($("#velocity-scaling-container").hide(),$("#velocity-log-container").hide())}function bo(){try{let n=new URLSearchParams(window.location.search),e=n.get("s"),t=null;if(e){if(t=xo(e),t){console.log("Loaded settings from URL parameter"),localStorage.setItem("vectorFieldSettings",JSON.stringify(t)),n.delete("s");let i=n.toString(),r=window.location.pathname+(i?"?"+i:"");window.history.replaceState({},"",r),console.log("URL cleaned, settings now in localStorage")}}else{let i=localStorage.getItem("vectorFieldSettings");i&&(t=JSON.parse(i),console.log("Loaded settings from localStorage"))}return t}catch(n){return console.warn("Failed to load settings:",n),null}}function xo(n){try{let e=n.replace(/-/g,"+").replace(/_/g,"/");for(;e.length%4;)e+="=";let t=atob(e);return JSON.parse(t)}catch(e){return console.error("Failed to decode settings:",e),null}}function yo(n){try{let e=JSON.stringify(n);return btoa(e).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}catch(e){return console.error("Failed to encode settings:",e),null}}function vo(n){let e=yo(n);if(!e){alert("Failed to encode settings");return}let t=new URL(window.location.href);t.search="";let i=new URLSearchParams(window.location.search).get("storage");i&&t.searchParams.set("storage",i),t.searchParams.set("s",e);let r=t.toString();if(navigator.clipboard&&navigator.clipboard.writeText)navigator.clipboard.writeText(r).then(()=>{let o=$("#share-url"),s=o.text();o.text("URL Copied!"),setTimeout(()=>{o.text(s)},2e3)}).catch(o=>{console.error("Failed to copy URL to clipboard:",o),alert(`Share this URL:

`+r)});else{let o=document.createElement("input");o.value=r,document.body.appendChild(o),o.select(),o.setSelectionRange(0,99999);try{let s=document.execCommand("copy");if(document.body.removeChild(o),s){let l=$("#share-url"),c=l.text();l.text("URL Copied!"),setTimeout(()=>{l.text(c)},2e3)}else throw new Error("execCommand failed")}catch{document.body.removeChild(o),alert(`Copy this URL to share:

`+r)}}}function $o(){$("#error-message").hide()}function _o(){window.presets={"2d_rotation":{dimensions:2,expressions:["-y","x"],integratorType:"rk2",colorMode:"velocity_angle",name:"Simple Rotation"},"2d_vortex":{dimensions:2,expressions:["-y + x*(1 - x*x - y*y)","x + y*(1 - x*x - y*y)"],integratorType:"rk4",colorMode:"velocity_angle",bbox:{min:[-3,-3],max:[3,3]},name:"Vortex"},"2d_vanderpol":{dimensions:2,expressions:["y","(1 - x*x)*y - x"],integratorType:"rk4",colorMode:"velocity_angle",name:"Van der Pol Oscillator"},"3d_lorenz":{dimensions:3,expressions:["10*(y - x)","x*(28 - z) - y","x*y - 2.67*z"],integratorType:"rk4",colorMode:"velocity_angle",name:"Lorenz Attractor"},"3d_rossler":{dimensions:3,expressions:["-y - z","x + 0.2*y","0.2 + z*(x - 5.7)"],colorMode:"velocity_angle",name:"R\xF6ssler Attractor"},"4d_hypersphere":{dimensions:4,expressions:["-y","x","-w","z"],colorMode:"velocity_angle",name:"4D Hypersphere Rotation"},"2d_fluid_stirring":{dimensions:2,expressions:["-y + sin(x)*cos(y)*3.0 - 0.1*x","x + cos(x)*sin(y)*3.0 - 0.1*y"],colorMode:"velocity_angle",name:"Fluid Transport with Stirring"},"4d_double_pendulum":{dimensions:4,expressions:["z","w","(-10*(2*sin(x) + sin(x - 2*y)) - 2*sin(x - y)*(w*w + z*z*cos(x - y))) / (3 - cos(2*x - 2*y))","(2*sin(x - y)*(2*z*z + 20*cos(x) + w*w*cos(x - y))) / (3 - cos(2*x - 2*y))"],name:"Double Pendulum (Chaotic)",timestep:.005,colorMode:"velocity_angle",mapperType:"custom",mapperParams:{horizontalExpr:"sin(x) + sin(y)",verticalExpr:"-cos(x) - cos(y)",depthExpr:""}},"2d_strange_attractor":{dimensions:2,expressions:["-y + x*(1 - x*x*x*x - y*y*y*y)","x + y*(1 - x*x*x*x - y*y*y*y)"],bbox:{min:[-3.5719104227544065,-1.7259582784950003],max:[3.5719104227544065,1.7259582784950003]},integratorType:"implicit-euler",solutionMethod:"fixed-point",timestep:.472,implicitIterations:3,particleCount:880100,fadeOpacity:.9999,colorMode:"velocity_angle",supersampleFactor:2,smaaEnabled:!1,"smaa-intensity":1,"smaa-threshold":1,bilateralEnabled:!0,bilateralSpatialSigma:5,bilateralIntensitySigma:.01,tonemapOperator:"luminance_extended",exposure:.010232929922807544,gamma:.7803178779033633,luminanceGamma:1.2188608780748513,highlightCompression:9.999999999999993,compressionThreshold:100000.00000000001,whitePoint:3.443499307633384,particleIntensity:47.31512589614813,particleSize:.10000000000000002,particleRenderMode:"points",colorSaturation:.429,brightnessDesaturation:.685,brightnessSaturation:.13,name:"Strange Attractor (Chaotic Limit Cycle)"}}}function di(n,e){let t=window.presets[n];if(t||(t=We()[n]),!t){console.error("Preset not found:",n),a.error(`Preset not found: ${n}`);return}if(a.info(`Loading preset: ${t.name||n} (dimensions=${t.dimensions}, expressions=${t.expressions.length})`),t.dimensions){let l;t.coordinateSystem?l=j.fromJSON(t.coordinateSystem):l=ue(t.dimensions),window.renderer&&(window.renderer.coordinateSystem=l);let c=e.get("dimension-inputs");c&&c.setCoordinateSystem(l),a.info(`Preset loaded with coordinate system: ${l.name}`)}e.applySettings(t);let i=e.get("dimension-inputs");i&&t.dimensions&&i.updateInputs(t.dimensions);let r=e.get("mapper-params");r&&r.updateControls();let o=e.get("transform-params");o&&o.updateControls();let s=e.getSettings();t.bbox&&(s.bbox=t.bbox,a.info(`Preset bbox: min=${t.bbox.min}, max=${t.bbox.max}`)),s.implicitIterations!==void 0&&(s.integratorParams={iterations:s.implicitIterations}),window.renderer&&window.renderer.updateConfig(s),a.info(`Preset ${t.name||n} loaded successfully`)}var ui="customPresets";function We(){try{let n=localStorage.getItem(ui);return n?JSON.parse(n):{}}catch(n){return console.error("Failed to load custom presets:",n),{}}}function wo(n,e){let t=We();t[n]=e;try{localStorage.setItem(ui,JSON.stringify(t))}catch(i){console.error("Failed to save custom preset:",i),alert("Failed to save preset: "+i.message)}}function Eo(n){let e=We();delete e[n];try{localStorage.setItem(ui,JSON.stringify(e))}catch(t){console.error("Failed to delete custom preset:",t)}}function ci(){let n=We(),e=$("#custom-presets-group");e.empty();let t=Object.keys(n).sort();t.length>0?(e.show(),t.forEach(i=>{let o=n[i].name||i;e.append(`<option value="${i}">${o}</option>`)})):e.hide()}X();X();var vr={linear:n=>n,easeIn:n=>n*n,easeOut:n=>1-Math.pow(1-n,2),easeInOut:n=>n<.5?2*n*n:1-Math.pow(-2*n+2,2)/2,easeInCubic:n=>n*n*n,easeOutCubic:n=>1-Math.pow(1-n,3),easeInOutCubic:n=>n<.5?4*n*n*n:1-Math.pow(-2*n+2,3)/2,elastic:n=>{let e=2*Math.PI/3;return n===0?0:n===1?1:-Math.pow(2,10*n-10)*Math.sin((n*10-10.75)*e)},bounce:n=>n<1/2.75?7.5625*n*n:n<2/2.75?7.5625*(n-=1.5/2.75)*n+.75:n<2.5/2.75?7.5625*(n-=2.25/2.75)*n+.9375:7.5625*(n-=2.625/2.75)*n+.984375},wt=class{constructor(e,t){this.renderer=e,this.manager=t,this.frames=[],this.isRunning=!1,this.isPaused=!1,this.script=null}loadScript(e){if(!e.baseSettings)throw new Error("Animation script missing baseSettings");if(!e.timeline||!Array.isArray(e.timeline))throw new Error("Animation script missing timeline array");if(e.timeline.length<2)throw new Error("Timeline must have at least 2 keyframes");for(let r=1;r<e.timeline.length;r++)if(e.timeline[r].time<=e.timeline[r-1].time)throw new Error("Timeline keyframes must be sorted by time");this.script={name:e.name||"Untitled Animation",description:e.description||"",fps:e.fps||30,baseSettings:e.baseSettings,timeline:e.timeline.map(r=>({time:r.time,settings:r.settings||{},easing:r.easing||"linear",convergenceSteps:r.convergenceSteps||0})),frameConfig:{burnInSteps:e.frameConfig?.burnInSteps||5e3,clearAfterBurnIn:e.frameConfig?.clearAfterBurnIn!==void 0?e.frameConfig.clearAfterBurnIn:!0,accumulationSteps:e.frameConfig?.accumulationSteps||2e3}};let t=this.script.timeline[this.script.timeline.length-1].time,i=Math.ceil(t*this.script.fps);return a.info(`Loaded animation: ${this.script.name}`),a.info(`  Duration: ${t}s @ ${this.script.fps} fps = ${i} frames`),a.info(`  Keyframes: ${this.script.timeline.length}`),this.script}getKeyframeIndices(e){let t=this.script.timeline;if(e<=t[0].time)return{prev:0,next:0,t:0};if(e>=t[t.length-1].time)return{prev:t.length-1,next:t.length-1,t:1};for(let i=1;i<t.length;i++)if(e<=t[i].time){let r=i-1,o=i,s=(e-t[r].time)/(t[o].time-t[r].time);return{prev:r,next:o,t:s}}return{prev:t.length-1,next:t.length-1,t:1}}interpolateValue(e,t,i,r="linear"){let s=(vr[r]||vr.linear)(i);if(typeof e=="number"&&typeof t=="number")return e+(t-e)*s;if(Array.isArray(e)&&Array.isArray(t))return e.map((l,c)=>{let d=t[c]!==void 0?t[c]:l;return typeof l=="number"?l+(d-l)*s:s<.5?l:d});if(typeof e=="object"&&e!==null&&typeof t=="object"&&t!==null){let l={...e};for(let c in t)e[c]!==void 0?l[c]=this.interpolateValue(e[c],t[c],s,r):l[c]=t[c];return l}return s<.5?e:t}getInterpolatedSettings(e){let{prev:t,next:i,t:r}=this.getKeyframeIndices(e),o=this.script.timeline;if(t===i)return{...this.script.baseSettings,...o[t].settings};let s={...this.script.baseSettings,...o[t].settings},l={...this.script.baseSettings,...o[i].settings},c=o[i].easing,d={...s};for(let u in l)s[u]!==void 0?d[u]=this.interpolateValue(s[u],l[u],r,c):d[u]=l[u];return d}getAnimationAlpha(e){let t=this.script.timeline[this.script.timeline.length-1].time;return Math.max(0,Math.min(1,e/t))}waitFrame(){return new Promise(e=>requestAnimationFrame(e))}async captureFrame(){return this.renderer.captureRenderBuffer()}async renderAnimationFrame(e,t,i){let{frameConfig:r}=this.script,o=this.getInterpolatedSettings(e),s=this.getAnimationAlpha(e);if(a.info(`Frame ${t+1}/${i}: t=${e.toFixed(3)}s, alpha=${s.toFixed(3)}`),this.manager.setSettings(o),this.renderer.setAnimationAlpha(s),await this.waitFrame(),this.renderer.clearRenderBuffer(),this.renderer.resetParticles(),r.burnInSteps>0&&(a.verbose(`  Burn-in: ${r.burnInSteps} steps`),this.renderer.step(r.burnInSteps)),r.clearAfterBurnIn&&this.renderer.clearRenderBuffer(),r.accumulationSteps>0){a.verbose(`  Accumulation: ${r.accumulationSteps} steps`);for(let c=0;c<r.accumulationSteps;c++)this.renderer.updatePositions(),this.renderer.drawParticles(),this.renderer.fadeScreen()}return this.renderer.render(),await this.waitFrame(),await this.captureFrame()}async run(e){if(this.isRunning)throw new Error("Animation already running");if(!this.script)throw new Error("No animation script loaded");this.isRunning=!0,this.isPaused=!1,this.frames=[];let t=this.script.timeline[this.script.timeline.length-1].time,i=Math.ceil(t*this.script.fps);try{a.info("Applying base settings...");let r={...this.script.baseSettings};if(delete r.coordinateSystem,this.manager.setSettings(r),this.script.baseSettings.coordinateSystem){let{CoordinateSystem:o}=await Promise.resolve().then(()=>(Le(),ar)),s=o.fromJSON(this.script.baseSettings.coordinateSystem);this.renderer.coordinateSystem=s,a.info(`Set coordinate system: ${s.name}`),this.renderer.compileShaders(),a.info("Shaders recompiled with coordinate system")}await this.waitFrame();for(let o=0;o<i;o++){for(;this.isPaused&&this.isRunning;)await new Promise(c=>setTimeout(c,100));if(!this.isRunning){a.info("Animation stopped");break}let s=o/this.script.fps,l=await this.renderAnimationFrame(s,o,i);this.frames.push({frameNum:o,time:s,blob:l,timestamp:Date.now()}),e&&e(o+1,i,s)}return a.info(`Animation complete: ${this.frames.length} frames captured`),this.frames}catch(r){throw a.error("Animation failed:",r),r}finally{this.isRunning=!1}}pause(){this.isPaused=!0}resume(){this.isPaused=!1}stop(){this.isRunning=!1,this.isPaused=!1}async downloadFrames(){if(this.frames.length===0)throw new Error("No frames to download");return window.JSZip?await this.downloadAsZip():await this.downloadIndividually()}async downloadAsZip(){let e=window.JSZip,t=new e;for(let{frameNum:s,blob:l}of this.frames){let c=`frame_${String(s).padStart(6,"0")}.png`;t.file(c,l)}let i={script:this.script,captureDate:new Date().toISOString(),frameCount:this.frames.length};t.file("metadata.json",JSON.stringify(i,null,2)),a.info("Generating ZIP archive...");let r=await t.generateAsync({type:"blob"}),o=`${this.script.name.replace(/\s+/g,"_")}.zip`;this.downloadBlob(r,o),a.info(`Downloaded ${o}`)}async downloadIndividually(){for(let{frameNum:e,blob:t}of this.frames){let i=`frame_${String(e).padStart(6,"0")}.png`;this.downloadBlob(t,i),await new Promise(r=>setTimeout(r,100))}a.info(`Downloaded ${this.frames.length} frames`)}downloadBlob(e,t){let i=URL.createObjectURL(e),r=document.createElement("a");r.href=i,r.download=t,document.body.appendChild(r),r.click(),document.body.removeChild(r),URL.revokeObjectURL(i)}};var ye=class{constructor(e,t){this.id=e,this.title=t,this._isRendered=!1,this._isActive=!1,this._contentElement=null}get isRendered(){return this._isRendered}get isActive(){return this._isActive}render(e){throw new Error("Tab subclass must implement render() method")}onActivate(){}onDeactivate(){}_activate(e){this._isRendered||(this._contentElement=this.render(e),this._isRendered=!0),this._contentElement&&(this._contentElement.style.display="block"),this._isActive=!0,this.onActivate()}_deactivate(){this._contentElement&&(this._contentElement.style.display="none"),this._isActive=!1,this.onDeactivate()}destroy(){this._contentElement&&this._contentElement.parentNode&&this._contentElement.parentNode.removeChild(this._contentElement),this._contentElement=null,this._isRendered=!1,this._isActive=!1}},Et=class{constructor(){this._tabs=new Map,this._activeTab=null,this._tabBarElement=null,this._contentElement=null}register(e){if(!(e instanceof ye))throw new Error("Tab must be an instance of Tab class");if(this._tabs.has(e.id))throw new Error(`Tab with id '${e.id}' already registered`);this._tabs.set(e.id,e),this._tabBarElement&&this._addTabButton(e)}unregister(e){let t=this._tabs.get(e);if(t&&(t===this._activeTab&&(this._activeTab=null),t.destroy(),this._tabs.delete(e),this._tabBarElement)){let i=this._tabBarElement.querySelector(`[data-tab-id="${e}"]`);i&&i.remove()}}activate(e){let t=this._tabs.get(e);return t?(this._activeTab&&this._activeTab!==t&&(this._activeTab._deactivate(),this._updateTabButton(this._activeTab.id,!1)),this._activeTab=t,t._activate(this._contentElement),this._updateTabButton(e,!0),!0):(console.warn(`Tab '${e}' not found`),!1)}getActiveTab(){return this._activeTab}getAllTabs(){return Array.from(this._tabs.values())}initializeUI(e,t){this._tabBarElement=e,this._contentElement=t;for(let i of this._tabs.values())this._addTabButton(i)}_addTabButton(e){if(!this._tabBarElement)return;let t=document.createElement("button");t.className="modal-tab-button",t.textContent=e.title,t.dataset.tabId=e.id,t.addEventListener("click",()=>{this.activate(e.id)}),this._tabBarElement.appendChild(t)}_updateTabButton(e,t){if(!this._tabBarElement)return;let i=this._tabBarElement.querySelector(`[data-tab-id="${e}"]`);i&&(t?i.classList.add("active"):i.classList.remove("active"))}destroy(){for(let e of this._tabs.values())e.destroy();this._tabs.clear(),this._activeTab=null,this._tabBarElement=null,this._contentElement=null}};var mi=class{constructor(){this.tabManager=new Et,this._modalElement=null,this._isVisible=!1,this._onCloseCallback=null,this._wasPaused=!1}initialize(){if(this._modalElement=document.getElementById("modal-overlay"),!this._modalElement){console.error("Modal overlay element not found");return}let e=document.getElementById("modal-tab-bar"),t=document.getElementById("modal-content");if(!e||!t){console.error("Modal tab bar or content element not found");return}this.tabManager.initializeUI(e,t);let i=document.getElementById("modal-close");i&&i.addEventListener("click",()=>this.hide()),this._modalElement.addEventListener("click",r=>{r.target===this._modalElement&&this.hide()}),document.addEventListener("keydown",r=>{r.key==="Escape"&&this._isVisible&&this.hide()})}registerTab(e){this.tabManager.register(e)}show(e=null,t=null){if(!this._modalElement){console.error("Modal not initialized");return}if(!e){let i=this.tabManager.getAllTabs();i.length>0&&(e=i[0].id)}if(e&&(this.tabManager.activate(e),t)){let i=this.tabManager.getAllTabs().find(r=>r.id===e);i&&typeof i.openToSection=="function"&&(i.isRendered?i.openToSection(t):typeof i.setPendingSection=="function"&&i.setPendingSection(t))}this._modalElement.style.display="flex",this._isVisible=!0,document.body.style.overflow="hidden",window.renderer&&window.renderer.isRunning?(window.renderer.stop(),this._wasPaused=!1):this._wasPaused=!0}hide(){this._modalElement&&(this._modalElement.style.display="none",this._isVisible=!1,document.body.style.overflow="",window.renderer&&!this._wasPaused&&window.renderer.start(),this._onCloseCallback&&this._onCloseCallback())}isVisible(){return this._isVisible}onClose(e){this._onCloseCallback=e}getActiveTab(){return this.tabManager.getActiveTab()}},hi=null;function To(){return hi||(hi=new mi),hi}function $r(){let n=To();return n.initialize(),n}var Tt=class extends ye{constructor(e,t){super("custom-functions","Custom Functions"),this.mathParser=e,this.debouncedApply=t,this.textarea=null,this.applyButton=null,this.errorDiv=null,this.successDiv=null}render(e){let t=document.createElement("div");return t.id="custom-functions-tab-content",t.className="modal-tab-content",t.style.display="none",t.innerHTML=`
            <div class="info" style="margin-bottom: 16px;">
                Define custom functions using mathematical syntax. Functions can be used in vector field expressions, color expressions, and mapper functions.
            </div>

            <h4 style="margin: 0 0 12px 0; padding: 0; font-size: 14px; color: #4CAF50;">Syntax</h4>
            <div class="info" style="margin-bottom: 16px; font-family: monospace; background: #000; padding: 8px; border-radius: 4px; font-size: 11px;">
                functionName(arg1, arg2, ...) = expression<br>
                <br>
                <span style="color: #888;">Examples:</span><br>
                <span style="color: #4CAF50;">smoothstep(x, a, b) = ((x-a)/(b-a))^3 * (3 - 2*((x-a)/(b-a)))</span><br>
                <span style="color: #4CAF50;">lerp(a, b, t) = a * (1-t) + b * t</span><br>
                <span style="color: #4CAF50;">sqr(x) = x * x</span><br>
                <span style="color: #4CAF50;">cube(x) = x * x * x</span>
            </div>

            <h4 style="margin: 0 0 8px 0; padding: 0; font-size: 14px; color: #4CAF50;">Function Definitions</h4>
            <div class="control-group">
                <textarea id="custom-functions-textarea"
                    rows="12"
                    style="width: 100%; font-family: 'Courier New', monospace; font-size: 12px; background: #1a1a1a; color: #4CAF50; border: 1px solid #444; border-radius: 4px; padding: 10px; resize: vertical;"
                    placeholder="Enter custom function definitions (one per line)...&#10;&#10;Example:&#10;smoothstep(x, a, b) = ((x-a)/(b-a))^3 * (3 - 2*((x-a)/(b-a)))"></textarea>
                <div class="info">One function per line. Use standard math operators (+, -, *, /, ^) and built-in functions (sin, cos, exp, log, sqrt, abs, etc.)</div>
            </div>

            <div class="control-group" style="margin-top: 12px;">
                <button id="apply-custom-functions" style="width: 100%; padding: 8px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">
                    Apply Functions
                </button>
            </div>

            <div id="custom-functions-error" style="display: none; margin-top: 12px; padding: 8px; background: rgba(244, 67, 54, 0.1); border: 1px solid #f44336; border-radius: 4px; color: #f44336; font-size: 11px;"></div>

            <div id="custom-functions-success" style="display: none; margin-top: 12px; padding: 8px; background: rgba(76, 175, 80, 0.1); border: 1px solid #4CAF50; border-radius: 4px; color: #4CAF50; font-size: 11px;"></div>
        `,e.appendChild(t),this.textarea=t.querySelector("#custom-functions-textarea"),this.applyButton=t.querySelector("#apply-custom-functions"),this.errorDiv=t.querySelector("#custom-functions-error"),this.successDiv=t.querySelector("#custom-functions-success"),this.applyButton.addEventListener("click",()=>this._applyFunctions()),this._loadSavedFunctions(),t}onActivate(){window.unicodeAutocomplete&&window.unicodeAutocomplete.attachToAll("#custom-functions-textarea")}_applyFunctions(){let e=this.textarea.value;this.errorDiv.style.display="none",this.successDiv.style.display="none";try{this.mathParser.setCustomFunctions(e);let t=e.trim()?e.trim().split(`
`).filter(i=>i.trim()&&!i.trim().startsWith("//")).length:0;this.successDiv.textContent=`\u2713 Successfully loaded ${t} custom function(s)`,this.successDiv.style.display="block",localStorage.setItem("customFunctions",e),this.debouncedApply()}catch(t){this.errorDiv.textContent=`Error: ${t.message}`,this.errorDiv.style.display="block"}}_loadSavedFunctions(){let e=localStorage.getItem("customFunctions");if(e&&this.textarea){this.textarea.value=e;try{this.mathParser.setCustomFunctions(e)}catch(t){console.error("Error loading saved custom functions:",t)}}}};var St=class extends ye{constructor(e){super("debug","Debug Console"),this.logger=e,this.debugToggle=null,this.debugVerbosity=null,this.debugOutput=null,this.bufferSizeSpan=null,this.bufferPercentSpan=null,this.bufferStatusDiv=null}render(e){let t=document.createElement("div");t.id="debug-tab-content",t.className="modal-tab-content",t.style.display="none",t.innerHTML=`
            <div style="display: flex; align-items: center; margin-bottom: 16px;">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="debug-toggle" checked style="margin-right: 8px;">
                    <span style="font-weight: bold;">Enable Debug Logging</span>
                </label>
            </div>

            <div id="debug-controls" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 16px;">
                <select id="debug-verbosity" style="flex: 0 0 auto;">
                    <option value="info">Info</option>
                    <option value="debug">Debug</option>
                    <option value="verbose">Verbose</option>
                    <option value="warn">Warnings Only</option>
                    <option value="error">Errors Only</option>
                    <option value="silent">Silent (Buffer)</option>
                </select>
                <button id="debug-log-update-shader" class="secondary" style="padding: 4px 8px;" title="Particle integration shader (updates positions each frame)">Update Shader</button>
                <button id="debug-log-draw-shader" class="secondary" style="padding: 4px 8px;" title="Particle rendering shaders (vertex + fragment for color/display)">Draw Shaders</button>
                <button id="debug-log-screen-shader" class="secondary" style="padding: 4px 8px;" title="Screen fade shader (trail decay)">Fade Shader</button>
                <button id="debug-log-stats-shaders" class="secondary" style="padding: 4px 8px;" title="Velocity statistics shader (max velocity tracking)">Velocity Stats</button>
                <button id="debug-buffer-stats" class="secondary" style="padding: 4px 8px;">Buffer Stats</button>
                <button id="debug-copy" class="secondary" style="padding: 4px 8px;">Copy Log</button>
                <button id="debug-clear" class="secondary" style="padding: 4px 8px;">Clear</button>
            </div>

            <div id="debug-buffer-status" style="display: none; padding: 8px; background: #2a2a2a; border-radius: 4px; margin-bottom: 12px; font-size: 11px; color: #888;">
                <span style="color: #FFA726; font-weight: bold;">SILENT MODE:</span>
                Buffering <span id="buffer-size" style="color: #4CAF50;">0</span> logs
                (<span id="buffer-percent">0</span>% of max)
                <button id="debug-flush-buffer" class="secondary" style="padding: 2px 6px; margin-left: 8px; font-size: 10px;">Flush Buffer</button>
                <button id="debug-clear-buffer" class="secondary" style="padding: 2px 6px; margin-left: 4px; font-size: 10px;">Clear Buffer</button>
            </div>

            <div style="padding: 8px; margin-bottom: 12px; background: #1f1f1f; border-radius: 4px;">
                <label style="display: flex; align-items: center; cursor: pointer; font-size: 11px;" title="Enable particle sampling and detailed logging (expensive GPU readback). Buffer stats for tone mapping are always enabled but optimized.">
                    <input type="checkbox" id="debug-enable-stats" style="margin-right: 6px;">
                    <span>Enable Particle Sampling (expensive GPU readback)</span>
                </label>
            </div>

            <div id="debug-output" style="background: #0a0a0a; border: 1px solid #333; border-radius: 4px; padding: 12px; height: calc(100vh - 450px); overflow-y: auto; font-family: 'Courier New', monospace; font-size: 11px; line-height: 1.4;"></div>
        `,e.appendChild(t),this.debugToggle=t.querySelector("#debug-toggle"),this.debugVerbosity=t.querySelector("#debug-verbosity"),this.debugOutput=t.querySelector("#debug-output"),this.bufferSizeSpan=t.querySelector("#buffer-size"),this.bufferPercentSpan=t.querySelector("#buffer-percent"),this.bufferStatusDiv=t.querySelector("#debug-buffer-status"),this._setupEventListeners(t),this.logger.setEnabled(this.debugToggle.checked);let i=this.debugVerbosity.value;return this.logger.setVerbosity(i),i==="silent"&&(this.bufferStatusDiv.style.display="block",this._updateBufferStatus()),this.logger.setOutputElement(this.debugOutput),t}_setupEventListeners(e){this.debugToggle.addEventListener("change",()=>{this.logger.setEnabled(this.debugToggle.checked),this.logger.info("Debug logging "+(this.debugToggle.checked?"enabled":"disabled"))}),this.debugVerbosity.addEventListener("change",()=>{let t=this.debugVerbosity.value;this.logger.setVerbosity(t),this.logger.info("Verbosity set to: "+t),t==="silent"?(this.bufferStatusDiv.style.display="block",this._updateBufferStatus()):this.bufferStatusDiv.style.display="none"}),e.querySelector("#debug-copy").addEventListener("click",()=>{let t=this.logger.getLogs(),i=`N-Dimensional Vector Field Renderer - Debug Log
`;i+="=".repeat(60)+`

`;for(let r of t){if(i+=`[${r.timestamp}] [${r.level.toUpperCase()}] ${r.message}`,r.data){let o=typeof r.data=="object"?JSON.stringify(r.data):String(r.data);i+=` | Data: ${o}`}r.stack&&(i+=`
Stack Trace:
${r.stack}`),i+=`
`}navigator.clipboard.writeText(i).then(()=>{this.logger.info("Log copied to clipboard ("+t.length+" entries)")}).catch(r=>{this.logger.error("Failed to copy log to clipboard",r)})}),e.querySelector("#debug-clear").addEventListener("click",()=>{this.logger.clear()}),e.querySelector("#debug-flush-buffer").addEventListener("click",()=>{this.logger.flush(),this._updateBufferStatus()}),e.querySelector("#debug-clear-buffer").addEventListener("click",()=>{this.logger.clearSilencedBuffer(),this._updateBufferStatus()}),e.querySelector("#debug-log-update-shader").addEventListener("click",()=>{window.renderer&&typeof window.renderer.logUpdateShader=="function"?window.renderer.logUpdateShader():this.logger.warn("Renderer not initialized - cannot log update shader")}),e.querySelector("#debug-log-draw-shader").addEventListener("click",()=>{window.renderer&&typeof window.renderer.logDrawShader=="function"?window.renderer.logDrawShader():this.logger.warn("Renderer not initialized - cannot log draw shader")}),e.querySelector("#debug-log-screen-shader").addEventListener("click",()=>{window.renderer&&typeof window.renderer.logScreenShader=="function"?window.renderer.logScreenShader():this.logger.warn("Renderer not initialized - cannot log screen shader")}),e.querySelector("#debug-log-stats-shaders").addEventListener("click",()=>{window.renderer&&typeof window.renderer.logStatsShaders=="function"?window.renderer.logStatsShaders():this.logger.warn("Renderer not initialized - cannot log stats shaders")}),e.querySelector("#debug-buffer-stats").addEventListener("click",()=>{window.renderer&&typeof window.renderer.logBufferStats=="function"?window.renderer.logBufferStats():this.logger.warn("Renderer not initialized - cannot log buffer stats")}),e.querySelector("#debug-enable-stats").addEventListener("change",t=>{if(window.renderer){let i=t.target.checked;window.renderer.enableDebugStats=i,this.logger.info(`GPU debug stats ${i?"ENABLED":"DISABLED"}`)}})}_updateBufferStatus(){let e=this.logger.getBufferStats();this.bufferSizeSpan.textContent=e.bufferSize,this.bufferPercentSpan.textContent=e.bufferUsagePercent,e.bufferUsagePercent>80?this.bufferSizeSpan.style.color="#EF5350":e.bufferUsagePercent>50?this.bufferSizeSpan.style.color="#FFA726":this.bufferSizeSpan.style.color="#4CAF50"}onActivate(){this._bufferUpdateInterval||(this._bufferUpdateInterval=setInterval(()=>{this.logger.isSilenced()&&this._isActive&&this._updateBufferStatus()},1e3))}onDeactivate(){this._bufferUpdateInterval&&(clearInterval(this._bufferUpdateInterval),this._bufferUpdateInterval=null)}destroy(){this._bufferUpdateInterval&&(clearInterval(this._bufferUpdateInterval),this._bufferUpdateInterval=null),super.destroy()}};var Ft=class extends ye{constructor(){super("docs","Documentation"),this.sections=[],this.sectionDefinitions=[{id:"display-options",title:"Display Options & UI Controls",file:"docs/display-options.md"},{id:"vector-fields",title:"Vector Fields",file:"docs/vector-fields.md"},{id:"integrators",title:"Integration Methods",file:"docs/integrators.md"},{id:"color-modes",title:"Color Modes",file:"docs/color-modes.md"},{id:"projection",title:"2D Projection",file:"docs/projection.md"},{id:"coordinate-systems",title:"Coordinate Systems",file:"docs/coordinate-systems.md"},{id:"domain-transforms",title:"Domain Transforms",file:"docs/domain-transforms.md"},{id:"hdr-rendering",title:"HDR & Tone Mapping",file:"docs/hdr-rendering.md"},{id:"rendering-effects",title:"Rendering Effects",file:"docs/rendering-effects.md"},{id:"particle-settings",title:"Particle Settings",file:"docs/particle-settings.md"},{id:"animation",title:"Animation System",file:"docs/animation.md"},{id:"preset-management",title:"Preset Management",file:"docs/preset-management.md"},{id:"storage-strategy",title:"Storage Strategy",file:"docs/storage-strategy.md"},{id:"keyboard-shortcuts",title:"Keyboard Shortcuts",file:"docs/keyboard-shortcuts.md"}]}async _loadMarkdown(e){try{let t=await fetch(e);if(!t.ok)throw new Error(`Failed to load ${e}: ${t.statusText}`);let i=await t.text();return typeof marked>"u"?(console.error("marked.js not loaded"),"<p>Error: Markdown parser not available</p>"):marked.parse(i)}catch(t){return console.error("Error loading markdown:",t),`<p>Error loading documentation: ${t.message}</p>`}}render(e){let t=document.createElement("div");return t.id="docs-tab-content",t.className="modal-tab-content",t.style.display="none",t.innerHTML=`
            <div class="docs-container">
                <p style="text-align: center; padding: 40px; color: #888;">Loading documentation...</p>
            </div>
        `,e.appendChild(t),this._loadAllSections(t),t}async _loadAllSections(e){let t=e.querySelector(".docs-container"),i=this.sectionDefinitions.map(async s=>{let l=await this._loadMarkdown(s.file);return{id:s.id,title:s.title,html:l}}),o=(await Promise.all(i)).map(s=>this._renderSection(s.id,s.title,s.html)).join("");t.innerHTML=o,this._setupCollapsibles(e),this._pendingSection&&(this.openToSection(this._pendingSection),this._pendingSection=null)}_renderSection(e,t,i){return`
            <div class="docs-section collapsed" id="docs-${e}">
                <div class="docs-section-header">
                    <h3>${t}</h3>
                    <span class="docs-toggle">\u25B6</span>
                </div>
                <div class="docs-section-content" style="max-height: 0;">
                    ${i}
                </div>
            </div>
        `}_setupCollapsibles(e){e.querySelectorAll(".docs-section-header").forEach(i=>{i.addEventListener("click",()=>{let r=i.parentElement,o=r.querySelector(".docs-section-content"),s=i.querySelector(".docs-toggle");r.classList.contains("collapsed")?(r.classList.remove("collapsed"),o.style.maxHeight="5000px",s.textContent="\u25BC",setTimeout(()=>{r.classList.contains("collapsed")||(o.style.maxHeight=o.scrollHeight+"px")},350)):(r.classList.add("collapsed"),o.style.maxHeight="0",s.textContent="\u25B6")})})}openToSection(e){if(!this._contentElement)return;let t=this._contentElement.querySelector(`#docs-${e}`);if(!t){console.warn(`Documentation section '${e}' not found`);return}t.classList.contains("collapsed")&&t.querySelector(".docs-section-header").click(),setTimeout(()=>{t.scrollIntoView({behavior:"smooth",block:"start"})},400)}onActivate(){this._pendingSection&&(this.openToSection(this._pendingSection),this._pendingSection=null)}setPendingSection(e){this._pendingSection=e}};window.MathParser={setCustomFunctions:Mi,getCustomFunctions:Pi};$(document).ready(function(){window.logger=a,a.hookConsole(),a.info("Logger initialized");function n(l){let c=document.getElementById("canvas"),d=null;function u(){if(c.width=window.innerWidth,c.height=window.innerHeight,d){d.resize(c.width,c.height);let h=c.width/c.height,g=d.bbox,f=(g.min[0]+g.max[0])/2,p=(g.min[1]+g.max[1])/2,y=(g.max[1]-g.min[1])*h;g.min[0]=f-y/2,g.max[0]=f+y/2,d.updateConfig({bbox:g})}}u(),window.addEventListener("resize",u);try{let g=new URLSearchParams(window.location.search).get("storage")||"float";d=new pt(c,{storageStrategy:g}),l(d,c)}catch(h){a.error("Failed to initialize renderer",h),alert("Failed to initialize WebGL renderer: "+(h.message||h))}}function e(l,c){let d=yr(l,function(u){let{manager:h,state:g,saveSettings:f}=u,p=h.getSettings();l.updateConfig(p),l.start(),o(l,h),window.renderer=l,window.loadPreset=di,window.logger=a,window.saveSettings=f,window.manager=h;let x=$r(),y=new St(a);x.registerTab(y);let b=h.debouncedApply.bind(h),v=new Tt(window.MathParser,b);x.registerTab(v);let w=new Ft;x.registerTab(w),window.appModal=x,a.info("N-Dimensional Vector Field Renderer initialized!"),a.info("Available presets: "+Object.keys(window.presets).join(", ")),a.info('Try: loadPreset("3d_lorenz")')})}function t(l,c){let d=!1,u=0,h=0,g=null;function f(){g&&clearTimeout(g),g=setTimeout(()=>{window.saveSettings&&window.saveSettings()},500)}c.addEventListener("mousedown",b=>{b.target===c&&(d=!0,u=b.clientX,h=b.clientY)}),c.addEventListener("mousemove",b=>{if(d){let v=b.clientX-u,w=b.clientY-h,S=l.bbox,M=S.max[0]-S.min[0],E=S.max[1]-S.min[1],R=M/c.width;S.min[0]-=v*R,S.max[0]-=v*R,S.min[1]+=w*R,S.max[1]+=w*R,l.updateConfig({bbox:S}),u=b.clientX,h=b.clientY}}),c.addEventListener("mouseup",()=>{d=!1,f()}),c.addEventListener("mouseleave",()=>{d=!1,d||f()}),c.addEventListener("wheel",b=>{b.preventDefault();let v=b.deltaY>0?1.1:.9,w=c.getBoundingClientRect(),S=b.clientX-w.left,M=b.clientY-w.top,E=l.bbox,R=E.max[0]-E.min[0],I=E.max[1]-E.min[1],B=E.min[0]+R*(S/c.width),z=E.max[1]-I*(M/c.height),K=I*v,F=c.width/c.height,A=K*F,C=(B-E.min[0])/R,V=(E.max[1]-z)/I;E.min[0]=B-A*C,E.max[0]=B+A*(1-C),E.min[1]=z-K*(1-V),E.max[1]=z+K*V,l.updateConfig({bbox:E}),f()});let p=0;c.addEventListener("touchstart",b=>{if(b.touches.length===1)d=!0,u=b.touches[0].clientX,h=b.touches[0].clientY;else if(b.touches.length===2){d=!1;let v=b.touches[1].clientX-b.touches[0].clientX,w=b.touches[1].clientY-b.touches[0].clientY;p=Math.sqrt(v*v+w*w)}b.preventDefault()}),c.addEventListener("touchmove",b=>{if(b.touches.length===1&&d){let v=b.touches[0].clientX-u,w=b.touches[0].clientY-h,S=l.bbox,M=S.max[0]-S.min[0],E=S.max[1]-S.min[1],R=M/c.width;S.min[0]-=v*R,S.max[0]-=v*R,S.min[1]+=w*R,S.max[1]+=w*R,l.updateConfig({bbox:S}),u=b.touches[0].clientX,h=b.touches[0].clientY}else if(b.touches.length===2){let v=b.touches[1].clientX-b.touches[0].clientX,w=b.touches[1].clientY-b.touches[0].clientY,S=Math.sqrt(v*v+w*w);if(p>0){let M=p/S,E=l.bbox,R=E.max[1]-E.min[1],I=(E.min[0]+E.max[0])/2,B=(E.min[1]+E.max[1])/2,z=R*M,K=c.width/c.height,F=z*K;E.min[0]=I-F/2,E.max[0]=I+F/2,E.min[1]=B-z/2,E.max[1]=B+z/2,l.updateConfig({bbox:E})}p=S}b.preventDefault()}),c.addEventListener("touchend",()=>{d=!1,p=0,f()});function x(b){let v=l.bbox,w=v.max[0]-v.min[0],S=v.max[1]-v.min[1],M=(v.min[0]+v.max[0])/2,E=(v.min[1]+v.max[1])/2,R=S*b,I=c.width/c.height,B=R*I;v.min[0]=M-B/2,v.max[0]=M+B/2,v.min[1]=E-R/2,v.max[1]=E+R/2,l.updateConfig({bbox:v}),f()}function y(b,v){let w=l.bbox,S=w.max[0]-w.min[0],M=w.max[1]-w.min[1],E=S*b*.1,R=M*v*.1;w.min[0]+=E,w.max[0]+=E,w.min[1]+=R,w.max[1]+=R,l.updateConfig({bbox:w}),f()}$("#zoom-in").on("click",()=>x(.9)),$("#zoom-out").on("click",()=>x(1.11)),$("#pan-up").on("click",()=>y(0,1)),$("#pan-down").on("click",()=>y(0,-1)),$("#pan-left").on("click",()=>y(-1,0)),$("#pan-right").on("click",()=>y(1,0)),$("#pan-up-left").on("click",()=>y(-1,1)),$("#pan-up-right").on("click",()=>y(1,1)),$("#pan-down-left").on("click",()=>y(-1,-1)),$("#pan-down-right").on("click",()=>y(1,-1)),$("#pan-reset").on("click",function(){let b=l.bbox,v=b.max[0]-b.min[0],w=b.max[1]-b.min[1];l.updateConfig({bbox:{min:[-v/2,-w/2],max:[v/2,w/2]},reinitializeParticles:!1}),f()})}function i(l,c){let d=document.getElementById("grid-canvas"),u=d.getContext("2d"),h=$("#cursor-position"),g=$("#show-grid").is(":checked"),f=0,p=0;function x(){d.width=c.width,d.height=c.height,w()}function y(F,A){let C=l.bbox,V=C.max[0]-C.min[0],D=C.max[1]-C.min[1],k=C.min[0]+F/c.width*V,U=C.max[1]-A/c.height*D;return{x:k,y:U}}function b(F,A){let C=l.bbox,V=C.max[0]-C.min[0],D=C.max[1]-C.min[1],k=(F-C.min[0])/V*c.width,U=(C.max[1]-A)/D*c.height;return{x:k,y:U}}function v(){let F=l.bbox,V=(F.max[0]-F.min[0])/10,D=Math.pow(10,Math.floor(Math.log10(V))),k=V/D,U;return k<1.5?U=1*D:k<3.5?U=2*D:k<7.5?U=5*D:U=10*D,U}function w(){if(!g){u.clearRect(0,0,d.width,d.height);return}u.clearRect(0,0,d.width,d.height);let F=l.bbox,A=v(),C=Math.floor(F.min[0]/A)*A,V=Math.ceil(F.max[0]/A)*A;u.strokeStyle="rgba(255, 255, 255, 0.1)",u.lineWidth=1,u.font="10px Courier New",u.fillStyle="rgba(255, 255, 255, 0.5)";for(let G=C;G<=V;G+=A){let Y=b(G,0);if(u.beginPath(),u.moveTo(Y.x,0),u.lineTo(Y.x,d.height),u.stroke(),Math.abs(G)<1e-4)continue;let Re=G.toFixed(Math.max(0,-Math.floor(Math.log10(A))));u.fillText(Re,Y.x+3,d.height-5)}let D=Math.floor(F.min[1]/A)*A,k=Math.ceil(F.max[1]/A)*A;for(let G=D;G<=k;G+=A){let Y=b(0,G);if(u.beginPath(),u.moveTo(0,Y.y),u.lineTo(d.width,Y.y),u.stroke(),Math.abs(G)<1e-4)continue;let Re=G.toFixed(Math.max(0,-Math.floor(Math.log10(A))));u.fillText(Re,5,Y.y-3)}let U=b(0,0);u.strokeStyle="rgba(255, 255, 255, 0.3)",u.lineWidth=2,U.y>=0&&U.y<=d.height&&(u.beginPath(),u.moveTo(0,U.y),u.lineTo(d.width,U.y),u.stroke(),u.fillText("0",U.x+3,U.y-3)),U.x>=0&&U.x<=d.width&&(u.beginPath(),u.moveTo(U.x,0),u.lineTo(U.x,d.height),u.stroke())}function S(){let F=y(f,p),A=c.getBoundingClientRect(),C=f-A.left,V=p-A.top,D=l.readPixelAt(C,V),k=`x: ${F.x.toFixed(3)}, y: ${F.y.toFixed(3)}`;if(D){if(D.hdr){let[U,G,Y]=D.hdr;k+=`
HDR: (${U.toFixed(3)}, ${G.toFixed(3)}, ${Y.toFixed(3)})`}if(D.ldr){let[U,G,Y]=D.ldr;k+=`
LDR: (${U.toFixed(3)}, ${G.toFixed(3)}, ${Y.toFixed(3)})`}}h.html(k.replace(/\n/g,"<br>"))}c.addEventListener("mousemove",F=>{f=F.clientX,p=F.clientY,S()}),$("#show-grid").on("change",function(){g=$(this).is(":checked"),w()}),window.addEventListener("resize",x),setInterval(w,100);let M=document.querySelector("#fps-counter .fps-display");function E(F){if(F>=1e3){let A=F/1e3;return A%1===0?`${Math.floor(A)}k`:`${A.toFixed(1)}k`}return F.toString()}function R(){if(l&&l.fps!==void 0){let F=l.totalFrames!==void 0?` | ${E(l.totalFrames)} frames`:"";M.textContent=`FPS: ${l.fps}${F}`}}setInterval(R,500);let I=$("#histogram-panel"),B=document.getElementById("histogram-canvas"),z=B.getContext("2d");$("#histogram-header").on("click",function(){I.toggleClass("collapsed"),$("#histogram-expand").text(I.hasClass("collapsed")?"\u25B6":"\u25BC")});function K(){if(!l)return;let F=l.getBufferStats();if(!F||!F.histogram||F.histogram.length===0)return;let A=B,C=z,V=window.devicePixelRatio||1;A.width=A.clientWidth*V,A.height=A.clientHeight*V,C.scale(V,V);let D=A.clientWidth,k=A.clientHeight;C.fillStyle="rgba(0, 0, 0, 0.3)",C.fillRect(0,0,D,k);let U=Math.max(...F.histogram);if(U===0)return;let G=D/F.histogram.length;C.fillStyle="#4CAF50",F.histogram.forEach((Y,Re)=>{let At=Y/U*(k-4),fi=Re*G,pi=k-At;C.fillRect(fi,pi,G-1,At)}),$("#hist-avg").text(F.avgBrightness.toFixed(1)),$("#hist-max").text(F.maxBrightness.toFixed(0)),F.maxVelocity!==void 0&&F.maxVelocity!==null?$("#hist-vel").text(F.maxVelocity.toFixed(2)):$("#hist-vel").text("--")}setInterval(K,1e3),x(),S()}function r(l){document.addEventListener("keydown",c=>{if(c.key==="c"&&!c.ctrlKey&&!c.altKey&&!c.metaKey&&!c.shiftKey){if(c.target.tagName==="INPUT"||c.target.tagName==="TEXTAREA")return;c.preventDefault(),l.clearScreen(),a.info("Screen cleared via keyboard shortcut (C)")}})}function o(l,c){let d=null;$("#open-animation-panel").on("click",function(){$("#animation-panel").toggle()}),$("#animation-script-input").on("change",function(u){let h=u.target.files[0];if(!h)return;let g=new FileReader;g.onload=function(f){try{let p=JSON.parse(f.target.result);d=new wt(l,c);let x=d.loadScript(p);$("#anim-name").text(x.name);let y=x.timeline[x.timeline.length-1].time,b=Math.ceil(y*x.fps);$("#anim-param").text(`${x.timeline.length} keyframes`),$("#anim-range").text(`0s \u2192 ${y}s`),$("#anim-frames").text(b),$("#anim-fps").text(x.fps),$("#anim-duration").text(`${y.toFixed(1)}s`),$("#animation-info").show(),$("#animation-run-btn").prop("disabled",!1),$("#animation-download-btn").prop("disabled",!0),a.info(`Animation script loaded: ${x.name}`)}catch(p){alert("Failed to load animation script: "+p.message),a.error("Animation script load failed",p)}},g.readAsText(h)}),$("#animation-run-btn").on("click",async function(){if(d)try{$("#animation-run-btn").prop("disabled",!0),$("#animation-pause-btn").prop("disabled",!1),$("#animation-stop-btn").prop("disabled",!1),$("#animation-script-input").prop("disabled",!0),$("#animation-progress").show(),await d.run((u,h,g)=>{let f=u/h*100;$("#progress-bar").css("width",f+"%"),$("#progress-text").text(`Frame ${u} / ${h}`),$("#progress-param").text(`Time: ${g.toFixed(2)}s`)}),a.info("Animation complete!"),alert("Animation complete! "+d.frames.length+" frames captured."),$("#animation-download-btn").prop("disabled",!1)}catch(u){a.error("Animation failed",u),alert("Animation failed: "+u.message)}finally{$("#animation-run-btn").prop("disabled",!1),$("#animation-pause-btn").prop("disabled",!0),$("#animation-stop-btn").prop("disabled",!0),$("#animation-script-input").prop("disabled",!1)}}),$("#animation-pause-btn").on("click",function(){d&&(d.isPaused?(d.resume(),$(this).text("\u23F8 Pause"),a.info("Animation resumed")):(d.pause(),$(this).text("\u25B6 Resume"),a.info("Animation paused")))}),$("#animation-stop-btn").on("click",function(){d&&(d.stop(),a.info("Animation stopped"),$("#animation-run-btn").prop("disabled",!1),$("#animation-pause-btn").prop("disabled",!0),$("#animation-stop-btn").prop("disabled",!0),$("#animation-script-input").prop("disabled",!1))}),$("#animation-download-btn").on("click",async function(){if(!(!d||d.frames.length===0))try{$(this).prop("disabled",!0),$(this).text("\u{1F4BE} Downloading..."),await d.downloadFrames(),$(this).text("\u2713 Downloaded"),setTimeout(()=>{$(this).text("\u{1F4BE} Download Frames (ZIP)"),$(this).prop("disabled",!1)},2e3)}catch(u){a.error("Download failed",u),alert("Download failed: "+u.message),$(this).text("\u{1F4BE} Download Frames (ZIP)"),$(this).prop("disabled",!1)}}),a.info("Animation panel initialized")}function s(){let l="accordionState",c={};try{let d=localStorage.getItem(l);d&&(c=JSON.parse(d))}catch(d){console.warn("Failed to load accordion state",d)}$("#controls h2").each(function(d){let u=$(this),h=u.next(".accordion-section");if(h.length===0)return;let g=u.text().trim();(c.hasOwnProperty(g)?c[g]:d>0)?(u.addClass("collapsed"),h.addClass("collapsed")):h.css("max-height",h[0].scrollHeight+"px"),u.on("click",function(){let x=$(this),y=x.next(".accordion-section"),b=x.hasClass("collapsed");b?(x.removeClass("collapsed"),y.css("max-height",y[0].scrollHeight+"px"),y.removeClass("collapsed")):(y.css("max-height",y[0].scrollHeight+"px"),y[0].offsetHeight,y.css("max-height","0"),x.addClass("collapsed"),y.addClass("collapsed")),c[g]=!b;try{localStorage.setItem(l,JSON.stringify(c))}catch(v){console.warn("Failed to save accordion state",v)}});let p=()=>{h.hasClass("collapsed")||h.css("max-height",h[0].scrollHeight+"px")};typeof ResizeObserver<"u"&&new ResizeObserver(p).observe(h[0])}),a.info("Accordion initialized with "+$("#controls h2").length+" sections")}s(),n(function(l,c){t(l,c),i(l,c),r(l),e(l,c)})});})();
//# sourceMappingURL=app.min.js.map
